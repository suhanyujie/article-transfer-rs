>* Advent of Code 2020 Day2 译文（Advent of Code 2020 第2天）
>* 原文链接：https://fasterthanli.me/series/advent-of-code-2020/part-2
>* 原文作者：[Amos](https://twitter.com/fasterthanlime)
>* 译文来自：https://github.com/suhanyujie/article-transfer-rs/
>* 译者：[suhanyujie](https://ishenghuo.cnblogs.com/)
>* ps：水平有限，如有不当之处，欢迎指正
>* 标签：Rust，advent of code, algo

酷熊：第二天，第二天啦！

[Advent of Code 2020](https://adventofcode.com/2020/day/2) 第 2 天的问题描述的是密码相关。听起来有点熟悉。

基本上，输入是这样的:

```
1-3 a: abcde
1-3 b: cdefg
2-9 c: ccccccccc
```

每一行包含一个“password policy”和一个“password”。对于第一行，策略是密码必须是 1~3(包括 3)次字母“a”。

酷熊：那么，会有更多的解析吧？
Amos: 更多解析。

好吧，和第一天一样，我们创建一个新项目:

```shell
$ cargo new day2
     Created binary (application) `day2` package
$ cd day2
$ cargo add anyhow
      Adding anyhow v1.0.35 to dependencies
```

将我们的输入添加到 `day2/src/input.txt`，然后:

```rust
// in `day2/src/main.rs`

fn main() -> anyhow::Result<()> {
    let input = include_str!("input.txt");

    Ok(())
}
```

因此，每一行都包含一个密码策略和一个密码。让我们开始考虑如何用类型来表示它。

策略有一定的范围和一个字符。

酷熊：它是一个字符吗? 输入难道不都是我们的 ASCII？
Amos: 是的！
酷熊：所以我们可以只用字节，对吧？
Amos: 我想是的！

```rust
use std::ops::RangeInclusive;

struct PasswordPolicy {
    byte: u8,
    range: RangeInclusive<usize>,
}
```

接下来，我们可能需要一个函数来解析一行，并返回 `PasswordPolicy` 和(我猜想) 应该是  `&str`？

酷熊：是啊，如果我们处理的是字节，没问题。

```rust
fn parse_line(s: &str) -> anyhow::Result<(PasswordPolicy, &str)> {
    todo!()
}
```

我们还需要一些方法来确保密码与给定的 `PasswordPolicy` 匹配:

```rust
impl PasswordPolicy {
    fn is_valid(&self, password: &str) -> bool {
        todo!()
    }
}
```

酷熊：好多 todo 啊！我们能不能至少勾勒出所有这些函数的主要功能？

第 1 部分的问题是，根据它们的策略，有多少密码是有效的，因此，当然，现在我们已经掌握了所有的已知条件，我们可以这样做:

```rust
fn main() -> anyhow::Result<()> {
    let count = include_str!("input.txt")
        .lines()
        .map(parse_line)
        .map(Result::unwrap)
        .filter(|(policy, password)| policy.is_valid(password))
        .count();
    println!("{} passwords are valid", count);

    Ok(())
}
```

酷熊：啊，太棒了! `lines` 是干什么用的? 是不是类似于 `split('\n')`？
Amos: 差不多! 它也适用于 `\r\n`(CRLF) ，也就是“Windows 风格的行结尾”。
酷熊：这次我们没有 `collect` 为 `Result` 吗？
Amos: 不，我想强调的是，我们可以使用 `filter` 和 `count` 来解答问题，而不需要收集任何数据。全都是流式操作！
酷熊：我们接下来要实现什么？

我们试一下 `is_valid`。

一般来说我们只关心字节，因为输入只是 ASCII 字符，所以我们不必关心 [UTF-8 编码](https://fasterthanli.me/articles/working-with-strings-in-rust)。

[str::as_bytes](https://doc.rust-lang.org/stable/std/primitive.str.html#method.as_bytes) 方法返回了 `&[u8]` ，从那里我们可以使用我们所熟悉的迭代器方法:


```Rust
impl PasswordPolicy {
    fn is_valid(&self, password: &str) -> bool {
        self.range.contains(
            &password
                .as_bytes()
                .iter()
                .copied()
                .filter(|&b| b == self.byte)
                .count(),
        )
    }
}
```

酷熊：等一下，`.copied()` 是什么？
Amos: 好的，`password.as_bytes().iter()` 提供了迭代器 `Iterator<Item = &u8>`。
而且碰巧 `u8` 是一个 [Copy](https://doc.rust-lang.org/stable/std/marker/trait.Copy.html) 类型-我们不必担心它的所有权，而且它的开销比较小，嗯，复制的开销。

酷熊：啊，那么 `.copied()` 将其转换为 `Iterator<Item = u8>`？然后我们可以直接操作 `u8` 值，而不是像 `&u8` 这样的引用？
Amos: 差不多，是的! 还有一点是当 iter 是迭代器 `Iterator<Item = T>` 时，`iter.filter()` 会传递 `&T`。
酷熊：啊，因为我们在**过滤**，所以我们不能“消费”这些项，我们只是想读取它们，然后决定是否保留它们。
Amos: 没错！

——待续 `Exactly!`——












