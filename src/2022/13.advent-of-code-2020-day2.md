>* Advent of Code 2020 Day2 译文（Advent of Code 2020 第2天）
>* 原文链接：https://fasterthanli.me/series/advent-of-code-2020/part-2
>* 原文作者：[Amos](https://twitter.com/fasterthanlime)
>* 译文来自：https://github.com/suhanyujie/article-transfer-rs/
>* 译者：[suhanyujie](https://ishenghuo.cnblogs.com/)
>* ps：水平有限，如有不当之处，欢迎指正
>* 标签：Rust，advent of code, algo

酷熊：第二天，第二天啦！

[Advent of Code 2020](https://adventofcode.com/2020/day/2) 第 2 天的问题描述的是密码相关。听起来有点熟悉。

基本上，输入是这样的:

```
1-3 a: abcde
1-3 b: cdefg
2-9 c: ccccccccc
```

每一行包含一个“password policy”和一个“password”。对于第一行，策略是密码必须是 1~3(包括 3)次字母“a”。

酷熊：那么，会有更多的解析吧？
Amos: 更多解析。

好吧，和第一天一样，我们创建一个新项目:

```shell
$ cargo new day2
     Created binary (application) `day2` package
$ cd day2
$ cargo add anyhow
      Adding anyhow v1.0.35 to dependencies
```

将我们的输入添加到 `day2/src/input.txt`，然后:

```rust
// in `day2/src/main.rs`

fn main() -> anyhow::Result<()> {
    let input = include_str!("input.txt");

    Ok(())
}
```

因此，每一行都包含一个密码策略和一个密码。让我们开始考虑如何用类型来表示它。

策略有一定的范围和一个字符。

酷熊：它是一个字符吗? 输入难道不都是我们的 ASCII？
Amos: 是的！
酷熊：所以我们可以只用字节，对吧？
Amos: 我想是的！

```rust
use std::ops::RangeInclusive;

struct PasswordPolicy {
    byte: u8,
    range: RangeInclusive<usize>,
}
```

接下来，我们可能需要一个函数来解析一行，并返回 `PasswordPolicy` 和(我猜想) 应该是  `&str`？

酷熊：是啊，如果我们处理的是字节，没问题。

```rust
fn parse_line(s: &str) -> anyhow::Result<(PasswordPolicy, &str)> {
    todo!()
}
```

我们还需要一些方法来确保密码与给定的 `PasswordPolicy` 匹配:

```rust
impl PasswordPolicy {
    fn is_valid(&self, password: &str) -> bool {
        todo!()
    }
}
```

酷熊：好多 todo 啊！我们能不能至少勾勒出所有这些函数的主要功能？

第 1 部分的问题是，根据它们的策略，有多少密码是有效的，因此，当然，现在我们已经掌握了所有的已知条件，我们可以这样做:

```rust
fn main() -> anyhow::Result<()> {
    let count = include_str!("input.txt")
        .lines()
        .map(parse_line)
        .map(Result::unwrap)
        .filter(|(policy, password)| policy.is_valid(password))
        .count();
    println!("{} passwords are valid", count);

    Ok(())
}
```

酷熊：啊，太棒了! `lines` 是干什么用的? 是不是类似于 `split('\n')`？










