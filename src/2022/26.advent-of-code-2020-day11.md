>* Advent of Code 2020 Day11 译文（用 Rust 实现 Advent of Code 2020 第11天）
>* 原文链接：https://fasterthanli.me/series/advent-of-code-2020/part-11
>* 原文作者：[Amos](https://twitter.com/fasterthanlime)
>* 译文来自：https://github.com/suhanyujie/article-transfer-rs/
>* 译者：[suhanyujie](https://ishenghuo.cnblogs.com/)
>* ps：水平有限，如有不当之处，欢迎指正
>* 标签：Rust，advent of code, algo

新的一天，[新的问题](https://adventofcode.com/2020/day/11)。

这个问题看起来有点像“[康威的生命游戏”（Game of Life）](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life) ，或者是一种老式的[细胞生命自动机](https://en.wikipedia.org/wiki/Cellular_automaton)。

我们有一张这样的地图:

```text
L.LL.LL.LL
LLLLLLL.LL
L.L.L..L..
LLLL.LL.LL
L.LL.LL.LL
L.LLLLL.LL
..L.L.....
LLLLLLLLLL
L.LLLLLL.L
L.LLLLL.LL
```

对于每一次迭代：
- 如果是 `L` 符号，会变成 `#`，如果没有变成 `#`，则在其相邻的 8 个位置一定有一个可以转换成 `#`
- `#` 符号，则变成 `L`，前提是相邻位置中有 4 个以上的单元格是 `#` 
- `.` 符号，则不会改变

这是一个令人感兴趣的问题。我们甚至可以回想一些我们在[第 3 天](https://fasterthanli.me/series/advent-of-code-2020/part-3)做的东西！

首先是 2D vector 类型：

```rust
#[derive(Debug, Clone, Copy, PartialEq)]
struct Vec2 {
    x: i64,
    y: i64,
}
```

然后是 tile 枚举：

```rust
#[derive(Clone, Copy, PartialEq)]
enum Tile {
    Floor,
    EmptySeat,
    OccupiedSeat,
}

impl Default for Tile {
    fn default() -> Self {
        Self::Floor
    }
}
```

为 Tile 实现一个简洁的 `Debug` trait：

```rust
use std::fmt;

impl fmt::Debug for Tile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let c = match self {
            Tile::Floor => '.',
            Tile::EmptySeat => 'L',
            Tile::OccupiedSeat => '#',
        };
        write!(f, "{}", c)
    }
}
```

然后，`Map` —— 这一次，让它通用一些。只是为了好玩！

```rust
struct Map<T> {
    size: Vec2,
    tiles: Vec<T>,
}
```

如果 T 实现了 Default trait，可以很简单地实现 `new`:

```rust
impl<T> Map<T>
where
    T: Default,
{
    fn new(size: Vec2) -> Self {
        let num_tiles = size.x * size.y;
        Self {
            size,
            tiles: (0..num_tiles)
                .into_iter()
                .map(|_| Default::default())
                .collect(),
        }
    }
}
```

然后是 `Map::index`，从 2D 空间到 1D 空间的映射/索引：

```rust
impl<T> Map<T> {
    fn index(&self, pos: Vec2) -> Option<usize> {
        if (0..self.size.x).contains(&pos.x) && (0..self.size.y).contains(&pos.y) {
            Some((pos.x + pos.y * self.size.x) as _)
        } else {
            None
        }
    }
}
```

从这里我们可以很容易地实现 `set`:

```rust
impl<T> Map<T> {
    fn set(&mut self, pos: Vec2, tile: T) {
        if let Some(index) = self.index(pos) {
            self.tiles[index] = tile;
        }
    }
}
```

对于 `get`，我们需要 `T` 是可 Copy 的，这样我们就不需要使用引用：

```rust
impl<T> Map<T>
where
    T: Copy,
{
    fn get(&self, pos: Vec2) -> Option<T> {
        self.index(pos).map(|index| self.tiles[index])
    }
}
```

接下来 —— 我们将不得不处理邻近位置，所以如果我们能够枚举指定单元格的所有邻近位置，那将会非常简洁:

```rust
impl<T> Map<T> {
    fn neighbor_positions(&self, pos: Vec2) -> impl Iterator<Item = Vec2> {
        (-1..=1)
            .map(|dx| (-1..=1).map(move |dy| (dx, dy)))
            .flatten()
            .filter(|&(dx, dy)| !(dx == 0 && dy == 0))
            .map(move |(dx, dy)| Vec2 {
                x: pos.x + dx,
                y: pos.y + dy,
            })
    }
}
```

酷熊：这看起来有点毛骨悚然，测试一下怎么样？

```rust
#[test]
fn test_neighbor_positions() {
    use std::collections::HashSet;

    let map = Map::<()>::new(Vec2 { x: 3, y: 3 });
    let positions: HashSet<_> = map
        .neighbor_positions(Vec2 { x: 1, y: 1 })
        .map(|v| (v.x, v.y))
        .collect();
    for p in &[
        (0, 0),
        (0, 1),
        (0, 2),
        (1, 0),
        (2, 0),
        (1, 2),
        (2, 2),
        (2, 1),
    ] {
        assert!(positions.contains(p));
    }
}
```

```shell
$ cargo t -q

running 1 test
.
test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

酷熊：好吧，继续。

接下来，为了更好地度量，我们可以使用 `.neighbor_tiles` 方法返回 `Tile` 的迭代器！

```rust
impl<T> Map<T>
where
    T: Copy,
{
    fn neighbor_tiles(&self, pos: Vec2) -> impl Iterator<Item = T> + '_ {
        self.neighbor_positions(pos)
            .filter_map(move |pos| self.get(pos))
    }
}
```

酷熊：`+ '_` 是什么意思？

Amos：em，迭代器只有在 `&self` 被借用的情况下，才有效，因为它是从它那里获取的！

酷熊：啊，那么 `impl Iterator<Item = T>` (没有任何附加注释)的生命周期是多少呢？

Amos：就像 `Box<T>` 一样，它默认为 `'static`，这只适用于拥有所有权的类型（比如我们的 `neighbor_positions` 迭代器，它拥有产生数据项所需的所有权），或者，我猜测，真正的 `'static` 引用类似于一个 `const`，或者一些在 [`Box::leak`](https://doc.rust-lang.org/stable/std/boxed/struct.Box.html#method.leak) 或 `include_str` 中泄漏的东西！

好了，现在我们可以开始实现一些细胞自动机逻辑了，让我们基于 `Tile` 做一些处理：

```rust
impl Tile {
    fn next<I>(self, neighbors: I) -> Self
    where
        I: Iterator<Item = Self>,
    {
        match self {
            Self::Floor => Self::Floor,
            Self::EmptySeat => match neighbors
                .filter(|t| matches!(t, Self::OccupiedSeat))
                .count()
            {
                // no one around? we can sit here!
                0 => Self::OccupiedSeat,
                // social distancing please
                _ => Self::EmptySeat,
            },
            Self::OccupiedSeat => {
                match neighbors.filter(|t| matches!(t, Self::OccupiedSeat)).count() {
                    // up to 3 neighbors: still okay for now
                    0..=3 => Self::OccupiedSeat,
                    // that's too many folks!
                    _ => Self::EmptySeat,
                }
            }
        }
    }
}
```






