>* Error Handling in Rust 译文（Rust 中的错误处理）
>* 原文链接：https://blog.burntsushi.net/rust-error-handling/
>* 原文作者：[Andrew Gallant](https://github.com/BurntSushi)
>* 译文来自：https://github.com/suhanyujie/article-transfer-rs/
>* 译者：[suhanyujie](https://github.com/suhanyujie)
>* 译者博客：[suhanyujie](https://ishenghuo.cnblogs.com/)
>* ps：水平有限，翻译不当之处，还请指正。
>* 标签：Rust，error handling

Like most programming languages, Rust encourages the programmer to handle errors in a particular way. Generally speaking, error handling is divided into two broad categories: exceptions and return values. Rust opts for return values.

像大多数编程语言一样，Rust 鼓励程序员用特定的方式处理错误。一般来说，错误处理分为两大类: 异常和返回值。Rust 选择返回值。

In this article, I intend to provide a comprehensive treatment of how to deal with errors in Rust. More than that, I will attempt to introduce error handling one piece at a time so that you’ll come away with a solid working knowledge of how everything fits together.

在本文中，我打算详细讲解 Rust 中如何处理错误。更重要的是，我将尝试分多个阶段解释错误处理，这样你会知道，如何将所有部分组合在一起使用。

When done naively, error handling in Rust can be verbose and annoying. This article will explore those stumbling blocks and demonstrate how to use the standard library to make error handling concise and ergonomic.

按原始的做法，Rust 中的错误处理可能是冗长和烦人的。本文将探索这些障碍，并演示如何使用标准库使错误处理更简洁且符合人体工程学。

Target audience: Those new to Rust that don’t know its error handling idioms yet. Some familiarity with Rust is helpful. (This article makes heavy use of some standard traits and some very light use of closures and macros.)

目标受众: 那些初学者还不知道惯用的错误处理。因而本文对 Rust 稍微熟悉一下是有帮助的。(本文大量使用了一些标准的 trait，以及一些非常轻量级的闭包和宏。)

Update (2018/04/14): Examples were converted to ?, and some text was added to give historical context on the change.

更新(2018/04/14) : 示例中多处错误返回被转换为 `?`，并添加了一些文本以说明更改的背景和原因。

Update (2020/01/03): A recommendation to use failure was removed and replaced with a recommendation to use either Box<Error + Send + Sync> or anyhow.

更新(2020/01/03) : 移除使用 failure 的建议，取而代之的是使用 `Box<Error + Send + Sync>` 或使用 anyhow。

## 简要说明
All code samples in this post compile with Rust 1.0.0-beta.5. They should continue to work as Rust 1.0 stable is released.

本文中的所有代码示例都使用 `Rust 1.0.0-beta.5` 编译。Rust 1.0 稳定发布，他们应该也能正常工作。

All code can be found and compiled in my blog’s repository.

所有代码都可以在我[博客的仓库](https://github.com/BurntSushi/blog/tree/master/code/rust-error-handling)中找到并编译。

The Rust Book has a section on error handling. It gives a very brief overview, but doesn’t (yet) go into enough detail, particularly when working with some of the more recent additions to the standard library.

Rust 书有一个关于错误处理的章节。它提供了一个非常简短的概述，但不够详细，特别标准库中最近添加的内容。

## 运行代码
If you’d like to run any of the code samples below, then the following should work:

如果你想运行下面的任何一个代码示例，那么可以试试下面的代码:

```
$ git clone git://github.com/BurntSushi/blog
$ cd blog/code/rust-error-handling
$ cargo run --bin NAME-OF-CODE-SAMPLE [ args ... ]
```

Each code sample is labeled with its name. (Code samples without a name aren’t available to be run this way. Sorry.)

每个代码示例都带有标签。(没有名称的代码示例不能以这种方式运行。对不起。)

## 目录
This article is very long, mostly because I start at the very beginning with sum types and combinators, and try to motivate the way Rust does error handling incrementally. As such, programmers with experience in other expressive type systems may want to jump around. Here’s my very brief guide:

这篇文章很长，主要是因为我从一开始就从和类型和组合子开始，并试图逐步地说明 Rust 处理错误的方式。因此，在其他表达型系统方面有经验的程序员可能希望跳来跳去。以下是我的简短指南:

* 如果你是 Rust、系统编程和表达型系统方面不熟悉，那么从头开始，一步一步来。(如果完全不懂，你可能应该先阅读一下 Rust book)
* 如果你以前从未见过 Rust，但对函数式语言(“代数数据类型”和“组合子”让你感到温暖和模糊)有经验，那么你可以跳过这些基础知识，先浏览一下 [多种错误类型](https://blog.burntsushi.net/rust-error-handling/#working-with-multiple-error-types), 你已经完全理解了[标准库 error trait](https://blog.burntsushi.net/rust-error-handling/#standard-library-traits-used-for-error-handling)。略读基本的语法可能可能会更好。你也可能需要[查阅 Rust 书](http://doc.rust-lang.org/1.0.0-beta.5/book/) 看看 Rust 闭包和宏。
* 如果您已经有了 Rust 方面的经验，并且只是想了解错误处理的细节，那么您可以直接跳过这部分直到文章最后。你可能会发现研究一些[个案](https://blog.burntsushi.net/rust-error-handling/#case-study-a-program-to-read-population-data)示例非常有用。

---

* 基本知识
    * unwrap 的详细解释
    * `Option` 类型
        * `Option<T>` 值的作用
    * Result 类型
        * 解析整数
        * `Result` 类型常用别名
    * 一个简短的插曲: 使用 unwrap 并不是坏事
* 处理多种错误类型
    * 组合 `Option` 和 `Result`
    * 组合子的局限
    * 提前返回
    * try! 宏/? 操作符
    * 自定义错误类型
* 用于错误处理的标准库 trait
    * Error trait
    * From trait
    * 真实的 try! 宏/? 操作符
    * 组合自定义错误类型
    * 给库作者的建议
* 案例研究: 读取人口数据的程序
    * Github 仓库
    * 初始化设置
    * 参数解析
    * 写逻辑
    * 使用 `Box<Error>` 进行错误处理
    * 从 stdin 中读取
    * 使用自定义类型进行错误处理
    * 添加功能
* 总结

## 基本知识
I like to think of error handling as using case analysis to determine whether a computation was successful or not. As we will see, the key to ergonomic error handling is reducing the amount of explicit case analysis the programmer has to do while keeping code composable.

我喜欢将错误处理看作是使用案例分析来确定计算是否成功。正如我们将看到的，符合人体工程学的错误处理的关键是减少程序员在保持代码可组合性的同时必须进行的显式案例分析的数量。

Keeping code composable is important, because without that requirement, we could panic whenever we come across something unexpected. (panic causes the current task to unwind, and in most cases, the entire program aborts.) Here’s an example:

保持代码的可组合性非常重要，因为如果没有这个需求，我们可能会在遇到非正常情况时发生 panic。(panic 让当前任务调用链展开，大多数情况下，整个程序会中止。)下面是一个例子:

```
// panic-simple
// 猜 0 和 10 之间的数
// 如果匹配上之前设定好的数值，返回 true，否则返回 false
fn guess(n: i32) -> bool {
    if n < 1 || n > 10 {
        panic!("Invalid number: {}", n);
    }
    n == 5
}

fn main() {
    guess(11);
}
```

(If you like, it’s easy to run this code.)

(如果您愿意，运行这段代码很容易。)

If you try running this code, the program will crash with a message like this:

如果你尝试运行这段代码，程序会崩溃，并发出如下信息:

```
thread '<main>' panicked at 'Invalid number: 11', src/bin/panic-simple.rs:5
```

Here’s another example that is slightly less contrived. A program that accepts an integer as an argument, doubles it and prints it.

这里还有一个稍微不那么矫揉造作的例子。接受一个整数作为参数的程序，将其加倍并打印出来。

```
// unwrap-double
// unwrap 两次
use std::env;

fn main() {
    let mut argv = env::args();
    let arg: String = argv.nth(1).unwrap(); // error 1
    let n: i32 = arg.parse().unwrap(); // error 2
    println!("{}", 2 * n);
}

// $ cargo run --bin unwrap-double 5
// 10
```

If you give this program zero arguments (error 1) or if the first argument isn’t an integer (error 2), the program will panic just like in the first example.

如果给这个程序零个参数(错误1) ，或者如果第一个参数不是整数(错误2) ，那么程序就会像上面的示例一样陷入崩溃。

I like to think of this style of error handling as similar to a bull running through a china shop. The bull will get to where it wants to go, but it will trample everything in the process.

我喜欢把这种错误处理方式想象成一头公牛在瓷器店里奔跑。公牛会去它想去的地方，但是在这个过程中它会践踏一切。

### 解开包装（unwrap）
In the previous example (unwrap-double), I claimed that the program would simply panic if it reached one of the two error conditions, yet, the program does not include an explicit call to panic like the first example (panic-simple). This is because the panic is embedded in the calls to unwrap.

在前面的示例 (unwrap-double) 中，我声称如果程序出现两个错误中的一个，它将简单地 panic，然而，该程序没有像第一个示例 (panic-simple) 那样显式地进行 panic。这是因为这种 panic 嵌入在要求 unwrap 的调用中。

To “unwrap” something in Rust is to say, “Give me the result of the computation, and if there was an error, just panic and stop the program.” It would be better if I just showed the code for unwrapping because it is so simple, but to do that, we will first need to explore the Option and Result types. Both of these types have a method called unwrap defined on them.

“unwrap” 调用在 Rust 中的解释是，“给我计算结果，如果有错误，只要 panic 并停止程序即可。”，如果我只显示展开后地结果会更好，因为它非常简单，但是要做到这一点，我们首先需要探索 `Option` 和 `Result` 类型。这两种类型都有一个名为 `unwrap` 的方法。

### Option 类型
The Option type is defined in the standard library:

在[标准库中](http://doc.rust-lang.org/std/option/enum.Option.html)定义了 `Option` 类型:

```
// option-def
enum Option<T> {
    None,
    Some(T),
}
```

The Option type is a way to use Rust’s type system to express the possibility of absence. Encoding the possibility of absence into the type system is an important concept because it will cause the compiler to force the programmer to handle that absence. Let’s take a look at an example that tries to find a character in a string:

Option 类型是用 Rust 类型系统来表示缺失的可能性的一种方式。将缺失的可能性编码到类型系统中是一个重要的概念，因为它将导致编译器强制程序员处理缺失的情况。让我们来看一个在字符串中查找子字符的例子:

```
// option-ex-string-find
// Searches `haystack` for the Unicode character `needle`. If one is found, the
// byte offset of the character is returned. Otherwise, `None` is returned.
fn find(haystack: &str, needle: char) -> Option<usize> {
    for (offset, c) in haystack.char_indices() {
        if c == needle {
            return Some(offset);
        }
    }
    None
}
```

(Pro-tip: don’t use this code. Instead, use the find method from the standard library.)

(提示: 生产中不要使用此代码，而是使用标准库中的 [`find`](http://doc.rust-lang.org/std/primitive.str.html#method.find) 方法。)

Notice that when this function finds a matching character, it doesn’t just return the offset. Instead, it returns Some(offset). Some is a variant or a value constructor for the Option type. You can think of it as a function with the type fn<T>(value: T) -> Option<T>. Correspondingly, None is also a value constructor, except it has no arguments. You can think of None as a function with the type fn<T>() -> Option<T>.

注意，当这个函数找到匹配的字符时，它不仅仅返回 offset。相反，它返回 `Some(offset)`。`Some` 是 `Option` 类型的变体或值构造器。你可以把它看作类型为 `fn<T>(value: T) -> Option<T>` 的函数。相应的，`None` 也是一个值构造器，只是它没有参数。您可以将 `None` 看作是 `fn<T>() -> Option<T>` 类型的函数。

This might seem like much ado about nothing, but this is only half of the story. The other half is using the find function we’ve written. Let’s try to use it to find the extension in a file name.

这可能看起来像无事生非，但这只是故事的一半。另一半是使用我们编写的 `find` 函数。让我们尝试使用它来查找文件名中的扩展名。

```rust
//option-ex-string-find
fn main_find() {
    let file_name = "foobar.rs";
    match find(file_name, '.') {
        None => println!("No file extension found."),
        Some(i) => println!("File extension: {}", &file_name[i+1..]),
    }
}
```

This code uses pattern matching to do case analysis on the Option<usize> returned by the find function. In fact, case analysis is the only way to get at the value stored inside an Option<T>. This means that you, as the programmer, must handle the case when an Option<T> is None instead of Some(t).

这段代码使用模式匹配来对 find 函数返回的 `Option<usize>` 进行匹配。实际上，case 匹配是获取 `Option<T>` 中存储的值的唯一方法。这意味着，作为程序员，当 `Option<T>` 是 `None` 而不是 `Some(t)` 时，必须处理这种情况。

But wait, what about unwrap used in unwrap-double? There was no case analysis there! Instead, the case analysis was put inside the unwrap method for you. You could define it yourself if you want:

但是等等，用 unwrap-double 例子中的 unwrap 怎么样？那里没有 case 分析！相反，case 分析被放在 unwrap 方法中。如果你愿意，你可以自己定义它:

```rust
//option-def-unwrap
enum Option<T> {
    None,
    Some(T),
}

impl<T> Option<T> {
    fn unwrap(self) -> T {
        match self {
            Option::Some(val) => val,
            Option::None =>
              panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}
```

The `unwrap` method abstracts away the _case analysis_. This is precisely the thing that makes unwrap ergonomic to use. Unfortunately, that panic! means that unwrap is not composable: it is the bull in the china shop.

`unwrap` 方法抽象出了案例分析（case analysis）。这正使 unwrap 的使用更加符合人体工程学。不幸的是，`panic!` 意味着 unwrap 是不可组合的: 它是瓷器店里的公牛（前面提到的比喻）。

### `Option<T>` 值的组合
In option-ex-string-find we saw how to use find to discover the extension in a file name. Of course, not all file names have a . in them, so it’s possible that the file name has no extension. This possibility of absence is encoded into the types using Option<T>. In other words, the compiler will force us to address the possibility that an extension does not exist. In our case, we just print out a message saying as such.

在 `option-ex-string-find` 示例中，我们看到了如何使用 `find` 来查找文件名中的扩展名。当然，并非所有文件名都有。所以文件名可能没有扩展名。这种_缺失的可能性_被编码到使用 `Option<T>` 的类型中。换句话说，编译器将强迫我们额外处理不存在的可能性。在我们的例子中，我们只是打印出一条消息说明这一点。

Getting the extension of a file name is a pretty common operation, so it makes sense to put it into a function:

获取文件名的扩展名是一个非常常见的操作，所以把它放到一个函数中是有意义的:

```rust
//option-ex-string-find
// Returns the extension of the given file name, where the extension is defined
// as all characters succeeding the first `.`.
// If `file_name` has no `.`, then `None` is returned.
fn extension_explicit(file_name: &str) -> Option<&str> {
    match find(file_name, '.') {
        None => None,
        Some(i) => Some(&file_name[i+1..]),
    }
}
```

(Pro-tip: don’t use this code. Use the extension method in the standard library instead.)

(专业提示: 生产环境中不要使用此代码，而是使用标准库中的 [extension](http://doc.rust-lang.org/std/path/struct.Path.html#method.extension) 方法。)

The code stays simple, but the important thing to notice is that the type of find forces us to consider the possibility of absence. This is a good thing because it means the compiler won’t let us accidentally forget about the case where a file name doesn’t have an extension. On the other hand, doing explicit case analysis like we’ve done in extension_explicit every time can get a bit tiresome.

代码保持简单，但需要注意的重要事情是，`find` 类型迫使我们考虑缺失的可能性。这是一件好事，因为这意味着编译器不会让我们意外地忘记文件名没有扩展名的情况。另一方面，像我们每次在 `extension_ explicit` 中所做的那样进行明确的 case analysis 可能会让人有点厌烦。

In fact, the case analysis in extension_explicit follows a very common pattern: map a function on to the value inside of an Option<T>, unless the option is None, in which case, just return None.

实际上，`extension_ explicit` 中的 case analysis 遵循一个非常常见的模式: 将一个函数映射到 `Option<T>` 中的值，除非值是 `None`，而这是只返回 `None`。

Rust has parametric polymorphism, so it is very easy to define a combinator that abstracts this pattern:

Rust 有参数多态，所以很容易定义一个组合子来抽象这种模式:

```rust
// option-map
fn map<F, T, A>(option: Option<T>, f: F) -> Option<A> where F: FnOnce(T) -> A {
    match option {
        None => None,
        Some(value) => Some(f(value)),
    }
}
```

Indeed, map is defined as a method on Option<T> in the standard library.

实际上，map 在标准库中被定义为 `Option<T>` 上的一个方法。

Armed with our new combinator, we can rewrite our extension_explicit method to get rid of the case analysis:

有了新的组合子，我们可以重写 `extension_explicit` 的方法来摆脱 case analysis:

```rust
//option-ex-string-find
// Returns the extension of the given file name, where the extension is defined
// as all characters succeeding the first `.`.
// If `file_name` has no `.`, then `None` is returned.
fn extension(file_name: &str) -> Option<&str> {
    find(file_name, '.').map(|i| &file_name[i+1..])
}
```

One other pattern that I find is very common is assigning a default value to the case when an Option value is None. For example, maybe your program assumes that the extension of a file is rs even if none is present. As you might imagine, the case analysis for this is not specific to file extensions—it can work with any Option<T>:

我发现的另一个非常常见的模式是，当 Option 值为 `None` 时，为 case 分配一个默认值。例如，可能您的程序假设文件的扩展名是 `rs`，即使没有。正如你可能想象的那样，这方面的 `case analysis` 并不是针对文件扩展名 —— 它可以用于任何 `Option<T>` 类型:

```rust
// option-unwrap-or
fn unwrap_or<T>(option: Option<T>, default: T) -> T {
    match option {
        None => default,
        Some(value) => value,
    }
}
```

The trick here is that the default value must have the same type as the value that might be inside the Option<T>. Using it is dead simple in our case:

这里的诀窍是默认值必须与 `Option<T>` 中的值具有相同的类型。在我们的例子中，使用它非常简单:

```rust
//option-ex-string-find
fn main() {
    assert_eq!(extension("foobar.csv").unwrap_or("rs"), "csv");
    assert_eq!(extension("foobar").unwrap_or("rs"), "rs");
}
```

(Note that unwrap_or is defined as a method on Option<T> in the standard library, so we use that here instead of the free-standing function we defined above. Don’t forget to check out the more general unwrap_or_else method.)

(请注意 unwrap_ or 在标准库中被定义为 `Option<T>` 上的一个方法，因此我们在这里使用它来代替上面定义的独立函数。不要忘记查看更为常见的 `unwrap_or_else` 方法

There is one more combinator that I think is worth paying special attention to: and_then. It makes it easy to compose distinct computations that admit the possibility of absence. For example, much of the code in this section is about finding an extension given a file name. In order to do this, you first need the file name which is typically extracted from a file path. While most file paths have a file name, not all of them do. For example, ., .. or /.

我认为还有一个值得特别关注的组合子: `and_then`。它可用于组合成独特的计算，处理“缺失”可能性变得容易。例如，本节中的大部分代码都是关于查找给定文件名的扩展名的。为此，首先需要从文件路径提取的文件名。虽然大多数文件路径都有文件名，但并非所有路径都有文件名。例如：`.`，`..` 或 `/`。

So, we are tasked with the challenge of finding an extension given a file path. Let’s start with explicit case analysis:

因此，我们的任务就是找到一个给定文件路径的扩展名。我们从案例分析开始:

```rust
//option-ex-string-find
fn file_path_ext_explicit(file_path: &str) -> Option<&str> {
    match file_name(file_path) {
        None => None,
        Some(name) => match extension(name) {
            None => None,
            Some(ext) => Some(ext),
        }
    }
}

fn file_name(file_path: &str) -> Option<&str> {
  // implementation elided
  unimplemented!()
}
```

You might think that we could just use the map combinator to reduce the case analysis, but its type doesn’t quite fit. Namely, map takes a function that does something only with the inner value. The result of that function is then always rewrapped with Some. Instead, we need something like map, but which allows the caller to return another Option. Its generic implementation is even simpler than map:

您可能认为我们可以使用 map 组合器来减少 case analysis，但是它的类型并不完全适合。也就是说，map 接受一个只对内部值执行某些操作的函数。函数的结果总是用 `Some` 重新包装。相反，我们需要类似 `map` 的东西，但是它允许调用者返回另一个 `Option`。它的通用实现甚至比 map 更简单:

```rust
// option-and-then
fn and_then<F, T, A>(option: Option<T>, f: F) -> Option<A>
        where F: FnOnce(T) -> Option<A> {
    match option {
        None => None,
        Some(value) => f(value),
    }
}
```

Now we can rewrite our file_path_ext function without explicit case analysis:

现在我们可以重写 file_path_ext 函数，而不需要进行明确的 case analysis:

```rust
//option-ex-string-find
fn file_path_ext(file_path: &str) -> Option<&str> {
    file_name(file_path).and_then(extension)
}
```

The Option type has many other combinators defined in the standard library. It is a good idea to skim this list and familiarize yourself with what’s available—they can often reduce case analysis for you. Familiarizing yourself with these combinators will pay dividends because many of them are also defined (with similar semantics) for Result, which we will talk about next.

Option 类型在标准库中[定义了许多其他的组合子](http://doc.rust-lang.org/std/option/enum.Option.html)。浏览一下这个列表，熟悉一下是个不错的主意 —— 它们通常可以帮你减少 case analysis。熟悉这些组合子将带来好处，因为它们中的许多也是为 `Result` 定义的(具有类似的语义) ，我们将在下面讨论。

Combinators make using types like Option ergonomic because they reduce explicit case analysis. They are also composable because they permit the caller to handle the possibility of absence in their own way. Methods like unwrap remove choices because they will panic if Option<T> is None.

组合子是类似 Option 的人体工程学的类型，因为他们减少了明确的 case analysis。它们也是可组合的，因为它们允许调用者以自己的方式处理缺失的可能性。使用 `unwrap` 这样的方法排除可能性时，如果 `Option<T>` 为 `None`，会发生 panic。

### Result 类型（The Result type）
The Result type is also defined in the standard library:

在标准库中也定义了 Result 类型:

```rust
// result-def
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

The Result type is a richer version of Option. Instead of expressing the possibility of absence like Option does, Result expresses the possibility of error. Usually, the error is used to explain why the result of some computation failed. This is a strictly more general form of Option. Consider the following type alias, which is semantically equivalent to the real Option<T> in every way:

`Result` 类型是 `Option` 的丰富版本。`Result` 表达了错误的可能性，而不是像 `Option` 那样表达缺失的可能性。通常，错误被用来解释为什么一些计算的结果失败。这是一个严格的更一般的选择形式。考虑下面的类型别名，它在语义上与实际的 `Option<T>` 在各个方面都等价:

```rust
//option-as-result
type Option<T> = Result<T, ()>;
```

This fixes the second type parameter of `Result` to always be `()` (pronounced “unit” or “empty tuple”). Exactly one value inhabits the () type: (). (Yup, the type and value level terms have the same notation!)

这样固定了 `Result` 的第二个类型参数为 `()` (发音为“unit”或“empty tuple”)。只有一个值存在于 `()` 类型中: `()`。(是的，类型和值级别的术语有相同的符号!)

The Result type is a way of representing one of two possible outcomes in a computation. By convention, one outcome is meant to be expected or “Ok” while the other outcome is meant to be unexpected or “Err”.

`Result` 类型是表示计算中两种可能结果之一的一种方式。按照惯例，一种意味着结果是预期值或“Ok”，而另一个结果意味着意外或“Err”。

Just like Option, the Result type also has an unwrap method defined in the standard library. Let’s define it:

和 `Option` `一样，Result` 类型也有一个在标准库中定义的 [`unwrap` 方法](http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap):

```rust
// result-def
impl<T, E: ::std::fmt::Debug> Result<T, E> {
    fn unwrap(self) -> T {
        match self {
            Result::Ok(val) => val,
            Result::Err(err) =>
              panic!("called `Result::unwrap()` on an `Err` value: {:?}", err),
        }
    }
}
```

This is effectively the same as our definition for Option::unwrap, except it includes the error value in the panic! message. This makes debugging easier, but it also requires us to add a Debug constraint on the E type parameter (which represents our error type). Since the vast majority of types should satisfy the Debug constraint, this tends to work out in practice. (Debug on a type simply means that there’s a reasonable way to print a human readable description of values with that type.)

这实际上与我们对 [`Option::unwrap` 的定义](https://blog.burntsushi.net/rust-error-handling/#code-option-def-unwrap)相同，只不过它在 `panic!` 中包含了错误值信息。这使得调试更加容易，但是它也要求我们在 E 类型参数(我们的错误类型)上添加 [Debug](http://doc.rust-lang.org/std/fmt/trait.Debug.html) 约束。由于绝大多数类型都应该满足 `Debug` 约束，因此在实践中往往可以做到这一点。(对类型的 Debug 约束意味着有更合理的方法以更加可读的方式打印该类型的值。)

OK, let’s move on to an example.

好，让我们继续来看一个例子。

### 解析整数
The Rust standard library makes converting strings to integers dead simple. It’s so easy in fact, that it is very tempting to write something like the following:

Rust 标准库使字符串转换为整数变得非常简单。事实上，它是如此简单，以至于很容易就写下这样的代码:

```rust
// result-num-unwrap
fn double_number(number_str: &str) -> i32 {
    2 * number_str.parse::<i32>().unwrap()
}

fn main() {
    let n: i32 = double_number("10");
    assert_eq!(n, 20);
}
```

At this point, you should be skeptical of calling unwrap. For example, if the string doesn’t parse as a number, you’ll get a panic:

在这一点上，您应该对调用 unwrap 持怀疑态度。例如，如果字符串没有被解析为一个数字，程序会 panic：

```
thread '<main>' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', /home/rustbuild/src/rust-buildbot/slave/beta-dist-rustc-linux/build/src/libcore/result.rs:729
```

This is rather unsightly, and if this happened inside a library you’re using, you might be understandably annoyed. Instead, we should try to handle the error in our function and let the caller decide what to do. This means changing the return type of double_number. But to what? Well, that requires looking at the signature of the parse method in the standard library:

这是相当难看的，如果这发生在您正在使用的库中，您可能会很难受，这是可以理解的。相反，我们应该尝试处理函数中的错误，让调用者决定要做什么。这意味着更改 `double_number` 的返回类型。但是为了什么？这需要查看标准库中 `parse` 方法的签名:

```rust
impl str {
    fn parse<F: FromStr>(&self) -> Result<F, F::Err>;
}
```

Hmm. So we at least know that we need to use a Result. Certainly, it’s possible that this could have returned an Option. After all, a string either parses as a number or it doesn’t, right? That’s certainly a reasonable way to go, but the implementation internally distinguishes why the string didn’t parse as an integer. (Whether it’s an empty string, an invalid digit, too big or too small.) Therefore, using a Result makes sense because we want to provide more information than simply “absence.” We want to say why the parsing failed. You should try to emulate this line of reasoning when faced with a choice between Option and Result. If you can provide detailed error information, then you probably should. (We’ll see more on this later.)

嗯。所以我们至少知道我们需要使用 `Result`。当然，这也有可能返回一个 `Option`。毕竟，一个字符串要么作为数字解析，要么不作为数字解析，对吗？这当然是一种合理的方式，但是实现在内部区分了为什么字符串没有被解析为整数。(无论是空字符串、无效数字、太大或太小。)因此，使用 `Result` 是有意义的，因为我们希望提供更多的信息，而不仅仅是“缺失”我们想说明解析失败的原因。当面临 Option 和 Result 之间的选择时，您应该试着模仿这种推理方式。如果您可以提供详细的错误信息，那么您可能应该这样做。(我们稍后会看到更多内容。)

OK, but how do we write our return type? The parse method as defined above is generic over all the different number types defined in the standard library. We could (and probably should) also make our function generic, but let’s favor explicitness for the moment. We only care about i32, so we need to find its implementation of FromStr (do a CTRL-F in your browser for “FromStr”) and look at its associated type Err. We did this so we can find the concrete error type. In this case, it’s std::num::ParseIntError. Finally, we can rewrite our function:

好的，但是我们如何选择返回类型呢？上面定义的解析方法是基于泛型，它涵盖了标准库中定义的所有不同数值类型。我们也可以（也许应该）使我们的函数具有通用性，但是让我们先明确一下。我们只关心 `i32`，因此需要找到它的 [`FromStr` 实现](http://doc.rust-lang.org/std/primitive.i32.html)（在浏览器中为执行 CTRL-F 搜索 “FromStr”） ，并查看它的[相关类型](http://doc.rust-lang.org/1.0.0-beta.5/book/associated-types.html) `Err`。我们这样做是为了找到具体的错误类型。在本例中，它是 [std::num::ParseIntError](http://doc.rust-lang.org/std/num/struct.ParseIntError.html)。最后，我们可以重写函数:

```rust
// result-num-no-unwrap
use std::num::ParseIntError;

fn double_number(number_str: &str) -> Result<i32, ParseIntError> {
    match number_str.parse::<i32>() {
        Ok(n) => Ok(2 * n),
        Err(err) => Err(err),
    }
}

fn main() {
    match double_number("10") {
        Ok(n) => assert_eq!(n, 20),
        Err(err) => println!("Error: {:?}", err),
    }
}
```

This is a little better, but now we’ve written a lot more code! The case analysis has once again bitten us.

这是一个更好的一点，但现在我们已经编写了更多的代码！case analysis 再次让我们感到困惑。

Combinators to the rescue! Just like Option, Result has lots of combinators defined as methods. There is a large intersection of common combinators between Result and Option. In particular, map is part of that intersection:

用组合数来拯救！和 `Option` 一样，`Result` 也有很多定义为方法的组合子。Result 和 Option 之间有很多的公共组合子方法。特别是，`map` 就是其中之一:

```rust
// result-num-no-unwrap-map
use std::num::ParseIntError;

fn double_number(number_str: &str) -> Result<i32, ParseIntError> {
    number_str.parse::<i32>().map(|n| 2 * n)
}

fn main() {
    match double_number("10") {
        Ok(n) => assert_eq!(n, 20),
        Err(err) => println!("Error: {:?}", err),
    }
}
```

The usual suspects are all there for Result, including unwrap_or and and_then. Additionally, since Result has a second type parameter, there are combinators that affect only the error type, such as map_err (instead of map) and or_else (instead of and_then).

最常见的疑问都是关于 `Result` 的，包括 [`unwrap_or`](http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or) 和 [`and_then`](http://doc.rust-lang.org/std/result/enum.Result.html#method.and_then) 。此外，由于 `Result` 有第二个类型参数，因此存在一些处理错误类型的组合子，例如 [`map_err`](http://doc.rust-lang.org/std/result/enum.Result.html#method.map_err) （不是 `map`） 和 [`or_else`](http://doc.rust-lang.org/std/result/enum.Result.html#method.or_else) (而不是 `and_then`)。

### Result 类型别名惯用法
In the standard library, you may frequently see types like Result<i32>. But wait, we defined Result to have two type parameters. How can we get away with only specifying one? The key is to define a Result type alias that fixes one of the type parameters to a particular type. Usually the fixed type is the error type. For example, our previous example parsing integers could be rewritten like this:

在标准库中，您可能经常看到 `Result<i32>` 这样的类型。但是等等，我们定义了 `Result` 有两个类型参数。我们怎样才能仅仅指定一个呢？关键是定义一个 `Result` 类型别名，该别名将类型参数之一固定为特定类型。通常被固定的类型是错误类型。例如，我们之前的解析整数的例子可以这样重写:

```rust
// result-num-no-unwrap-map-alias
use std::num::ParseIntError;
use std::result;

type Result<T> = result::Result<T, ParseIntError>;

fn double_number(number_str: &str) -> Result<i32> {
    unimplemented!();
}
```

Why would we do this? Well, if we have a lot of functions that could return ParseIntError, then it’s much more convenient to define an alias that always uses ParseIntError so that we don’t have to write it out all the time.

我们为什么要这么做？好吧，如果我们有很多函数可以返回 `ParseIntError`，那么定义一个错误类型总是为 `ParseIntError` 的别名会更方便，这样我们就不必一直写出来了。

The most prominent place this idiom is used in the standard library is with io::Result. Typically, one writes io::Result<T>, which makes it clear that you’re using the io module’s type alias instead of the plain definition from std::result. (This idiom is also used for fmt::Result.)

这个习惯用法在标准库中最突出的地方是 `io::Result<T>`。通常情况下，写作 `io::Result<T>`，这清楚地表明你使用的是 `io` 模块的类型别名，而不是 `std::result` 中的简单定义。(这种惯用方法也适用于 `fmt::Result`。)

### 一个简短的插曲：unwrap 并不是坏事
If you’ve been following along, you might have noticed that I’ve taken a pretty hard line against calling methods like unwrap that could panic and abort your program. Generally speaking, this is good advice.

如果你跟上我了，你可能已经注意到，我对像 unwrap 这样的调用采取了相当严格的措施，因为它可能会导致错误并中止您的程序。一般来说，这样做更严谨。

However, unwrap can still be used judiciously. What exactly justifies use of unwrap is somewhat of a grey area and reasonable people can disagree. I’ll summarize some of my opinions on the matter.

然而，unwrap 仍然可以明智地使用。使用 unwrap 的确切理由不是那么容易说清楚，理性的人可能不同意。我将总结一下我对这个问题的一些看法。

* 在示例和随意的代码中。有时候你需要编写示例或者一个简单的程序，错误处理并不重要，在这种情况下，打破 unwrap 的便利性是很困难的，所以很有吸引力
* panic 时表明程序中有错误。代码的变量应该能够防止某种情况发生(比如从空堆栈中弹出)时，就可以允许恐慌。这是因为它暴露了程序中的 bug。这很明确，比如 `assert!` 时发生失败, 也可能是因为数组的索引超出了边界。

This is probably not an exhaustive list. Moreover, when using an Option, it is often better to use its expect method. expect does exactly the same thing as unwrap, except it prints a message you give to expect. This makes the resulting panic a bit nicer to deal with, since it will show your message instead of “called unwrap on a None value.”

这可能是一个不全的列举。此外，在使用 Option 时，最好使用其 `expect` 方法。`expect` 和 `unwrap` 的功能完全一样，只是它会打印一条你想要的消息。这使在产生 panic 时更容易处理，因为它将显示你的信息而不是 “called unwrap on a None value.”。

My advice boils down to this: use good judgment. There’s a reason why the words “never do X” or “Y is considered harmful” don’t appear in my writing. There are trade offs to all things, and it is up to you as the programmer to determine what is acceptable for your use cases. My goal is only to help you evaluate trade offs as accurately as possible.

我的建议可以归结为: 做正确的判断。这就是为什么“永远不要选择 x” 或者“选择 y 是有害的”这样的观点没有出现在我的文章中的原因。所有的事情都需要权衡，作为程序员的你应该决定什么是根据你的场景决定的。我的目标只是帮助你尽可能准确地评估和权衡。

Now that we’ve covered the basics of error handling in Rust, and I’ve said my piece about unwrapping, let’s start exploring more of the standard library.

现在我们已经介绍了 Rust 中错误处理的基本知识，并且已经介绍了关于 unwrap 的部分，让我们开始探索更多标准库的相关内容。


## 处理多种错误类型（Working with multiple error types）
Thus far, we’ve looked at error handling where everything was either an Option<T> or a Result<T, SomeError>. But what happens when you have both an Option and a Result? Or what if you have a Result<T, Error1> and a Result<T, Error2>? Handling composition of distinct error types is the next challenge in front of us, and it will be the major theme throughout the rest of this article.

到目前为止，我们已经研究了错误处理，其中包含 `Option<T>` 或 `Result<T, SomeError>` 。但是当你同时拥有 Option 和一个 Result 时会发生什么呢？或者如果你有一个 `Result<T, Error1>` 和一个 `Result<T, Error2>` 怎么办？处理不同错误类型如何将它们组合是摆在我们面前的下一个挑战，也是本文余下部分的主要内容。


### 组合选项和结果（Composing Option and Result）
So far, I’ve talked about combinators defined for Option and combinators defined for Result. We can use these combinators to compose results of different computations without doing explicit case analysis.

到目前为止，我已经讨论了为 Option 定义的组合子和为 Result 定义的组合子。我们可以使用这些组合子来组合不同计算的结果，而不需要进行显式的 case analysis。

Of course, in real code, things aren’t always as clean. Sometimes you have a mix of Option and Result types. Must we resort to explicit case analysis, or can we continue using combinators?

当然，在真正的代码中，事情并不总是那么简单。有时你有一个 Option 和 Result 类型的混合。我们进行明确的 case analysis，还是继续使用组合子？

For now, let’s revisit one of the first examples in this article:

现在，让我们回顾一下这篇文章中的第一个例子:

```rust
use std::env;

fn main() {
    let mut argv = env::args();
    let arg: String = argv.nth(1).unwrap(); // error 1
    let n: i32 = arg.parse().unwrap(); // error 2
    println!("{}", 2 * n);
}

// $ cargo run --bin unwrap-double 5
// 10
```

Given our new found knowledge of Option, Result and their various combinators, we should try to rewrite this so that errors are handled properly and the program doesn’t panic if there’s an error.

考虑到我们新发现的关于 `Option`、 `Result` 和它们的各种组合子的知识，我们应该尝试重写它，以便正确地处理错误，并且如果出现错误，程序不会 panic。

The tricky aspect here is that argv.nth(1) produces an Option while arg.parse() produces a Result. These aren’t directly composable. When faced with both an Option and a Result, the solution is usually to convert the Option to a Result. In our case, the absence of a command line parameter (from env::args()) means the user didn’t invoke the program correctly. We could just use a String to describe the error. Let’s try:

这里比较棘手的一点是，`argv.nth (1)` 生成一个 `Option`，而 `arg.parse()` 返回 Result。这些不是直接组合的。当同时面对 Option 和 Result 时，解决方案通常是将 Option 转换为 Result。在我们的示例中，缺少命令行参数(来自 `env::args()`)意味着用户没有正确地调用程序。我们可以用一个 `String` 来描述这个错误。我们试试:

```rust
// error-double-string
use std::env;

fn double_arg(mut argv: env::Args) -> Result<i32, String> {
    argv.nth(1)
        .ok_or("Please give at least one argument".to_owned())
        .and_then(|arg| arg.parse::<i32>().map_err(|err| err.to_string()))
        .map(|i| i * 2)
}

fn main() {
    match double_arg(env::args()) {
        Ok(n) => println!("{}", n),
        Err(err) => println!("Error: {}", err),
    }
}
```

There are a couple new things in this example. The first is the use of the Option::ok_or combinator. This is one way to convert an Option into a Result. The conversion requires you to specify what error to use if Option is None. Like the other combinators we’ve seen, its definition is very simple:

在这个例子中有一些新的东西。第一个是使用 `Option::ok_or` 组合子。这是将 Option 转换为 Result 的一种方法。如果 Option 为 None，则转换时要求你指定对应的错误类型。和我们见过的其他组合子一样，它的定义非常简单:

```rust
// option-ok-or-def
fn ok_or<T, E>(option: Option<T>, err: E) -> Result<T, E> {
    match option {
        Some(val) => Ok(val),
        None => Err(err),
    }
}
```

The other new combinator used here is Result::map_err. This is just like Result::map, except it maps a function on to the error portion of a Result value. If the Result is an Ok(...) value, then it is returned unmodified.

这里使用的另一个新的组合子是 `Result::map_err`。这就像 `Result::map`，只不过它将一个函数映射到 Result 值的错误部分。如果 Result 是 `Ok(...)`，则返回未修改的值。

We use map_err here because it is necessary for the error types to remain the same (because of our use of and_then). Since we chose to convert the Option<String> (from argv.nth(1)) to a Result<String, String>, we must also convert the ParseIntError from arg.parse() to a String.

我们在这里使用 `map_err` 是因为错误类型必须保持不变(因为我们使用了 `and_then`)。由于我们选择将 `Option<String>` (从 `argv.nth (1)` 转换为 `Result<String, String>`，所以我们还必须将 `ParseIntError` 从 `arg.parse()` 转换为 `String`。

### 组合子的局限性（The limits of combinators）
Doing IO and parsing input is a very common task, and it’s one that I personally have done a lot of in Rust. Therefore, we will use (and continue to use) IO and various parsing routines to exemplify error handling.

执行 IO 和解析输入是一项非常常见的任务，这也是我个人在 Rust 中经常做的事情。因此，我们将使用（并继续使用）IO 和各种解析例程来举例说明错误处理。

Let’s start simple. We are tasked with opening a file, reading all of its contents and converting its contents to a number. Then we multiply it by 2 and print the output.

我们从简单的开始。首先是打开一个文件，读取其所有的内容，并将其内容转换为一个数字。然后乘以 2，输出结果。

Although I’ve tried to convince you not to use unwrap, it can be useful to first write your code using unwrap. It allows you to focus on your problem instead of the error handling, and it exposes the points where proper error handling need to occur. Let’s start there so we can get a handle on the code, and then refactor it to use better error handling.

尽管我已经尝试说服你不要使用 unwrap，但是首先使用 unwrap 编写代码还是很有用的（方便）。它可以让你能够专注于你的问题，而不是错误处理，并且它公开了错误处理需要在哪儿进行。从那里开始，我们可以得到处理的代码，然后以更好的错误处理重构它。

```rust
// io-basic-unwrap
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double<P: AsRef<Path>>(file_path: P) -> i32 {
    let mut file = File::open(file_path).unwrap(); // error 1
    let mut contents = String::new();
    file.read_to_string(&mut contents).unwrap(); // error 2
    let n: i32 = contents.trim().parse().unwrap(); // error 3
    2 * n
}

fn main() {
    let doubled = file_double("foobar");
    println!("{}", doubled);
}
```

(N.B. The AsRef<Path> is used because those are the same bounds used on std::fs::File::open. This makes it ergnomic to use any kind of string as a file path.)

(注意: 使用 `AsRef<Path>` 是因为它与 `std::fs::File::open` 的 bound（约束）相同。这使得使用任何类型的字符串作为文件路径成为可能。)

There are three different errors that can occur here:

这里可能会出现三种不同的错误:

* 打开文件有问题
* 从文件中读取数据有问题
* 将字符串解析为数字有问题

The first two problems are described via the std::io::Error type. We know this because of the return types of std::fs::File::open and std::io::Read::read_to_string. (Note that they both use the Result type alias idiom described previously. If you click on the Result type, you’ll see the type alias, and consequently, the underlying io::Error type.) The third problem is described by the std::num::ParseIntError type. The io::Error type in particular is pervasive throughout the standard library. You will see it again and again.

前两个问题通过 `std::io::Error` 类型描述。我们知道这一点是因为理解了 `std::fs::File::open` 和 `std::io::Read::read_to_string` 的返回类型。(请注意，它们都使用前面描述的 Result 类型别名惯用法。如果跟踪查看 Result 类型，您将看到类型别名定义，从而看到底层 `io::Error type` 类型。)第三个问题由 `std::num::ParseIntError` 类型表示。`io::Error` 类型在整个标准库中都很普遍。你会经常看到它。

Let’s start the process of refactoring the file_double function. To make this function composable with other components of the program, it should not panic if any of the above error conditions are met. Effectively, this means that the function should return an error if any of its operations fail. Our problem is that the return type of file_double is i32, which does not give us any useful way of reporting an error. Thus, we must start by changing the return type from i32 to something else.

我们开始重构 `file_double` 函数。为了使这个函数与程序的其他组件组合，如果满足上述任何错误条件，都不会 panic。实际上，这意味着如果函数的任何操作失败，该函数应该返回一个错误。我们的问题是 `file_double` 的返回类型是 i32，这不能给我们提供任何有用的报告错误的方法。因此，我们必须首先将返回类型从 i32 更改为其他类型。

The first thing we need to decide: should we use Option or Result? We certainly could use Option very easily. If any of the three errors occur, we could simply return None. This will work and it is better than panicking, but we can do a lot better. Instead, we should pass some detail about the error that occurred. Since we want to express the possibility of error, we should use Result<i32, E>. But what should E be? Since two different types of errors can occur, we need to convert them to a common type. One such type is String. Let’s see how that impacts our code:

我们需要决定的第一件事是: 我们应该使用 `Option` 还是 `Result`？我们当然可以很容易地使用 `Option`。如果出现上面提到得三个错误中的任何一个，我们可以简单地返回 None。这会起作用，这比直接 panic 要好，但我们可以做得更好。相反，我们应该传递一些关于发生的错误的细节。既然我们要表示出错的可能性，我们应该使用 `Result<i32, E>` 。但是 `E` 应该是什么呢？由于可能发生两种不同类型的错误，因此我们需要将它们转换为通用类型。其中一种类型是 `String`。让我们看看这对我们的代码有什么影响:

```rust
//io-basic-error-string
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, String> {
    File::open(file_path)
         .map_err(|err| err.to_string())
         .and_then(|mut file| {
              let mut contents = String::new();
              file.read_to_string(&mut contents)
                  .map_err(|err| err.to_string())
                  .map(|_| contents)
         })
         .and_then(|contents| {
              contents.trim().parse::<i32>()
                      .map_err(|err| err.to_string())
         })
         .map(|n| 2 * n)
}

fn main() {
    match file_double("foobar") {
        Ok(n) => println!("{}", n),
        Err(err) => println!("Error: {}", err),
    }
}
```

This code looks a bit hairy. It can take quite a bit of practice before code like this becomes easy to write. The way I write it is by following the types. As soon as I changed the return type of file_double to Result<i32, String>, I had to start looking for the right combinators. In this case, we only used three different combinators: and_then, map and map_err.

这段代码看起来有点复杂。在这样的代码变得更好之前，需要相当多的练习。我写它的方式是按照下面的类型。一旦我将 `file_double` 的返回类型改为 `Result<i32, String>`，我就必须开始寻找正确的组合子。在本例中，我们只使用了三个不同的组合子: `and_then`，`map` 和 `map_err`。

and_then is used to chain multiple computations where each computation could return an error. After opening the file, there are two more computations that could fail: reading from the file and parsing the contents as a number. Correspondingly, there are two calls to and_then.

`and_then` 用于连接多个计算，其中每次计算都可能返回一个 error。在打开文件之后，还有两个计算可能失败: 从文件中读取和将内容解析为一个数字。相应地，有两个 `and_then` 调用。

map is used to apply a function to the Ok(...) value of a Result. For example, the very last call to map multiplies the Ok(...) value (which is an i32) by 2. If an error had occurred before that point, this operation would have been skipped because of how map is defined.

map 的作用是将闭包函数应用于 `Result` 的 `Ok (...)` 值。例如，`map` 的最后一个调用将 `Ok (...)` 值（即 i32）乘以 2。如果在这之前发生错误，则会跳过此操作，因为 map 是这样定义的。

map_err is the trick the makes all of this work. map_err is just like map, except it applies a function to the Err(...) value of a Result. In this case, we want to convert all of our errors to one type: String. Since both io::Error and num::ParseIntError implement ToString, we can call the to_string() method to convert them.

`map_err` 是使所有这一切正常执行的诀窍。map_err 与 map 类似，只是它将闭包函数应用于 `Result` 的 `Err (...)` 值。在这种情况下，我们希望将所有错误转换为一种类型: `String`。由于 io::Error 和 num::ParseIntError 都实现了 ToString，所以我们可以调用 `to_string()` 方法来进行转换。

With all of that said, the code is still hairy. Mastering use of combinators is important, but they have their limits. Let’s try a different approach: early returns.

尽管如此，代码仍然是很粗糙。掌握使用组合子很重要，但它们也有局限性。让我们尝试一种不同的方法: 提前返回（early returns）。

### 提前返回（Early returns）
I’d like to take the code from the previous section and rewrite it using early returns. Early returns let you exit the function early. We can’t return early in file_double from inside another closure, so we’ll need to revert back to explicit case analysis.

我打算使用上一节中的代码，并使用提前返回的方式重写它。提前返回可以让您提前退出函数。我们不能在 file_double 中从另一个闭包提前返回值，所以我们需要回到显式的 case analysis。

```rust
//io-basic-error-string-early-return
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, String> {
    let mut file = match File::open(file_path) {
        Ok(file) => file,
        Err(err) => return Err(err.to_string()),
    };
    let mut contents = String::new();
    if let Err(err) = file.read_to_string(&mut contents) {
        return Err(err.to_string());
    }
    let n: i32 = match contents.trim().parse() {
        Ok(n) => n,
        Err(err) => return Err(err.to_string()),
    };
    Ok(2 * n)
}

fn main() {
    match file_double("foobar") {
        Ok(n) => println!("{}", n),
        Err(err) => println!("Error: {}", err),
    }
}
```

Reasonable people can disagree over whether this code is better that the code that uses combinators, but if you aren’t familiar with the combinator approach, this code looks simpler to read to me. It uses explicit case analysis with match and if let. If an error occurs, it simply stops executing the function and returns the error (by converting it to a string).

理智的人可能会争论这段代码是否比使用组合子的代码更好，但是如果你不熟悉组合子的方法，这段代码对我来说读起来更简单。它使用带有 `match` 和 `if let` 的显式 case analysis。如果出现错误，它只是停止执行该函数并返回错误（再将其转换为字符串）。

Isn’t this a step backwards though? Previously, I said that the key to ergonomic error handling is reducing explicit case analysis, yet we’ve reverted back to explicit case analysis here. It turns out, there are multiple ways to reduce explicit case analysis. Combinators aren’t the only way.

这难道不是一种倒退吗？之前，我说过人机工程学错误处理的关键是减少明确的案例分析，然而我们在这里又回到了明确的案例分析。事实证明，有多种方法可以减少显式的案例分析。选择组合符并不是唯一的方法。

### try! /`?` 操作符
In older versions of Rust (Rust 1.12 or older), a cornerstone of error handling in Rust is the try! macro. The try! macro abstracts case analysis just like combinators, but unlike combinators, it also abstracts control flow. Namely, it can abstract the early return pattern seen above.

在 Rust 的旧版本(Rust 1.12或更老版本)中，Rust 中错误处理的基石是尝试！宏。尝试！宏抽象案例分析就像组合子一样，但与组合子不同，它也抽象控制流。也就是说，它可以抽象出上面看到的早期回报模式。

Here is a simplified definition of a try! macro:

这里有一个 try! 宏的简化定义:

try-def-simple
macro_rules! try {
    ($e:expr) => (match $e {
        Ok(val) => val,
        Err(err) => return Err(err),
    });
}
(The real definition is a bit more sophisticated. We will address that later.)

(真正的定义稍微复杂一些，我们稍后再讨论。)

Using the try! macro makes it very easy to simplify our last example. Since it does the case analysis and the early return for us, we get tighter code that is easier to read:

使用尝试！宏使我们很容易简化我们的最后一个例子。因为它做案例分析和早期回报，我们得到了更紧密的代码，更容易阅读:

io-basic-error-try 基本错误试验
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, String> {
    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));
    let mut contents = String::new();
    try!(file.read_to_string(&mut contents).map_err(|e| e.to_string()));
    let n = try!(contents.trim().parse::<i32>().map_err(|e| e.to_string()));
    Ok(2 * n)
}

fn main() {
    match file_double("foobar") {
        Ok(n) => println!("{}", n),
        Err(err) => println!("Error: {}", err),
    }
}
The map_err calls are still necessary given our definition of try!. This is because the error types still need to be converted to String. The good news is that we will soon learn how to remove those map_err calls! The bad news is that we will need to learn a bit more about a couple important traits in the standard library before we can remove the map_err calls.

鉴于我们对 try 的定义，map _ err 调用仍然是必要的！.这是因为仍然需要将错误类型转换为 String。好消息是，我们很快就会知道如何删除这些 map _ err 调用！坏消息是，在删除 map _ err 调用之前，我们需要更多地了解一些标准库中的一些重要特性。

In newer versions of Rust (Rust 1.13 or newer), the try! macro was replaced with the ? operator. While it is intended to grow new powers that we won’t cover here, using ? instead of try! is simple:

在锈的新版本(锈1.13或更新) ，尝试！宏被替换为？操作员。虽然它的目的是增长新的力量，我们不会涵盖在这里，使用？而不是去尝试！很简单:

io-basic-error-question 基本错误问题
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, String> {
    let mut file = File::open(file_path).map_err(|e| e.to_string())?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).map_err(|e| e.to_string())?;
    let n = contents.trim().parse::<i32>().map_err(|e| e.to_string())?;
    Ok(2 * n)
}

fn main() {
    match file_double("foobar") {
        Ok(n) => println!("{}", n),
        Err(err) => println!("Error: {}", err),
    }
}
Defining your own error type
定义自己的错误类型
Before we dive into some of the standard library error traits, I’d like to wrap up this section by removing the use of String as our error type in the previous examples.

在深入讨论一些标准库错误特征之前，我想通过删除前面示例中使用 String 作为错误类型来结束本节。

Using String as we did in our previous examples is convenient because it’s easy to convert errors to strings, or even make up your own errors as strings on the spot. However, using String for your errors has some downsides.

像我们在前面的例子中那样使用 String 是很方便的，因为很容易将错误转换为字符串，甚至可以当场将您自己的错误作为字符串。但是，使用 String 来处理错误有一些缺点。

The first downside is that the error messages tend to clutter your code. It’s possible to define the error messages elsewhere, but unless you’re unusually disciplined, it is very tempting to embed the error message into your code. Indeed, we did exactly this in a previous example.

第一个缺点是错误消息容易使代码混乱。在其他地方定义错误消息是可能的，但是除非您非常严格，否则将错误消息嵌入到代码中是非常诱人的。实际上，我们在前一个例子中就是这样做的。

The second and more important downside is that Strings are lossy. That is, if all errors are converted to strings, then the errors we pass to the caller become completely opaque. The only reasonable thing the caller can do with a String error is show it to the user. Certainly, inspecting the string to determine the type of error is not robust. (Admittedly, this downside is far more important inside of a library as opposed to, say, an application.)

第二个也是更重要的缺点是 string 是有损耗的。也就是说，如果所有错误都转换为字符串，那么我们传递给调用方的错误就完全不透明了。对于 String 错误，调用者能够做的唯一合理的事情就是向用户显示它。当然，检查字符串来确定错误的类型是不健壮的。(不可否认，这个缺点在库中比在应用程序中更为重要。)

For example, the io::Error type embeds an io::ErrorKind, which is structured data that represents what went wrong during an IO operation. This is important because you might want to react differently depending on the error. (e.g., A BrokenPipe error might mean quitting your program gracefully while a NotFound error might mean exiting with an error code and showing an error to the user.) With io::ErrorKind, the caller can examine the type of an error with case analysis, which is strictly superior to trying to tease out the details of an error inside of a String.

例如，IO: : Error 类型嵌入一个 IO: : ErrorKind，这是一个结构化数据，表示 IO 操作期间出错的地方。这很重要，因为您可能希望根据错误做出不同的反应。(例如，BrokenPipe 错误可能意味着优雅地退出程序，而 NotFound 错误可能意味着退出时带有错误代码并向用户显示错误。)使用 io: : ErrorKind，调用者可以通过 case 分析检查错误的类型，这比试图梳理出 String 内部错误的细节要好得多。

Instead of using a String as an error type in our previous example of reading an integer from a file, we can define our own error type that represents errors with structured data. We endeavor to not drop information from underlying errors in case the caller wants to inspect the details.

我们可以定义自己的错误类型，用结构化数据表示错误，而不是在上一个从文件读取整数的示例中使用 String 作为错误类型。我们努力不从潜在的错误中丢弃信息，以防调用者想要检查细节。

The ideal way to represent one of many possibilities is to define our own sum type using enum. In our case, an error is either an io::Error or a num::ParseIntError, so a natural definition arises:

表示许多可能性之一的理想方法是使用枚举定义我们自己的和类型。在我们的例子中，一个错误要么是 io: : Error，要么是 num: ParseIntError，所以一个自然的定义就出现了:

io-basic-error-custom I-basic-error-custom
use std::io;
use std::num;

// We derive `Debug` because all types should probably derive `Debug`.
// This gives us a reasonable human readable description of `CliError` values.
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}
Tweaking our code is very easy. Instead of converting errors to strings, we simply convert them to our CliError type using the corresponding value constructor:

调整我们的代码非常简单。我们只需使用相应的值构造函数将错误转换为 CliError 类型，而不是将错误转换为字符串:

io-basic-error-custom I-basic-error-custom
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, CliError> {
    let mut file = File::open(file_path).map_err(CliError::Io)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).map_err(CliError::Io)?;
    let n: i32 = contents.trim().parse().map_err(CliError::Parse)?;
    Ok(2 * n)
}

fn main() {
    match file_double("foobar") {
        Ok(n) => println!("{}", n),
        Err(err) => println!("Error: {:?}", err),
    }
}
The only change here is switching map_err(|e| e.to_string()) (which converts errors to strings) to map_err(CliError::Io) or map_err(CliError::Parse). The caller gets to decide the level of detail to report to the user. In effect, using a String as an error type removes choices from the caller while using a custom enum error type like CliError gives the caller all of the conveniences as before in addition to structured data describing the error.

这里唯一的变化是将 map _ err (| e | e.to _ string ())(将错误转换为字符串)切换到 map _ err (CliError: : Io)或 map _ err (CliError: : Parse)。调用方可以决定向用户报告的详细级别。实际上，使用 String 作为错误类型会从调用者那里移除选项，而使用 CliError 这样的自定义 enum 错误类型会像以前一样为调用者提供所有方便，除了描述错误的结构化数据之外。

A rule of thumb is to define your own error type, but a String error type will do in a pinch, particularly if you’re writing an application. If you’re writing a library, defining your own error type should be strongly preferred so that you don’t remove choices from the caller unnecessarily.

一个经验法则是定义自己的错误类型，但必要时使用 String 错误类型也可以，特别是在编写应用程序时。如果您正在编写一个库，那么最好定义您自己的错误类型，这样您就不必要地从调用者中移除选项。

Standard library traits used for error handling
用于错误处理的标准库特性
The standard library defines two integral traits for error handling: std::error::Error and std::convert::From. While Error is designed specifically for generically describing errors, the From trait serves a more general role for converting values between two distinct types.

标准库定义了两个用于错误处理的整型 traits: std: : Error: Error 和 std: : convert: : From。虽然 Error 是专门为一般性描述错误而设计的，但 From trait 在两个不同类型之间转换值时起着更一般的作用。

The Error trait
错误特性
The Error trait is defined in the standard library:

在标准库中定义了 Error trait:

error-def 错误清除
use std::fmt::{Debug, Display};

trait Error: Debug + Display {
  /// A short description of the error.
  fn description(&self) -> &str;

  /// The lower level cause of this error, if any.
  fn cause(&self) -> Option<&Error> { None }
}
This trait is super generic because it is meant to be implemented for all types that represent errors. This will prove useful for writing composable code as we’ll see later. Otherwise, the trait allows you to do at least the following things:

这个 trait 是超通用的，因为它是为所有表示错误的类型实现的。这将证明对编写可组合代码非常有用，我们将在后面讨论。否则，这个特质至少允许你做以下事情:

Obtain a 获得Debug representation of the error. 表示错误
Obtain a user-facing 获得面向用户的Display representation of the error. 表示错误
Obtain a short description of the error (via the 获取错误的简短描述(通过description method). 方法)
Inspect the causal chain of an error, if one exists (via the 检查一个错误的因果链，如果存在的话(通过cause method). 方法)
The first two are a result of Error requiring impls for both Debug and Display. The latter two are from the two methods defined on Error. The power of Error comes from the fact that all error types impl Error, which means errors can be existentially quantified as a trait object. This manifests as either Box<Error> or &Error. Indeed, the cause method returns an &Error, which is itself a trait object. We’ll revisit the Error trait’s utility as a trait object later.

前两个是错误要求隐含的调试和显示的结果。后两个方法来自于 Error 上定义的两个方法。错误的力量来自于这样一个事实，即所有的错误类型都会影响错误，这意味着错误可以作为一个特质对象而存在量化。这显示为 Box < Error > 或者 & Error。事实上，cause 方法返回 & Error，它本身就是 trait 对象。稍后我们将重新讨论作为 trait 对象的 Error trait 实用程序。

For now, it suffices to show an example implementing the Error trait. Let’s use the error type we defined in the previous section:

现在，展示一个实现 Error trait 的示例就足够了。让我们使用我们在前一节中定义的错误类型:

error-impl 错误-嵌入
use std::io;
use std::num;

// We derive `Debug` because all types should probably derive `Debug`.
// This gives us a reasonable human readable description of `CliError` values.
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}
This particular error type represents the possibility of two types of errors occurring: an error dealing with I/O or an error converting a string to a number. The error could represent as many error types as you want by adding new variants to the enum definition.

这种特殊的错误类型表示出现两种类型错误的可能性: 处理 i/o 错误或将字符串转换为数字的错误。通过向枚举定义添加新的变量，该错误可以表示任意多的错误类型。

Implementing Error is pretty straight-forward. It’s mostly going to be a lot explicit case analysis.

实现错误是相当直接的，它主要是很明确的案例分析。

error-impl 错误-嵌入
use std::error;
use std::fmt;

impl fmt::Display for CliError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            // Both underlying errors already impl `Display`, so we defer to
            // their implementations.
            CliError::Io(ref err) => write!(f, "IO error: {}", err),
            CliError::Parse(ref err) => write!(f, "Parse error: {}", err),
        }
    }
}

impl error::Error for CliError {
    fn description(&self) -> &str {
        // Both underlying errors already impl `Error`, so we defer to their
        // implementations.
        match *self {
            CliError::Io(ref err) => err.description(),
            // Normally we can just write `err.description()`, but the error
            // type has a concrete method called `description`, which conflicts
            // with the trait method. For now, we must explicitly call
            // `description` through the `Error` trait.
            CliError::Parse(ref err) => error::Error::description(err),
        }
    }

    fn cause(&self) -> Option<&error::Error> {
        match *self {
            // N.B. Both of these implicitly cast `err` from their concrete
            // types (either `&io::Error` or `&num::ParseIntError`)
            // to a trait object `&Error`. This works because both error types
            // implement `Error`.
            CliError::Io(ref err) => Some(err),
            CliError::Parse(ref err) => Some(err),
        }
    }
}
I note that this is a very typical implementation of Error: match on your different error types and satisfy the contracts defined for description and cause.

我注意到这是一个非常典型的 Error 实现: 匹配不同的错误类型并满足为描述和原因定义的契约。

The From trait
发自内心的特质
The std::convert::From trait is defined in the standard library:

在标准库中定义了:

from-def 来自 def
trait From<T> {
    fn from(T) -> Self;
}
Deliciously simple, yes? From is very useful because it gives us a generic way to talk about conversion from a particular type T to some other type (in this case, “some other type” is the subject of the impl, or Self). The crux of From is the set of implementations provided by the standard library.

美味的简单，是吗？From 非常有用，因为它提供了一种通用的方式来讨论从特定类型 t 到其他类型的转换(在本例中，“其他类型”是 impl 或 Self 的主题)。From 的关键是由标准库提供的一组实现。

Here are a few simple examples demonstrating how From works:

这里有一些简单的例子来演示 From 是如何工作的:

from-examples 举例
let string: String = From::from("foo");
let bytes: Vec<u8> = From::from("foo");
let cow: ::std::borrow::Cow<str> = From::from("foo");
OK, so From is useful for converting between strings. But what about errors? It turns out, there is one critical impl:

好的，所以 From 对于字符串之间的转换很有用。但是错误怎么办呢？事实证明，有一个关键的影响:

impl<'a, E: Error + 'a> From<E> for Box<Error + 'a>
This impl says that for any type that impls Error, we can convert it to a trait object Box<Error>. This may not seem terribly surprising, but it is useful in a generic context.

这个例子说明，对于任何包含 Error 的类型，我们可以将它转换为 trait 对象 Box < Error > 。这可能看起来并不十分令人惊讶，但是在一般的上下文中是有用的。

Remember the two errors we were dealing with previously? Specifically, io::Error and num::ParseIntError. Since both impl Error, they work with From:

还记得我们之前处理的两个错误吗？具体来说，io: : Error 和 num: : ParseIntError。因为两者都有 impl Error，所以它们使用 From:

from-examples-errors 从例子-错误
use std::error::Error;
use std::fs;
use std::io;
use std::num;

// We have to jump through some hoops to actually get error values.
let io_err: io::Error = io::Error::last_os_error();
let parse_err: num::ParseIntError = "not a number".parse::<i32>().unwrap_err();

// OK, here are the conversions.
let err1: Box<Error> = From::from(io_err);
let err2: Box<Error> = From::from(parse_err);
There is a really important pattern to recognize here. Both err1 and err2 have the same type. This is because they are existentially quantified types, or trait objects. In particular, their underlying type is erased from the compiler’s knowledge, so it truly sees err1 and err2 as exactly the same. Additionally, we constructed err1 and err2 using precisely the same function call: From::from. This is because From::from is overloaded on both its argument and its return type.

这里有一个非常重要的模式需要认识。Err1和 err2具有相同的类型。这是因为他们是存在的量化类型，或特质对象。特别是，它们的底层类型从编译器的知识中消除了，因此编译器真正看到的 err1和 err2是完全相同的。此外，我们使用完全相同的函数调用: From: : From 构造了 err1和 err2。这是因为 From: : From 在其参数和返回类型上都重载了。

This pattern is important because it solves a problem we had earlier: it gives us a way to reliably convert errors to the same type using the same function.

这个模式很重要，因为它解决了我们之前遇到的一个问题: 它为我们提供了一种使用相同函数将错误可靠地转换为相同类型的方法。

Time to revisit an old friend; the try! macro/? operator.

是时候重访一位老朋友了; try! 宏/? 操作符。

The real try! macro/? operator
真正的 try! 宏/? 操作符
Previously, I presented this definition of try!:

之前，我给出了 try 的定义:

macro_rules! try {
    ($e:expr) => (match $e {
        Ok(val) => val,
        Err(err) => return Err(err),
    });
}
This is not it’s real definition. It’s real definition is in the standard library:

这不是它的真实定义，它的真实定义在标准库中:

try-def
macro_rules! try {
    ($e:expr) => (match $e {
        Ok(val) => val,
        Err(err) => return Err(::std::convert::From::from(err)),
    });
}
There’s one tiny but powerful change: the error value is passed through From::from. This makes the try! macro a lot more powerful because it gives you automatic type conversion for free. This is also very similar to how the ? operator works, which is defined slightly differently. Namely, x? desugars to something like the following:

有一个微小但强大的更改: 错误值通过 From: : From 传递。这就是尝试！宏更加强大，因为它让你自动类型转换免费。这也是非常相似的怎么了？操作符工作，这是定义略有不同。也就是说，x？如下所述:

questionmark-def 问号
match ::std::ops::Try::into_result(x) {
    Ok(v) => v,
    Err(e) => return ::std::ops::Try::from_error(From::from(e)),
}
The Try trait is still unstable and beyond the scope of this article, but the essence of it is that it provides a way to abstract over many different types of success/failure scenarios, without being tightly coupled to Result<T, E>. As you can see though, the x? syntax still calls From::from, which is how we achieve automatic error conversion.

Try trait 仍然不稳定，超出了本文的范围，但是它的本质是提供了一种方法来抽象许多不同类型的成功/失败场景，而不与 Result < t，e > 紧密耦合。正如你所看到的，x？语法仍然调用 From: : From，这就是我们实现自动错误转换的方法。

Since most code written today uses ? instead of try!, we will use ? for the remainder of this post.

由于现在编写的大多数代码使用? 而不是尝试! ，我们将在本文的其余部分使用? 。

Let’s take a look at code we wrote previously to read a file and convert its contents to an integer:

让我们来看一下我们之前写的代码，用来读取文件并将其内容转换为整数:

use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, String> {
    let mut file = File::open(file_path).map_err(|e| e.to_string())?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).map_err(|e| e.to_string())?;
    let n = contents.trim().parse::<i32>().map_err(|e| e.to_string())?;
    Ok(2 * n)
}
Earlier, I promised that we could get rid of the map_err calls. Indeed, all we have to do is pick a type that From works with. As we saw in the previous section, From has an impl that let’s it convert any error type into a Box<Error>:

早些时候，我承诺我们可以去掉 map _ err 调用。事实上，我们所要做的就是选择一个可以与之匹配的类型。正如我们在上一节中看到的，From 有一个 impl，让我们将任何错误类型转换为 Box < error > :

io-basic-error-try-from I-basic-error-try-from
use std::error::Error;
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, Box<Error>> {
    let mut file = File::open(file_path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    let n = contents.trim().parse::<i32>()?;
    Ok(2 * n)
}
We are getting very close to ideal error handling. Our code has very little overhead as a result from error handling because the ? operator encapsulates three things simultaneously:

我们已经非常接近理想的错误处理。由于错误处理，我们的代码开销很小，因为？操作符同时包含三个东西:

Case analysis. 案例分析
Control flow. 控制流
Error type conversion. 错误类型转换
When all three things are combined, we get code that is unencumbered by combinators, calls to unwrap or case analysis.

当这三者结合在一起时，我们得到的代码不会受到 combinator、 unwrap 调用或案例分析的影响。

There’s one little nit left: the Box<Error> type is opaque. If we return a Box<Error> to the caller, the caller can’t (easily) inspect underlying error type. The situation is certainly better than String because the caller can call methods like description and cause, but the limitation remains: Box<Error> is opaque. (N.B. This isn’t entirely true because Rust does have runtime reflection, which is useful in some scenarios that are beyond the scope of this article.)

还有一个小问题: Box < error > 类型是不透明的。如果我们向调用者返回一个 Box < error > ，调用者就不能(容易地)检查底层错误类型。这种情况肯定比 String 好，因为调用者可以调用像 description 和 cause 这样的方法，但是限制仍然存在: Box < error > 是不透明的。(注意:。这并不完全正确，因为 Rust 确实有运行时反射，这在某些超出本文范围的场景中非常有用。)

It’s time to revisit our custom CliError type and tie everything together.

是时候重新检查自定义 CliError 类型并将所有内容绑定在一起了。

Composing custom error types
编写自定义错误类型
In the last section, we looked at the real ? operator and how it does automatic type conversion for us by calling From::from on the error value. In particular, we converted errors to Box<Error>, which works, but the type is opaque to callers.

在最后一部分，我们看到的是真实的？运算符，以及它如何通过从错误值上调用 From: : From 来为我们进行自动类型转换。特别是，我们将错误转换为 Box < error > ，它可以工作，但是对于调用方来说，类型是不透明的。

To fix this, we use the same remedy that we’re already familiar with: a custom error type. Once again, here is the code that reads the contents of a file and converts it to an integer:

为了解决这个问题，我们使用了我们已经熟悉的补救方法: 自定义错误类型。同样，下面是读取文件内容并将其转换为整数的代码:

io-basic-error-custom-from I-basic-error-custom-from
use std::fs::File;
use std::io::{self, Read};
use std::num;
use std::path::Path;

// We derive `Debug` because all types should probably derive `Debug`.
// This gives us a reasonable human readable description of `CliError` values.
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}

fn file_double_verbose<P: AsRef<Path>>(file_path: P) -> Result<i32, CliError> {
    let mut file = File::open(file_path).map_err(CliError::Io)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).map_err(CliError::Io)?;
    let n: i32 = contents.trim().parse().map_err(CliError::Parse)?;
    Ok(2 * n)
}
Notice that we still have the calls to map_err. Why? Well, recall the definitions of the ? operator and From. The problem is that there is no From impl that allows us to convert from error types like io::Error and num::ParseIntError to our own custom CliError. Of course, it is easy to fix this! Since we defined CliError, we can impl From with it:

注意，我们仍然需要调用 map _ err。为什么？那么，回想一下？操作符和 From。问题是，没有 From impl 允许我们从错误类型如 io: : Error 和 num: : ParseIntError 转换为我们自己的自定义 CliError。当然，解决这个问题很容易！因为我们定义了 CliError，所以我们可以使用它来实现:

io-basic-error-custom-from I-basic-error-custom-from
impl From<io::Error> for CliError {
    fn from(err: io::Error) -> CliError {
        CliError::Io(err)
    }
}

impl From<num::ParseIntError> for CliError {
    fn from(err: num::ParseIntError) -> CliError {
        CliError::Parse(err)
    }
}
All these impls are doing is teaching From how to create a CliError from other error types. In our case, construction is as simple as invoking the corresponding value constructor. Indeed, it is typically this easy.

所有这些隐含的意义都是教导我们如何从其他错误类型中创建一个 CliError。在我们的例子中，构造就像调用相应的值构造函数一样简单。事实上，它通常就是这么简单。

We can finally rewrite file_double:

我们终于可以重写文件 double:

io-basic-error-custom-from I-basic-error-custom-from
fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, CliError> {
    let mut file = File::open(file_path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    let n: i32 = contents.trim().parse()?;
    Ok(2 * n)
}
The only thing we did here was remove the calls to map_err. They are no longer needed because the ? operator invokes From::from on the error value. This works because we’ve provided From impls for all the error types that could appear.

我们在这里做的唯一一件事就是删除 map _ err 的调用。他们不再需要，因为？操作符从错误值上调用 From: : From。这是因为我们已经为可能出现的所有错误类型提供了 From impls。

If we modified our file_double function to perform some other operation, say, convert a string to a float, then we’d need to add a new variant to our error type:

如果我们修改了 file _ double 函数来执行其他操作，比如说，将一个字符串转换成一个浮点数，那么我们就需要给我们的错误类型添加一个新的变体:

enum CliError {
    Io(io::Error),
    ParseInt(num::ParseIntError),
    ParseFloat(num::ParseFloatError),
}
To reflect this change we need to update the previous impl From<num::ParseIntError> for CliError and add the new impl From<num::ParseFloatError> for CliError:

为了反映这个变化，我们需要更新 CliError 的前一个 impl From < num: : parseinterror > ，并为 CliError 添加新的 impl From < num: : parsefloaterror > :

impl From<num::ParseIntError> for CliError {
    fn from(err: num::ParseIntError) -> CliError {
        CliError::ParseInt(err)
    }
}

impl From<num::ParseFloatError> for CliError {
    fn from(err: num::ParseFloatError) -> CliError {
        CliError::ParseFloat(err)
    }
}
And that’s it!

就是这样！

Advice for library writers
给图书馆作家的建议
Idioms for Rust libraries are still forming, but if your library needs to report custom errors, then you should probably define your own error type. It’s up to you whether or not to expose its representation (like ErrorKind) or keep it hidden (like ParseIntError). Regardless of how you do it, it’s usually good practice to at least provide some information about the error beyond just its String representation. But certainly, this will vary depending on use cases.

锈库的习惯用法仍在形成，但是如果您的库需要报告自定义错误，那么您可能应该定义自己的错误类型。是公开它的表示形式(如 ErrorKind)还是保持隐藏(如 ParseIntError) ，这取决于您。无论如何操作，通常最好至少提供一些关于错误的信息，而不仅仅是它的 String 表示形式。但是毫无疑问，这取决于用例的不同。

At a minimum, you should probably implement the Error trait. This will give users of your library some minimum flexibility for composing errors. Implementing the Error trait also means that users are guaranteed the ability to obtain a string representation of an error (because it requires impls for both fmt::Debug and fmt::Display).

至少，您可能应该实现 Error trait。这将为库的用户提供编写错误的最小灵活性。实现 Error trait 还意味着保证用户能够获得错误的字符串表示形式(因为它同时要求 fmt: Debug 和 fmt: : Display 的 imps)。

Beyond that, it can also be useful to provide implementations of From on your error types. This allows you (the library author) and your users to compose more detailed errors. For example, csv::Error provides From impls for both io::Error and byteorder::Error.

除此之外，在错误类型上提供 From 的实现也很有用。这允许您(库作者)和您的用户编写更详细的错误。例如，csv: : : Error 为 io: : Error 和 byteorder: : Error 提供 From impls。

Finally, depending on your tastes, you may also want to define a Result type alias, particularly if your library defines a single error type. This is used in the standard library for io::Result and fmt::Result.

最后，根据您的喜好，您可能还需要定义 Result 类型别名，特别是如果您的库定义了单个错误类型。这是在 io: : Result 和 fmt: Result 的标准库中使用的。

Case study: A program to read population data
案例研究: 读取人口数据的程序
This article was long, and depending on your background, it might be rather dense. While there is plenty of example code to go along with the prose, most of it was specifically designed to be pedagogical. While I’m not quite smart enough to craft pedagogical examples that are also not toy examples, I certainly can write about a case study.

这篇文章很长，根据你的背景，它可能相当密集。虽然这篇文章中有大量的示例代码，但大部分都是专门为教学而设计的。虽然我没有足够的智慧来制作不是玩具的教学范例，但我肯定可以写一个案例研究。

For this, I’d like to build up a command line program that lets you query world population data. The objective is simple: you give it a location and it will tell you the population. Despite the simplicity, there is a lot that can go wrong!

为此，我想构建一个命令行程序，允许您查询世界人口数据。目标很简单: 你给它一个地点，它会告诉你人口。尽管很简单，但还是有很多地方可能出错！

The data we’ll be using comes from the Data Science Toolkit. I’ve prepared some data from it for this exercise. You can either grab the world population data (41MB gzip compressed, 145MB uncompressed) or just the US population data (2.2MB gzip compressed, 7.2MB uncompressed).

我们将使用的数据来自数据科学工具包。我已经为这个练习准备了一些数据。您可以获取世界人口数据(41 MB gzip 压缩，145 MB 未压缩) ，或者只获取美国人口数据(2.2 MB gzip 压缩，7.2 MB 未压缩)。

Up until now, I’ve kept the code limited to Rust’s standard library. For a real task like this though, we’ll want to at least use something to parse CSV data, parse the program arguments and decode that stuff into Rust types automatically. For that, we’ll use the csv, docopt and rustc-serialize crates.

到目前为止，我一直将代码限制在 Rust 的标准库中。对于这样一个真正的任务，我们至少需要使用一些东西来解析 CSV 数据，解析程序参数，并自动将这些东西解码为 Rust 类型。为此，我们将使用 csv、 docopt 和 rustc-serialize 板条箱。

It’s on Github
在 Github 上
The final code for this case study is on Github. If you have Rust and Cargo installed, then all you need to do is:

本案例研究的最终代码在 Github 上。如果你已经安装了 Rust and Cargo，那么你需要做的就是:

git clone git://github.com/BurntSushi/rust-error-handling-case-study
cd rust-error-handling-case-study
cargo build --release
./target/release/city-pop --help
We’ll build up this project in pieces. Read on and follow along!

我们将逐步构建这个项目。请继续阅读并跟随！

Initial setup
初始设置
I’m not going to spend a lot of time on setting up a project with Cargo because it is already covered well in the Rust book and Cargo’s documentation.

我不打算花很多时间在 Cargo 上建立一个项目，因为它已经在 Rust 的书和 Cargo 的文档中涵盖得很好了。

To get started from scratch, run cargo new --bin city-pop and make sure your Cargo.toml looks something like this:

从零开始，运行 cargo new -- bin city-pop，并确保你的 Cargo.toml 看起来像这样:

[package]
name = "city-pop"
version = "0.1.0"
authors = ["Andrew Gallant <jamslam@gmail.com>"]

[[bin]]
name = "city-pop"

[dependencies]
csv = "0.*"
docopt = "0.*"
rustc-serialize = "0.*"
You should already be able to run:

你应该已经能够运行:

cargo build --release
./target/release/city-pop
#Outputs: Hello, world!
Argument parsing
参数解析
Let’s get argument parsing out of the way. I won’t go into too much detail on Docopt, but there is a nice web page describing it and documentation for the Rust crate. The short story is that Docopt generates an argument parser from the usage string. Once the parsing is done, we can decode the program arguments into a Rust struct. Here’s our program with the appropriate extern crate statements, the usage string, our Args struct and an empty main:

让我们来解析一下参数。关于 Docopt 我不会谈论太多细节，但是有一个很好的网页描述了它和关于铁锈箱的文档。简而言之，Docopt 根据使用字符串生成一个参数解析器。解析完成后，我们可以将程序参数解码为 Rust 结构。下面是我们的程序，包含适当的 extern crate 语句、用法字符串、 Args struct 和一个空的 main:

extern crate docopt;
extern crate rustc_serialize;

static USAGE: &'static str = "
Usage: city-pop [options] <data-path> <city>
       city-pop --help

Options:
    -h, --help     Show this usage message.
";

struct Args {
    arg_data_path: String,
    arg_city: String,
}

fn main() {

}
Okay, time to get coding. The docs for Docopt say we can create a new parser with Docopt::new and then decode the current program arguments into a struct with Docopt::decode. The catch is that both of these functions can return a docopt::Error. We can start with explicit case analysis:

好了，该写代码了。的文档说我们可以用 Docopt: : new 创建一个新的解析器，然后用 Docopt: : decode 将当前的程序参数解码为一个结构。问题是这两个函数都可以返回一个 docopt: : Error。我们可以从明确的案例分析开始:

// These use statements were added below the `extern` statements.
// I'll elide them in the future. Don't worry! It's all on Github:
// https://github.com/BurntSushi/rust-error-handling-case-study
//use std::io::{self, Write};
//use std::process;
//use docopt::Docopt;

fn main() {
    let args: Args = match Docopt::new(USAGE) {
        Err(err) => {
            writeln!(&mut io::stderr(), "{}", err).unwrap();
            process::exit(1);
        }
        Ok(dopt) => match dopt.decode() {
            Err(err) => {
                writeln!(&mut io::stderr(), "{}", err).unwrap();
                process::exit(1);
            }
            Ok(args) => args,
        }
    };
}
This is not so nice. One thing we can do to make the code a bit clearer is to write a macro to print messages to stderr and then exit:

这可不太好。为了使代码更加清晰，我们可以做的一件事就是编写一个宏来将消息打印到 stderr，然后退出:

fatal-def 致命的
macro_rules! fatal {
    ($($tt:tt)*) => {{
        use std::io::Write;
        writeln!(&mut ::std::io::stderr(), $($tt)*).unwrap();
        ::std::process::exit(1)
    }}
}
The unwrap is probably OK here, because if it fails, it means your program could not write to stderr. A good rule of thumb here is that it’s OK to abort, but certainly, you could do something else if you needed to.

展开在这里可能没有问题，因为如果它失败了，这意味着您的程序无法写入 stderr。一个很好的经验法则就是可以中止，但是当然，如果需要的话，你可以做其他的事情。

The code looks nicer, but the explicit case analysis is still a drag:

代码看起来更好，但是明确的案例分析仍然是一个拖累:

let args: Args = match Docopt::new(USAGE) {
    Err(err) => fatal!("{}", err),
    Ok(dopt) => match dopt.decode() {
        Err(err) => fatal!("{}", err),
        Ok(args) => args,
    }
};
Thankfully, the docopt::Error type defines a convenient method exit, which effectively does what we just did. Combine that with our knowledge of combinators, and we have concise, easy to read code:

值得庆幸的是，docopt: : Error 类型定义了一个方便的方法退出，它实际上完成了我们刚才所做的工作。结合我们对组合子的了解，我们就有了简洁易读的代码:

let args: Args = Docopt::new(USAGE)
                        .and_then(|d| d.decode())
                        .unwrap_or_else(|err| err.exit());
If this code completes successfully, then args will be filled from the values provided by the user.

如果此代码成功完成，那么将从用户提供的值填充 args。

Writing the logic
写逻辑
We’re all different in how we write code, but when I’m not sure how to go about coding a problem, error handling is usually the last thing I want to think about. This isn’t very good practice for good design, but it can be useful for rapidly prototyping. In our case, because Rust forces us to be explicit about error handling, it will also make it obvious what parts of our program can cause errors. Why? Because Rust will make us call unwrap! This can give us a nice bird’s eye view of how we need to approach error handling.

我们编写代码的方式各不相同，但当我不确定如何编写问题时，错误处理通常是我最不愿考虑的事情。这对于优秀的设计来说并不是一个很好的实践，但是对于快速的原型设计来说却是很有用的。在我们的例子中，由于 Rust 迫使我们明确错误处理，它也将使我们的程序的哪些部分可能导致错误变得明显。为什么？因为铁锈会让我们打开包装！这可以让我们对如何处理错误处理有一个很好的鸟瞰视图。

In this case study, the logic is really simple. All we need to do is parse the CSV data given to us and print out a field in matching rows. Let’s do it. (Make sure to add extern crate csv; to the top of your file.)

在这个案例研究中，逻辑非常简单。我们所需要做的就是解析给我们的 CSV 数据，并在匹配的行中打印出一个字段。我们开始吧。(请确保将 externcrate csv; 添加到文件顶部。)

// This struct represents the data in each row of the CSV file.
// Type based decoding absolves us of a lot of the nitty gritty error
// handling, like parsing strings as integers or floats.
struct Row {
    country: String,
    city: String,
    accent_city: String,
    region: String,

    // Not every row has data for the population, latitude or longitude!
    // So we express them as `Option` types, which admits the possibility of
    // absence. The CSV parser will fill in the correct value for us.
    population: Option<u64>,
    latitude: Option<f64>,
    longitude: Option<f64>,
}

fn main() {
    let args: Args = Docopt::new(USAGE)
                            .and_then(|d| d.decode())
                            .unwrap_or_else(|err| err.exit());

    let file = fs::File::open(args.arg_data_path).unwrap();
    let mut rdr = csv::Reader::from_reader(file);
    for row in rdr.decode::<Row>() {
        let row = row.unwrap();
        if row.city == args.arg_city {
            println!("{}, {}: {:?}",
                     row.city, row.country,
                     row.population.expect("population count"));
        }
    }
}
Let’s outline the errors. We can start with the obvious: the three places that unwrap is called:

让我们来概括一下这些错误。我们可以从最明显的地方开始: 展开的三个地方被调用:

fs::File::open can return an 可以返回一个io::Error.
csv::Reader::decode decodes one record at a time, and 一次解码一个记录decoding a record 解码记录 (look at the 看看这个Item associated type on the 的关联类型Iterator impl) can produce a Impl)可以产生一个csv::Error.
If 如果row.population is 是None, then calling ，然后打电话expect will panic. 会惊慌失措
Are there any others? What if we can’t find a matching city? Tools like grep will return an error code, so we probably should too. So we have logic errors specific to our problem, IO errors and CSV parsing errors. We’re going to explore two different ways to approach handling these errors.

还有其他人吗？如果我们找不到一个匹配的城市呢？像 grep 这样的工具会返回错误代码，所以我们也应该这样做。因此，我们有针对我们的问题的逻辑错误，IO 错误和 CSV 解析错误。我们将探索两种不同的方法来处理这些错误。

I’d like to start with Box<Error>. Later, we’ll see how defining our own error type can be useful.

我想从 Box < error > 开始。稍后，我们将看到定义我们自己的错误类型是如何有用的。

Error handling with Box<Error>
用 Box < Error > 处理错误
Box<Error> is nice because it just works. You don’t need to define your own error types and you don’t need any From implementations. The downside is that since Box<Error> is a trait object, it erases the type, which means the compiler can no longer reason about its underlying type.

Box < error > 很好，因为它正好可以工作。您不需要定义自己的错误类型，也不需要任何 From 实现。缺点是，因为 Box < error > 是 trait 对象，所以它会擦除类型，这意味着编译器不能再推断它的底层类型。

Previously we started refactoring our code by changing the type of our function from T to Result<T, OurErrorType>. In this case, OurErrorType is just Box<Error>. But what’s T? And can we add a return type to main?

之前，我们开始重构代码，将函数的类型从 t 改为 Result < t，OurErrorType > 。在这种情况下，OurErrorType 只是 Box < error > 。但 t 是什么？我们可以向 main 添加一个返回类型吗？

The answer to the second question is no, we can’t. That means we’ll need to write a new function. But what is T? The simplest thing we can do is to return a list of matching Row values as a Vec<Row>. (Better code would return an iterator, but that is left as an exercise to the reader.)

第二个问题的答案是不，我们不能。这意味着我们需要写一个新函数。但 t 是什么？我们可以做的最简单的事情是将匹配的 Row 值列表作为 Vec < Row > 返回。(更好的代码会返回一个迭代器，但是留给读者作为练习。)

Let’s refactor our code into its own function, but keep the calls to unwrap. Note that we opt to handle the possibility of a missing population count by simply ignoring that row.

让我们将代码重构为它自己的函数，但是保持调用打开。请注意，我们选择通过忽略该行来处理缺失人口计数的可能性。

struct Row {
    // unchanged
}

struct PopulationCount {
    city: String,
    country: String,
    // This is no longer an `Option` because values of this type are only
    // constructed if they have a population count.
    count: u64,
}

fn search<P: AsRef<Path>>(file_path: P, city: &str) -> Vec<PopulationCount> {
    let mut found = vec![];
    let file = fs::File::open(file_path).unwrap();
    let mut rdr = csv::Reader::from_reader(file);
    for row in rdr.decode::<Row>() {
        let row = row.unwrap();
        match row.population {
            None => { } // skip it
            Some(count) => if row.city == city {
                found.push(PopulationCount {
                    city: row.city,
                    country: row.country,
                    count: count,
                });
            },
        }
    }
    found
}

fn main() {
    let args: Args = Docopt::new(USAGE)
                            .and_then(|d| d.decode())
                            .unwrap_or_else(|err| err.exit());

    for pop in search(&args.arg_data_path, &args.arg_city) {
        println!("{}, {}: {:?}", pop.city, pop.country, pop.count);
    }
}
While we got rid of one use of expect (which is a nicer variant of unwrap), we still should handle the absence of any search results.

虽然我们去掉了 expect 的一个用法(这是 unwrap 的一个更好的变体) ，但是我们仍然应该处理没有任何搜索结果的情况。

To convert this to proper error handling, we need to do the following:

要将其转换为适当的错误处理，我们需要执行以下操作:

Change the return type of 更改返回类型search to be 将来Result<Vec<PopulationCount>, Box<Error>>.
Use the 使用? operator so that errors are returned to the caller instead of panicking the program. 操作符，以便将错误返回给调用方，而不是惊慌失措的程序
Handle the error in 中处理错误main.
Let’s try it:

让我们试试:

fn search<P: AsRef<Path>>
         (file_path: P, city: &str)
         -> Result<Vec<PopulationCount>, Box<Error+Send+Sync>> {
    let mut found = vec![];
    let file = fs::File::open(file_path)?;
    let mut rdr = csv::Reader::from_reader(file);
    for row in rdr.decode::<Row>() {
        let row = row?;
        match row.population {
            None => { } // skip it
            Some(count) => if row.city == city {
                found.push(PopulationCount {
                    city: row.city,
                    country: row.country,
                    count: count,
                });
            },
        }
    }
    if found.is_empty() {
        Err(From::from("No matching cities with a population were found."))
    } else {
        Ok(found)
    }
}
Instead of x.unwrap(), we now have x?. Since our function returns a Result<T, E>, the ? operator will return early from the function if an error occurs.

我们现在不用 x.unwrap () ，而是用 x？.由于我们的函数返回结果 < t，e > ，那么？如果出现错误，操作符将从函数中提前返回。

There is one big gotcha in this code: we used Box<Error + Send + Sync> instead of Box<Error>. We did this so we could convert a plain string to an error type. We need these extra bounds so that we can use the corresponding From impls:

这段代码中有一个很大的问题: 我们使用了 Box < Error + Send + Sync > 而不是 Box < Error > 。我们这样做是为了将普通字符串转换为错误类型。我们需要这些额外的边界，这样我们就可以使用相应的 From impls:

// We are making use of this impl in the code above, since we call `From::from`
// on a `&'static str`.
impl<'a, 'b> From<&'b str> for Box<Error + Send + Sync + 'a>

// But this is also useful when you need to allocate a new string for an
// error message, usually with `format!`.
impl From<String> for Box<Error + Send + Sync>
Now that we’ve seen how to do proper error handling with Box<Error>, let’s try a different approach with our own custom error type. But first, let’s take a quick break from error handling and add support for reading from stdin.

现在我们已经了解了如何使用 Box < error > 进行适当的错误处理，接下来让我们使用自定义错误类型尝试一种不同的方法。但是首先，让我们暂停一下错误处理，添加对从 stdin 读取的支持。

Reading from stdin
从 stdin 中读取
In our program, we accept a single file for input and do one pass over the data. This means we probably should be able to accept input on stdin. But maybe we like the current format too—so let’s have both!

在我们的程序中，我们接受一个文件作为输入，并对数据进行一次传递。这意味着我们可能能够接受 stdin 上的输入。但也许我们也喜欢当前的格式ーー所以让我们两者兼得吧！

Adding support for stdin is actually quite easy. There are only two things we have to do:

添加对 stdin 的支持实际上非常简单:

Tweak the program arguments so that a single parameter—the city—can be accepted while the population data is read from stdin. 调整程序参数，以便在从 stdin 读取填充数据时可以接受单个参数 city
Modify the 修改search function to take an 函数取一个optional 可选的 file path. When 文件路径。当None, it should know to read from stdin. ，它应该知道读从 stdin
First, here’s the new usage and Args struct:

首先，下面是新的用法和 Args 结构:

static USAGE: &'static str = "
Usage: city-pop [options] [<data-path>] <city>
       city-pop --help

Options:
    -h, --help     Show this usage message.
";

struct Args {
    arg_data_path: Option<String>,
    arg_city: String,
}
All we did is make the data-path argument optional in the Docopt usage string, and make the corresponding struct member arg_data_path optional. The docopt crate will handle the rest.

我们所做的只是在 Docopt 使用字符串中使数据路径参数可选，并使相应的结构成员 arg _ data _ path 可选。剩下的就交给大箱子了。

Modifying search is slightly trickier. The csv crate can build a parser out of any type that implements io::Read. But how can we use the same code over both types? There’s actually a couple ways we could go about this. One way is to write search such that it is generic on some type parameter R that satisfies io::Read. Another way is to just use trait objects:

修改搜索要稍微棘手一些。Csv 条箱可以用任何实现 io: : Read 的类型构建一个解析器。但是我们如何在这两种类型上使用相同的代码呢？实际上我们有几种方法可以做到这一点。一种方法是编写搜索，使其在某个类型参数 r 上是泛型的，满足 io: : Read。另一种方法是直接使用 trait 对象:

fn search<P: AsRef<Path>>
         (file_path: &Option<P>, city: &str)
         -> Result<Vec<PopulationCount>, Box<Error+Send+Sync>> {
    let mut found = vec![];
    let input: Box<io::Read> = match *file_path {
        None => Box::new(io::stdin()),
        Some(ref file_path) => Box::new(fs::File::open(file_path)?),
    };
    let mut rdr = csv::Reader::from_reader(input);
    // The rest remains unchanged!
}
Error handling with a custom type
使用自定义类型进行错误处理
Previously, we learned how to compose errors using a custom error type. We did this by defining our error type as an enum and implementing Error and From.

以前，我们学习了如何使用自定义错误类型撰写错误。为此，我们将错误类型定义为枚举，并实现 Error 和 From。

Since we have three distinct errors (IO, CSV parsing and not found), let’s define an enum with three variants:

由于我们有三个不同的错误(IO、 CSV 解析和未找到) ，让我们定义一个带有三个变体的枚举:

enum CliError {
    Io(io::Error),
    Csv(csv::Error),
    NotFound,
}
And now for impls on Display and Error:

现在来谈谈显示和错误的影响:

impl fmt::Display for CliError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            CliError::Io(ref err) => err.fmt(f),
            CliError::Csv(ref err) => err.fmt(f),
            CliError::NotFound => write!(f, "No matching cities with a \
                                             population were found."),
        }
    }
}

impl Error for CliError {
    fn description(&self) -> &str {
        match *self {
            CliError::Io(ref err) => err.description(),
            CliError::Csv(ref err) => err.description(),
            CliError::NotFound => "not found",
        }
    }
}
Before we can use our CliError type in our search function, we need to provide a couple From impls. How do we know which impls to provide? Well, we’ll need to convert from both io::Error and csv::Error to CliError. Those are the only external errors, so we’ll only need two From impls for now:

在我们的搜索函数中使用 CliError 类型之前，我们需要提供一对 From impls。我们如何知道应该提供哪些信息？好吧，我们需要将 io: : Error 和 csv: Error 转换为 CliError。这些是唯一的外部错误，所以我们现在只需要两个 From imps:

impl From<io::Error> for CliError {
    fn from(err: io::Error) -> CliError {
        CliError::Io(err)
    }
}

impl From<csv::Error> for CliError {
    fn from(err: csv::Error) -> CliError {
        CliError::Csv(err)
    }
}
The From impls are important because of how the ? operator is defined. In particular, if an error occurs, From::from is called on the error, which in this case, will convert it to our own error type CliError.

来自隐含是重要的，因为如何？定义操作符。特别是，如果发生错误，将对错误调用 From: : From，在本例中，它将把错误转换为我们自己的错误类型 CliError。

With the From impls done, we only need to make two small tweaks to our search function: the return type and the “not found” error. Here it is in full:

完成 From imps 之后，我们只需要对搜索函数进行两个小的调整: 返回类型和“ not found”错误。以下是全文:

fn search<P: AsRef<Path>>
         (file_path: &Option<P>, city: &str)
         -> Result<Vec<PopulationCount>, CliError> {
    let mut found = vec![];
    let input: Box<io::Read> = match *file_path {
        None => Box::new(io::stdin()),
        Some(ref file_path) => Box::new(fs::File::open(file_path)?),
    };
    let mut rdr = csv::Reader::from_reader(input);
    for row in rdr.decode::<Row>() {
        let row = row?;
        match row.population {
            None => { } // skip it
            Some(count) => if row.city == city {
                found.push(PopulationCount {
                    city: row.city,
                    country: row.country,
                    count: count,
                });
            },
        }
    }
    if found.is_empty() {
        Err(CliError::NotFound)
    } else {
        Ok(found)
    }
}
No other changes are necessary.

没有其他的变化是必要的。

Adding functionality
添加功能
If you’re anything like me, writing generic code feels good because generalizing stuff is cool! But sometimes, the juice isn’t worth the squeeze. Look at what we just did in the previous step:

如果你像我一样，编写通用代码感觉很好，因为通用化的东西很酷！但是有时候，这种果汁并不值得去榨取。看看我们在前一步做了什么:

Defined a new error type. 定义新的错误类型
Added impls for 增加恳求Error, Display and two for 还有两张From.
The big downside here is that our program didn’t improve a whole lot. I’m personally fond of it because I like using enums for representing errors, but there is quite a bit of overhead to doing so, especially in short programs like this.

这里最大的缺点是我们的程序并没有提高很多。我个人很喜欢它，因为我喜欢使用枚举表示错误，但是这样做会有相当大的开销，特别是在像这样的短程序中。

One useful aspect of using a custom error type like we’ve done here is that the main function can now choose to handle errors differently. Previously, with Box<Error>, it didn’t have much of a choice: just print the message. We’re still doing that here, but what if we wanted to, say, add a --quiet flag? The --quiet flag should silence any verbose output.

使用自定义错误类型(就像我们在这里所做的)的一个有用的方面是，main 函数现在可以选择以不同的方式处理错误。在此之前，由于 Box < error > ，它没有太多选择: 只能打印消息。我们现在仍然在这样做，但是如果我们想要，比如说，添加一个---- 安静的标志呢？Quiet 标志应该使任何冗长的输出保持沉默。

Right now, if the program doesn’t find a match, it will output a message saying so. This can be a little clumsy, especially if you intend for the program to be used in shell scripts.

现在，如果程序没有找到匹配项，它将输出一条如此说明的消息。这可能有点笨拙，特别是如果您打算在 shell 脚本中使用该程序。

So let’s start by adding the flags. Like before, we need to tweak the usage string and add a flag to the Args struct. The docopt crate does the rest:

让我们从添加标志开始。与前面一样，我们需要调整使用字符串并向 Args 结构添加一个标志。剩下的就交给 docopt 板条箱了:

static USAGE: &'static str = "
Usage: city-pop [options] [<data-path>] <city>
       city-pop --help

Options:
    -h, --help     Show this usage message.
    -q, --quiet    Don't show noisy messages.
";

struct Args {
    arg_data_path: Option<String>,
    arg_city: String,
    flag_quiet: bool,
}
Now we just need to implement our “quiet” functionality. This requires us to tweak the case analysis in main:

现在我们只需要实现我们的“静态”功能，这需要我们对案例分析进行主要的调整:

match search(&args.arg_data_path, &args.arg_city) {
    Err(CliError::NotFound) if args.flag_quiet => process::exit(1),
    Err(err) => fatal!("{}", err),
    Ok(pops) => for pop in pops {
        println!("{}, {}: {:?}", pop.city, pop.country, pop.count);
    }
}
Certainly, we don’t want to be quiet if there was an IO error or if the data failed to parse. Therefore, we use case analysis to check if the error type is NotFound and if --quiet has been enabled. If the search failed, we still quit with an exit code (following grep’s convention).

当然，如果出现 IO 错误或数据无法解析，我们不希望保持安静。因此，我们使用用例分析来检查错误类型是否为 NotFound，以及是否启用了 -- quiet。如果搜索失败，我们仍然使用退出代码退出(遵循 grep 的约定)。

If we had stuck with Box<Error>, then it would be pretty tricky to implement the --quiet functionality.

如果我们坚持使用 Box < error > ，那么实现 -- quiet 功能将会非常棘手。

This pretty much sums up our case study. From here, you should be ready to go out into the world and write your own programs and libraries with proper error handling.

这几乎总结了我们的案例研究。从这里开始，您应该准备好进入这个世界，用适当的错误处理编写自己的程序和库。

The short story
短篇小说
Since this article is long, it is useful to have a quick summary for error handling in Rust. These are my “rules of thumb.” They are emphatically not commandments. There are probably good reasons to break every one of these heuristics!

因为这篇文章很长，所以对 Rust 中的错误处理进行一个快速的总结是很有用的。这些是我的“经验法则”它们显然不是戒律。可能有很好的理由打破这些启发式的每一个！

If you’re writing short example code that would be overburdened by error handling, it’s probably just fine to use 如果您正在编写简短的示例代码，错误处理可能会加重这些代码的负担，那么使用这些代码可能没有问题unwrap (whether that’s (不管那是不是Result::unwrap, Option::unwrap or preferably 或者最好是Option::expect). Consumers of your code should know to use proper error handling. (If they don’t, send them here!) )。您的代码的使用者应该知道使用适当的错误处理。(如果他们不知道，请将他们发送到这里!)
If you’re writing a quick ‘n’ dirty program, don’t feel ashamed if you use 如果你正在写一个快速的 n 脏的程序，不要感到羞愧，如果你使用unwrap. Be warned: if it winds up in someone else’s hands, don’t be surprised if they are agitated by poor error messages! .请注意: 如果它最终落入了别人的手中，如果他们被可怜的错误消息激怒了，不要感到惊讶
If you’re writing a quick ‘n’ dirty program and feel ashamed about panicking anyway, then you should probably use 如果您正在编写一个快速的 n 脏的程序，并且对惊慌失措感到羞愧，那么您可能应该使用Box<Error> (or (或Box<Error + Send + Sync>) as shown in examples above. Another promising alternative is the )。另一个有希望的选择是anyhow crate and its 板条箱及其anyhow::Error type. When using 类型。使用时anyhow, your errors will automatically have backtraces attached to them when using nightly Rust. ，您的错误将自动回溯连接到他们当使用夜间生锈
Otherwise, in a program, define your own error types with appropriate 否则，在程序中，使用适当的From and 及Error impls to make the 恳求使? operator macro more ergnomic. 操作员宏更多的 ergnomic
If you’re writing a library and your code can produce errors, define your own error type and implement the 如果您正在编写一个库，并且您的代码可能会产生错误，那么定义您自己的错误类型并实现std::error::Error trait. Where appropriate, implement 在适当的情况下，实施From to make both your library code and the caller’s code easier to write. (Because of Rust’s coherence rules, callers will not be able to impl 使你的库代码和调用者的代码更容易编写。(由于 Rust 的连贯性规则，呼叫者将无法进入From on your error type, so your library should do it.) 你的错误类型，所以你的库应该这样做。)
Learn the combinators defined on 学习上定义的组合子Option and 及Result. Using them exclusively can be a bit tiring at times, but I’ve personally found a healthy mix of the 。专门使用它们有时可能有点累人，但我个人发现了一个健康的组合? operator and combinators to be quite appealing. 运算符和组合子是非常有吸引力的and_then, map and 及unwrap_or are my favorites.
