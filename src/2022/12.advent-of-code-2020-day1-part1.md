>* Rust and CSV parsing 译文（用 Rust 实现 csv 解析-part8）
>* 原文链接：https://fasterthanli.me/series/advent-of-code-2020/part-1
>* 原文作者：[Amos](https://twitter.com/fasterthanlime)
>* 译文来自：https://github.com/suhanyujie/article-transfer-rs/
>* 译者：[suhanyujie](https://ishenghuo.cnblogs.com/)
>* ps：水平有限，如有不当之处，欢迎指正
>* 标签：Rust，advent of code, algo

今年 12 月我还没有具体的打算，但是我周围的很多人（在 Twitter 上，在工作中）都选择了这个 [Advent of Code](https://adventofcode.com/) 来学习 Rust，而且我有很大 的 [FOMO](https://en.wikipedia.org/wiki/Fear_of_missing_out) 能量，所以，让我们看看在哪里就这样。

我将在 Linux 上完成所有这些工作，因此可能会涉及到一些命令行工具，但不要担心 —— 代码本身应该在所有平台上运行都没有问题。

如果你想继续，你需要安装带有 [Rust Analyzer](https://rust-analyzer.github.io/) 扩展的 [VS Code](https://code.visualstudio.com/)，并且你也需要安装 [Rust](https://rustup.rs/)。

在 Windows 上，您可能必须安装 VS2019 构建工具，这可能有点烦人 - 抱歉！

## 第一部分
问题的输入类似下方

```text
1721
979
366
299
675
1456
```

我们的任务是找到两数相加的和为 2020 的项，然后把它们相乘，让我们开始吧！

```shell
$ cargo new day1
     Created binary (application) `day1` package
```

首先，让我将题目输入粘贴到 `day-1/src/input.txt` 文件中:

```
1470
1577
1054
(cut)
1911
1282
1306
```

但你的文件名可能不一样

然后，我们要读取这个文件，这里有几个选项，我们可以在运行时处理:

```shell
$ cargo add anyhow
    Updating 'https://github.com/rust-lang/crates.io-index' index
      Adding anyhow v1.0.35 to dependencies
```

> 小贴士:
> `cargo add` 由 [cargo-edit](https://lib.rs/crates/cargo-edit) 提供，我们将在整个系列中使用这个插件。
> 如果您遵循以下步骤，您可以简单地安装它并编辑依赖文件
> `cargo install cargo-edit`

```rust
// in `day1/src/main.rs`

fn main() -> anyhow::Result<()> {
    let s = std::fs::read_to_string("./src/input.txt")?;
    dbg!(&s[..40]);

    Ok(())
}
```

这将读取文件，并打印前 40 个字节内容：

```shell
$ cargo run --quiet
[src/main.rs:3] &s[..40] = "1470\n1577\n1054\n1962\n1107\n1123\n1683\n1680\n"
```

... 但是在运行时打开文件意味着可能会失败，我们需要确保 `input.txt` 文件总是在可执行文件的旁边。

因此，我们只需要在编译时将它包含进去:

```rust
fn main() -> anyhow::Result<()> {
    let s = include_str!("input.txt");
    dbg!(&s[..40]);

    Ok(())
}
```

```shell
$ cargo run --quiet
[src/main.rs:3] &s[..40] = "1470\n1577\n1054\n1962\n1107\n1123\n1683\n1680\n"
```

现在字符串内容是可执行文件的一部分：

```shell
$ xxd target/debug/day1 | grep "1470.15" -A 5
0003b000: 4572 726f 723a 200a 3134 3730 0a31 3537  Error: .1470.157
0003b010: 370a 3130 3534 0a31 3936 320a 3131 3037  7.1054.1962.1107
0003b020: 0a31 3132 330a 3136 3833 0a31 3638 300a  .1123.1683.1680.
0003b030: 3131 3736 0a31 3931 370a 3137 3836 0a31  1176.1917.1786.1
0003b040: 3536 350a 3134 3634 0a31 3039 370a 3133  565.1464.1097.13
0003b050: 3633 0a31 3039 310a 3130 3732 0a31 3832  63.1091.1072.182
```

> 小贴士：
> [xxd](https://linux.die.net/man/1/xxd) 是大多数 Linux 发行版附带的一个非常基本(和古老)的 hexdump 工具。

到目前为止，我们有一个很大的 String。我们希望分别处理每一行，所以，让我们用换行符分割它:

```rust
fn main() -> anyhow::Result<()> {
    let s = include_str!("input.txt").split("\n");

    Ok(())
}
```

> 小贴士：
> 你可能想用 `.lines()` 代替 `.split("\n")` 进行拆分，以便这与 CRLF 行结束兼容(Windows)。本文的其余部分是按照 `split` 的思路编写的，但是它们都提供了迭代器，所以你可以随便选。







