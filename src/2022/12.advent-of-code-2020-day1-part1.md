>* Rust and CSV parsing 译文（用 Rust 实现 csv 解析-part8）
>* 原文链接：https://fasterthanli.me/series/advent-of-code-2020/part-1
>* 原文作者：[Amos](https://twitter.com/fasterthanlime)
>* 译文来自：https://github.com/suhanyujie/article-transfer-rs/
>* 译者：[suhanyujie](https://ishenghuo.cnblogs.com/)
>* ps：水平有限，如有不当之处，欢迎指正
>* 标签：Rust，advent of code, algo

今年 12 月我还没有具体的打算，但是我周围的很多人（在 Twitter 上，在工作中）都选择了这个 [Advent of Code](https://adventofcode.com/) 来学习 Rust，而且我有很大 的 [FOMO](https://en.wikipedia.org/wiki/Fear_of_missing_out) 能量，所以，让我们看看在哪里就这样。

我将在 Linux 上完成所有这些工作，因此可能会涉及到一些命令行工具，但不要担心 —— 代码本身应该在所有平台上运行都没有问题。

如果你想继续，你需要安装带有 [Rust Analyzer](https://rust-analyzer.github.io/) 扩展的 [VS Code](https://code.visualstudio.com/)，并且你也需要安装 [Rust](https://rustup.rs/)。

在 Windows 上，您可能必须安装 VS2019 构建工具，这可能有点烦人 - 抱歉！

## 第一部分
问题的输入类似下方

```text
1721
979
366
299
675
1456
```

我们的任务是找到两数相加的和为 2020 的项，然后把它们相乘，让我们开始吧！

```shell
$ cargo new day1
     Created binary (application) `day1` package
```

首先，让我将题目输入粘贴到 `day-1/src/input.txt` 文件中:

```
1470
1577
1054
(cut)
1911
1282
1306
```

但你的文件名可能不一样

然后，我们要读取这个文件，这里有几个选项，我们可以在运行时处理:

```shell
$ cargo add anyhow
    Updating 'https://github.com/rust-lang/crates.io-index' index
      Adding anyhow v1.0.35 to dependencies
```

> 小贴士:
> `cargo add` 由 [cargo-edit](https://lib.rs/crates/cargo-edit) 提供，我们将在整个系列中使用这个插件。
> 如果您遵循以下步骤，您可以简单地安装它并编辑依赖文件
> `cargo install cargo-edit`

```rust
// in `day1/src/main.rs`

fn main() -> anyhow::Result<()> {
    let s = std::fs::read_to_string("./src/input.txt")?;
    dbg!(&s[..40]);

    Ok(())
}
```

这将读取文件，并打印前 40 个字节内容：

```shell
$ cargo run --quiet
[src/main.rs:3] &s[..40] = "1470\n1577\n1054\n1962\n1107\n1123\n1683\n1680\n"
```

... 但是在运行时打开文件意味着可能会失败，我们需要确保 `input.txt` 文件总是在可执行文件的旁边。

因此，我们只需要在编译时将它包含进去:

```rust
fn main() -> anyhow::Result<()> {
    let s = include_str!("input.txt");
    dbg!(&s[..40]);

    Ok(())
}
```

```shell
$ cargo run --quiet
[src/main.rs:3] &s[..40] = "1470\n1577\n1054\n1962\n1107\n1123\n1683\n1680\n"
```

现在字符串内容是可执行文件的一部分：

```shell
$ xxd target/debug/day1 | grep "1470.15" -A 5
0003b000: 4572 726f 723a 200a 3134 3730 0a31 3537  Error: .1470.157
0003b010: 370a 3130 3534 0a31 3936 320a 3131 3037  7.1054.1962.1107
0003b020: 0a31 3132 330a 3136 3833 0a31 3638 300a  .1123.1683.1680.
0003b030: 3131 3736 0a31 3931 370a 3137 3836 0a31  1176.1917.1786.1
0003b040: 3536 350a 3134 3634 0a31 3039 370a 3133  565.1464.1097.13
0003b050: 3633 0a31 3039 310a 3130 3732 0a31 3832  63.1091.1072.182
```

> 小贴士：
> [xxd](https://linux.die.net/man/1/xxd) 是大多数 Linux 发行版附带的一个非常基本(和古老)的 hexdump 工具。

到目前为止，我们有一个很大的 String。我们希望分别处理每一行，所以，让我们用换行符分割它:

```rust
fn main() -> anyhow::Result<()> {
    let s = include_str!("input.txt").split("\n");

    Ok(())
}
```

> 小贴士：
> 你可能想用 `.lines()` 代替 `.split("\n")` 进行拆分，以便这与 CRLF 行结束兼容(Windows)。本文的其余部分是按照 `split` 的思路编写的，但是它们都提供了迭代器，所以你可以随便选。

它给我们的不是一个字符串数组，而是一个实现了 `Iterator<Item = &str>` 的具体类型(`Split<&str>`)。

酷熊：等等，`&str`？我们不是有 `String` 吗？

Amos: 我们做到了！我们的迭代器现在返回的元素是从原来的 String 中借来的。它们是来自原始 String 的片段，因此不涉及复制。

酷熊：等等，不！当我们使用 `std::fs::read_to_string` 时，我们确实有一个 String:

![](https://fasterthanli.me/content/series/advent-of-code-2020/part-1/assets/read-to-string-is-a-string.f689393c8bab440c.avif)

但是等等... ... 当我们使用 `include_str!` 时，我们得到的是 `&str`:

![](https://fasterthanli.me/content/series/advent-of-code-2020/part-1/assets/include-str-is-a-str.4257c10addf7315d.avif)

Amos: 哦，对了！当我们“将字符串打包进在可执行文件中”时，我们得到的也是借用的字符串，因此，我们只是从可执行文件中借用字符串。

酷熊：“可执行文件”是指... ? (要问一个朋友)

Amos: `target/debug/day1` 中的文件是 Linux 上的 [ELF](https://fasterthanli.me/series/making-our-own-executable-packer)、 Windows 上的 PE 和 macOS 上的 Mach-O，这是编译程序得到的结果（通过 cargo build 或 cargo run 构建，最终都会调用 rustc 编译器）。

酷熊：对！

因此，我们有 `Split<&str>`，且它实现了 `Iterator<Item = &str>`。

`Iterator` 是一个 trait，最重要的必需方法是 `next()`：

```rust
fn next(&mut self) -> Option<Self::Item>
```

所以如果我们调用 `s.next()`，我们将得到一个 `Some(a_slice)`，或者在元素耗尽时返回 `None`。

```rust
fn main() -> anyhow::Result<()> {
    let mut s = include_str!("input.txt").split("\n");
    dbg!(s.next());
    dbg!(s.next());
    dbg!(s.next());

    Ok(())
}
```

```shell
$ cargo run --quiet
[src/main.rs:3] s.next() = Some(
    "1470",
)
[src/main.rs:4] s.next() = Some(
    "1577",
)
[src/main.rs:5] s.next() = Some(
    "1054",
)
```

酷熊：等等，我收到一个警告:

![](https://fasterthanli.me/content/series/advent-of-code-2020/part-1/assets/single-character-constant.19485d5311ae7b4b.avif)

Amos: 你遇到内联错误的警告？

酷熊：是的，这是 vscode 扩展 [Error Lens](https://marketplace.visualstudio.com/items?itemName=usernamehw.errorlens)，它是相当整洁！

好吧，关于那个错误-它不是一个真正的错误，它是一个来自 [clippy](https://github.com/rust-lang/rust-clippy) 的诊断提示，这...我之前说过你应该安装 clippy？

那么，你应该将它作为 rust-analyzer 默认的“检查保存”命令，将其保存在你的 VSCode 用户设置中：

```json
{
  "rust-analyzer.checkOnSave.command": "clippy",
}
```

clippy 试图告诉我们的是 `'\n'` 只是一个字符，这是一个很小的值，且不可分割，而 `"\n"` 是一个字符串，可以是任意长度(这里它的长度恰好是 1) ，所以我们强迫 `.split` 支持泛型（会导致更慢）的方法。

没有问题，我们可以很容易地修复，通过点击编辑器中的灯泡（💡）图标，或只是按下 `Ctrl + .`(MacOS 上可能是 `Cmd + .`）：

![](https://fasterthanli.me/content/series/advent-of-code-2020/part-1/assets/clippy-fix.aa634c613e108047.avif)

然后我们得到下面的代码：

```rust
fn main() -> anyhow::Result<()> {
    let mut s = include_str!("input.txt").split('\n');
    dbg!(s.next());
    dbg!(s.next());
    dbg!(s.next());

    Ok(())
}
```

执行结果和之前一样。

那么... 接下来我们要做什么呢? 让我们再看一下问题陈述:

> 具体来说，它们需要您找到两个总和为 2020 的条目，然后将这两个数字相乘。

对！就是描述的那样，不过有一个问题 —— 我们还没有数值，只有字符串。

幸运的是，[`str::parse`](https://doc.rust-lang.org/stable/std/primitive.str.html#method.parse) 可以做到这一点！

那么，我们从一个迭代器 `Iterator<Item = &str>` 开始，我们想要...`Iterator<Item = i64>`？

> 小贴士
> `i64` 是一个有符号的 64 位整数——当我们不担心内存使用问题并且不确定能得到多大的数字时，使用它似乎是一个相对安全的选择。

