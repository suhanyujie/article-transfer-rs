>* Advent of Code 2020 Day7 è¯‘æ–‡ï¼ˆç”¨ Rust å®ç° Advent of Code 2020 ç¬¬7å¤©ï¼‰
>* åŸæ–‡é“¾æ¥ï¼šhttps://fasterthanli.me/series/advent-of-code-2020/part-7
>* åŸæ–‡ä½œè€…ï¼š[Amos](https://twitter.com/fasterthanlime)
>* è¯‘æ–‡æ¥è‡ªï¼šhttps://github.com/suhanyujie/article-transfer-rs/
>* è¯‘è€…ï¼š[suhanyujie](https://ishenghuo.cnblogs.com/)
>* psï¼šæ°´å¹³æœ‰é™ï¼Œå¦‚æœ‰ä¸å½“ä¹‹å¤„ï¼Œæ¬¢è¿æŒ‡æ­£
>* æ ‡ç­¾ï¼šRustï¼Œadvent of code, algo

æ–°çš„ä¸€å¤©ï¼Œæ–°çš„ [Advent of Code 2020 é—®é¢˜](https://adventofcode.com/2020/day/7)ã€‚

è¿™é¢˜çœ‹èµ·æ¥æœ‰ç‚¹æ„æ€ï¼å¯¹é‚£äº›ç±»ä¼¼äºä¹¦å‘†å­çš„åšé¢˜è€…ï¼Œå°¤å…¶å¦‚æ­¤ã€‚

è¾“å…¥æ˜¯ä¸€äº›è§„åˆ™ï¼š

```text
light red bags contain 1 bright white bag, 2 muted yellow bags.
dark orange bags contain 3 bright white bags, 4 muted yellow bags.
bright white bags contain 1 shiny gold bag.
muted yellow bags contain 2 shiny gold bags, 9 faded blue bags.
shiny gold bags contain 1 dark olive bag, 2 vibrant plum bags.
dark olive bags contain 3 faded blue bags, 4 dotted black bags.
vibrant plum bags contain 5 faded blue bags, 6 dotted black bags.
faded blue bags contain no other bags.
dotted black bags contain no other bags.
```

æˆ‘ä»¬è¦è§£ç­”çš„é—®é¢˜æ˜¯ï¼šæœ‰å¤šå°‘ç§è¢‹å­æœ€ç»ˆä¼šè‡³å°‘åŒ…å«ä¸€ä¸ªâ€œé—ªäº®é‡‘â€è‰²ï¼ˆshiny goldï¼‰è¢‹å­ï¼Ÿ

ä¾‹å¦‚ï¼Œä»ä¸Šé¢è¾“å…¥çš„ä¾‹å­æ¥çœ‹ï¼Œâ€œäº®ç™½è‰²ï¼ˆbright whiteï¼‰è¢‹å­â€åŒ…å«ä¸€ä¸ªé—ªäº®é‡‘ï¼ˆshiny goldï¼‰è¢‹å­ï¼Œè€Œæµ…çº¢è‰²è¢‹å­åŒ…å«ä¸€ä¸ªäº®ç™½è‰²ï¼ˆbright whiteï¼‰è¢‹å­ï¼Œäº®ç™½è‰²è¢‹å­åˆå¯ä»¥åŒ…å«ä¸€ä¸ªé—ªäº®é‡‘è‰²ï¼ˆshiny goldï¼‰è¢‹å­ã€‚

ç¬¬ä¸€éƒ¨åˆ†é¢˜ç›®ä¸æ˜¯â€œ X è‰²è¢‹å­ä¸­å¯ä»¥åŒ…å«å¤šå°‘ Y è‰²è¢‹å­â€ï¼Œæ‰€ä»¥æˆ‘æ€€ç–‘å®ƒä¼šå‡ºç°åœ¨é¢˜ç›®ç¬¬äºŒéƒ¨åˆ†ï¼ˆåªæ˜¯ä¸€ä¸ªçŒœæµ‹ï¼Œæˆ‘è¿˜æ²¡çœ‹åˆ°ï¼Œé™¤éæˆ‘å·²ç»è§£å†³äº†ç¬¬ä¸€éƒ¨åˆ†ï¼‰ â€”â€” æˆ‘æƒ³å°è¯•è§£æå¹¶é€‰å¥½è¾“å…¥ç±»å‹ï¼Œä»¥ä¾¿è§£ç­”ç¬¬ä¸€ä¸ªé—®é¢˜ã€‚

æè¿°è¢‹å­æœ‰ä¸¤ä¸ªæ˜ç¡®çš„å±æ€§: å½¢å®¹è¯ï¼šå…‰ï¼ˆlightï¼‰ï¼Œæš—ï¼ˆdarkï¼‰ï¼Œæ˜äº®ï¼ˆbrightï¼‰ï¼ŒæŸ”å’Œï¼ˆmutedï¼‰ï¼Œé—ªäº®ï¼ˆshinyï¼‰ï¼Œå……æ»¡æ´»åŠ›ï¼ˆvibrantï¼‰ï¼Œè¤ªè‰²ï¼ˆfadedï¼‰ï¼Œç‚¹çŠ¶ï¼ˆdottedï¼‰ï¼Œè¿˜æœ‰é¢œè‰²ï¼šçº¢è‰²ï¼ˆredï¼‰ï¼Œæ©™è‰²ï¼ˆorangeï¼‰ï¼Œç™½è‰²ï¼ˆwhiteï¼‰ï¼Œé»„è‰²ï¼ˆyellowï¼‰ï¼Œé‡‘è‰²ï¼ˆgoldï¼‰ï¼Œæ©„æ¦„è‰²ï¼ˆoliveï¼‰ï¼Œæå­è‰²ï¼ˆplumï¼‰ç­‰ã€‚

è¿™é‡Œè¿˜ä¸çŸ¥é“ä¼šæœ‰å¤šå°‘ä¸åŒçš„å½¢å®¹è¯å’Œé¢œè‰²ï¼Œæ‰€ä»¥æˆ‘æƒ³æŠŠå®ƒä»¬è¡¨ç¤ºä¸ºå€Ÿç”¨å­—ç¬¦ä¸²ï¼š

```rust
/// (adjective, color), i.e. ("dark", "orange")
type BagSpec<'a> = (&'a str, &'a str);
```

>* é…·ç†Šçš„çƒ­è¾£å°è´´å£«
> â€œSpecâ€åœ¨è¿™é‡Œæ˜¯â€œspecificationâ€çš„ç®€å†™ã€‚

ä»è¿™é‡Œå¼€å§‹ï¼Œæˆ‘ä»¬çš„è§„åˆ™å…¶å®å°±æ˜¯ä» `BagSpec` åˆ°å¦ä¸€ä¸ª `BagSpec` å’Œæ•°é‡çš„æ˜ å°„:

```rust
use std::collections::HashMap;

/// K can contain V.0 of V.1
type Rules<'a> = HashMap<BagSpec<'a>, (usize, BagSpec<'a>)>;
```

è§„åˆ™è¡¨ç¤ºï¼Œæœ‰äº›è¢‹å­å¯ä»¥åŒ…å«å‡ ç§å…¶ä»–ç±»å‹çš„è¢‹å­ï¼Œä¾‹å¦‚è¿™ä¸ªè§„åˆ™ï¼š

```text
light red bags contain 1 bright white bag, 2 muted yellow bags.
```

æˆ‘ä»¬ä¸èƒ½ç”¨å½“å‰çš„ç±»å‹é›†åˆæ¥è¡¨è¾¾è¿™ä¸ªè§„åˆ™:

```rust
fn main() {
    let mut rules: Rules = Default::default();
    rules.insert(("light", "red"), (1, ("bright", "white")));
    rules.insert(("light", "red"), (2, ("muted", "yellow")));
    dbg!(&rules);
}
```

```shell
$ cargo run --quiet
[src/main.rs:13] &rules = {
    (
        "light",
        "red",
    ): (
        2,
        (
            "muted",
            "yellow",
        ),
```

ç¬¬äºŒæ¡è§„åˆ™è¦†ç›–äº†ç¬¬ä¸€æ¡ï¼

å¥½æ¶ˆæ¯æ˜¯: æœ‰ä¸€ä¸ª[æ¿æ¡ç®±](https://lib.rs/crates/multimap)ï¼ˆå’Œç±»å‹ï¼‰é€‚ç”¨äºè¯¥åœºæ™¯ã€‚

```shell
$ cargo add multimap
      Adding multimap v0.8.2 to dependencies
```

```rust
use multimap::MultiMap;

/// K can contain V.0 of V.1
type Rules<'a> = MultiMap<BagSpec<'a>, (usize, BagSpec<'a>)>;
```

```shell
$ cargo run --quiet
[src/main.rs:13] &rules = {
    (
        "light",
        "red",
    ): [
        (
            1,
            (
                "bright",
                "white",
            ),
        ),
        (
            2,
            (
                "muted",
                "yellow",
            ),
        ),
    ],
}
```

é…·ç†Šï¼šå°±åƒ hyper ä¸­çš„ `HeaderMap` ä¸€æ ·å—ï¼Ÿ

Amosï¼šæ˜¯çš„ï¼Œæˆ‘ä»¬[æœ€è¿‘è®¨è®ºè¿‡](https://fasterthanli.me/articles/aiming-for-correctness-with-types)ã€‚

ç°åœ¨æˆ‘ä»¬å°è¯•å°†ç¤ºä¾‹è§„åˆ™è§£æåˆ°è¿™ä¸ªæ•°æ®ç»“æ„ä¸­ã€‚

é…·ç†Šï¼šè¦ç”¨ peg å—ï¼Ÿ

Amosï¼šæ˜¯çš„ï¼Œpegã€‚

```shell
$ cargo add peg
      Adding peg v0.6.3 to dependencies
```

```rust
fn parse_rules(input: &str) -> Rules<'_> {
    let mut rules: Rules = Default::default();

    peg::parser! {
        pub(crate) grammar parser() for str {
            pub(crate) rule root(r: &mut Rules<'input>)
                = (line(r) "." whitespace()*)* ![_]

            rule line(r: &mut Rules<'input>)
                = spec:bag_spec() " contain " rules:rules() {
                    if let Some(rules) = rules {
                        for rule in rules {
                            r.insert(spec, rule)
                        }
                    }
                }

            rule bag_spec() -> BagSpec<'input>
                = adjective:name() " " color:name() " bag" "s"? { (adjective, color) }

            rule rules() -> Option<Vec<(usize, BagSpec<'input>)>>
                = rules:rule1()+ { Some(rules) }
                / "no other bags" { None }

            /// Rule followed by an optional comma and space
            rule rule1() -> (usize, BagSpec<'input>)
                = r:rule0() ", "? { r }

            /// A single rule
            rule rule0() -> (usize, BagSpec<'input>)
                = quantity:number() " " spec:bag_spec() { (quantity, spec) }

            rule number() -> usize
                = e:$(['0'..='9']+) { e.parse().unwrap() }

            /// A sequence of non-whitespace characters
            rule name() -> &'input str
                = $((!whitespace()[_])*)

            /// Spaces, tabs, CR and LF
            rule whitespace()
                = [' ' | '\t' | '\r' | '\n']
        }
    }

    parser::root(input, &mut rules).unwrap();
    rules
}
```

ç°åœ¨ï¼Œ`dbg!()` ä¼šæœ‰ç›¸å½“è¯¦ç»†çš„è¾“å‡º â€”â€” ä¹Ÿè®¸æˆ‘ä»¬å¯ä»¥æ¨¡ä»¿å¹¶å¤åˆ¶è¾“å…¥çš„æ ¼å¼ï¼Œä»¥ä¾¿æŸ¥çœ‹ï¼Ÿ

```rust
use std::fmt;

struct FormattedRules<'a>(Rules<'a>);

impl fmt::Display for FormattedRules<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        for (k, vv) in &self.0 {
            write!(f, "{} {} bags can contain ", k.0, k.1)?;
            if vv.is_empty() {
                write!(f, "no other bags")?;
            } else {
                for (i, v) in vv.iter().enumerate() {
                    if i > 0 {
                        write!(f, ", ")?;
                    }
                    write!(
                        f,
                        "{} {} {} {}",
                        v.0,
                        v.1 .0,
                        v.1 .1,
                        if v.0 == 1 { "bag" } else { "bags" }
                    )?;
                }
            }
            writeln!(f, ".")?;
        }
        Ok(())
    }
}
```

```rust
fn main() {
    let rules = parse_rules(include_str!("input.txt"));
    print!("{}", FormattedRules(rules));
}
```

ç°åœ¨ï¼Œä¸ºäº†å°†æˆ‘ä»¬ç¨‹åºçš„è¾“å‡ºä¸ç¤ºä¾‹è¾“å…¥è¿›è¡Œæ¯”è¾ƒï¼Œæˆ‘ä»¬å¿…é¡»å¯¹å®ƒè¿›è¡Œæ’åº â€”â€” ä¼ ç»Ÿçš„æ’åºæ–¹æ³•å¯ä»¥å¾ˆå¥½åœ°å®ç°:

```text
$ cargo run --quiet | sort -n
bright white bags can contain 1 shiny gold bag.
dark olive bags can contain 3 faded blue bags, 4 dotted black bags.
dark orange bags can contain 3 bright white bags, 4 muted yellow bags.
light red bags can contain 1 bright white bag, 2 muted yellow bags.
muted yellow bags can contain 2 shiny gold bags, 9 faded blue bags.
shiny gold bags can contain 1 dark olive bag, 2 vibrant plum bags.
vibrant plum bags can contain 5 faded blue bags, 6 dotted black bags.
```

```shell
$ cat src/input.txt | sort -n
bright white bags contain 1 shiny gold bag.
dark olive bags contain 3 faded blue bags, 4 dotted black bags.
dark orange bags contain 3 bright white bags, 4 muted yellow bags.
dotted black bags contain no other bags.
faded blue bags contain no other bags.
light red bags contain 1 bright white bag, 2 muted yellow bags.
muted yellow bags contain 2 shiny gold bags, 9 faded blue bags.
shiny gold bags contain 1 dark olive bag, 2 vibrant plum bags.
vibrant plum bags contain 5 faded blue bags, 6 dotted black bags.
```

çœ‹èµ·æ¥ä¸é”™ï¼å”¯ä¸€çš„åŒºåˆ«æ˜¯æˆ‘ä»¬ä¸è®°å¾—é‚£äº›æ²¡æœ‰è£…å…¶ä»–è¢‹å­çš„è¢‹å­ã€‚ç°åœ¨è¿™äº›éƒ½æ— å…³ç´§è¦ï¼Œæˆ‘ä»¬å¯ä»¥ä»¥åå†è°ƒæ•´æ–¹æ³•ã€‚

å›åˆ°é—®é¢˜ä¸Šæ¥ï¼Œå°½ç®¡è¿™ä¸ªæ•°æ®ç»“æ„æ˜¯å¹³çš„ï¼ˆå±•å¼€çš„ï¼‰ï¼Œä½†æˆ‘ä»¬æ‰‹å¤´ä¸Šæœ‰ä¸€å¼ å›¾:

![](https://fasterthanli.me/content/series/advent-of-code-2020/part-7/assets/graph.3a7788032e974729.svg)

è¿™ä¸æ˜¯æ™®é€šçš„å›¾è¡¨ï¼Œå®ƒæ˜¯ä¸ª[æœ‰å‘æ— ç¯å›¾](https://en.wikipedia.org/wiki/Directed_acyclic_graph)ã€‚

é…·ç†Šï¼šå“¦ï¼Dagï¼Œæˆ‘æŒº[å–œæ¬¢ Dag](https://www.youtube.com/watch?v=zH64dlgyydM) çš„

å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬æƒ³çŸ¥é“â€œä»€ä¹ˆé¢œè‰²çš„è¢‹å­æœ€ç»ˆå¯ä»¥è£…ä¸€ä¸ªé—ªäº®é‡‘è‰²è¢‹å­?â€æˆ‘ä»¬å¯ä»¥æŒ‰å›¾è¡¨èµ°ã€‚å¯¹äºå›¾ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹ï¼Œæˆ‘ä»¬åªéœ€æŒ‰ç…§ç®­å¤´æŒ‡ç¤ºæ“ä½œï¼Œç›´åˆ°:

* æ‰¾åˆ°â€œé—ªäº®é‡‘è‰²â€ â€”â€” åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¡¨ç¤ºå®ƒå¯ä»¥åŒ…å«é—ªäº®é‡‘è‰²è¢‹å­
* èµ°å‡ºè¾¹ç¼˜ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¸ï¼Œå®ƒä¸èƒ½è£…é—ªäº®é‡‘è‰²è¢‹å­

æˆ‘ä»¬ä»¥â€œæµ…çº¢è‰²â€ä¸ºä¾‹ã€‚å¦‚æœæˆ‘ä»¬è·Ÿéšæ•´ä¸ªå›¾è¡¨ï¼Œæˆ‘ä»¬ä¼šç»è¿‡æ‰€æœ‰çš„è¾¹å’ŒèŠ‚ç‚¹:

![](https://fasterthanli.me/content/series/advent-of-code-2020/part-7/assets/graph-walk.d7d3e966b9efb19d.svg)

å¹¶ä¸”è¿™ä¸ªå­é›†ç¡®å®åŒ…å«â€œé—ªäº®é‡‘è‰²â€ï¼Œæ‰€ä»¥â€œæµ…çº¢è‰²â€è¢‹å­æœ€ç»ˆåŒ…å«â€œé—ªäº®é‡‘è‰²â€è¢‹å­ã€‚

ç„¶è€Œï¼Œå¦‚æœæˆ‘ä»¬ä»æ·±æ©„æ¦„è‰²èŠ‚ç‚¹å¼€å§‹ï¼Œæˆ‘ä»¬åªä¼šé‡åˆ°è¿™äº›:

![](https://fasterthanli.me/content/series/advent-of-code-2020/part-7/assets/graph-walk-2.16cb220a3076116b.svg)

è¿™äº›éƒ½ä¸æ˜¯â€œé—ªäº®é‡‘è‰²â€ã€‚

ç°åœ¨æˆ‘ä»¬åªå‰©ä¸‹æœ€ç®€å•çš„éƒ¨åˆ† â€”â€” æŠŠæƒ³æ³•å˜æˆç°å®ï¼š

```rust
fn subgraph_contains(graph: &Rules<'_>, root: &(&str, &str), needle: &(&str, &str)) -> bool {
    if let Some(neighbors) = graph.get_vec(root) {
        for (_, neighbor) in neighbors {
            if neighbor == needle || subgraph_contains(graph, neighbor, needle) {
                return true;
            }
        }
    }
    false
}
```

é…·ç†Šï¼šæˆ‘ä»¬éœ€è¦ `if let` å’Œ `for` å¾ªç¯å—ï¼Ÿæˆ‘ä»¬ä¸èƒ½åªæ˜¯ä½¿ç”¨è¿­ä»£å™¨æ–¹æ³•å§ï¼Ÿ

å¥½å§ï¼Œé‚£å°±è¿™æ ·å§ï¼š

```rust
fn subgraph_contains(graph: &Rules<'_>, root: &(&str, &str), needle: &(&str, &str)) -> bool {
    graph
        .get_vec(root)
        .map(|v| {
            v.iter().any(|(_, neighbor)| {
                neighbor == needle || subgraph_contains(graph, neighbor, needle)
            })
        })
        .unwrap_or_default()
}
```

é…·ç†Šï¼šæˆ‘ä»¬èƒ½ä¸èƒ½æŠŠè¿™ä¸ªå±•å¼€ä¸€äº›ï¼Ÿ

å½“ç„¶ï¼Œå±•å¼€åå·®ä¸å¤šæ˜¯è¿™æ ·:

```rust
fn subgraph_contains(graph: &Rules<'_>, root: &(&str, &str), needle: &(&str, &str)) -> bool {
    graph
        .get_vec(root)
        .unwrap_or(&Default::default())
        .iter()
        .any(|(_, neighbor)| neighbor == needle || subgraph_contains(graph, neighbor, needle))
}
```

é…·ç†Šï¼šå•Šï¼Œè¿™æ˜¯æœ‰ç‚¹ç¬¨ â€”â€” éš¾é“æ‹…å¿ƒå®ƒä¸åˆ†é…ï¼Œä»¥é˜²æ²¡æœ‰å€¼å…³è”åˆ° `root` èŠ‚ç‚¹ï¼Ÿ

Amosï¼šå‘ƒï¼Œå¤ªè¿Ÿäº†ã€‚

é…·ç†Šï¼šå¥½å§ï¼Œä½†ä½ èƒ½ä¿è¯æˆ‘ä»¬å¾…ä¼šå¯ä»¥å­¦åˆ°ä¸€ä¸ªä¼˜åŒ–æ–¹æ³•å—ï¼Ÿ

Amosï¼šå¥½ï¼Œæˆ‘ä¿è¯ï¼

æ— è®ºå¦‚ä½•ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨è¿™æ ·çš„å‡½æ•°:

```rust
fn main() {
    let rules = parse_rules(include_str!("input.txt"));

    let needle = &("shiny", "gold");
    let colors_that_contain_shiny_gold: Vec<_> = rules
        .keys()
        // shiny gold bags are already shiny god, we're not interested
        // in what they can contain (as per the example)
        .filter(|&k| k != needle)
        .filter(|&k| subgraph_contains(&rules, k, needle))
        .collect();
    println!("{:?}", colors_that_contain_shiny_gold);
}
```

æˆ‘ä»¬ä¼šå¾—åˆ°è¿™æ ·çš„ç»“æœ:

```shell
$ cargo run --quiet
[("dark", "orange"), ("light", "red"), ("bright", "white"), ("muted", "yellow")]
```

å®ƒä¸é—®é¢˜æè¿°ä¸­çš„ç¤ºä¾‹ç›¸åŒ¹é…:

> æ ¹æ®è§„åˆ™ï¼Œæœ‰ä»¥ä¸‹æƒ…å†µï¼š

>* æ˜äº®çš„ç™½è‰²è¢‹å­ï¼Œå®ƒå¯ä»¥ç›´æ¥å®¹çº³é—ªäº®çš„é‡‘è‰²è¢‹å­
>* æŸ”å’Œçš„é»„è‰²è¢‹å­ï¼Œå®ƒå¯ä»¥ç›´æ¥å®¹çº³é—ªäº®çš„é‡‘è‰²è¢‹å­ï¼Œå†åŠ ä¸Šä¸€äº›å…¶ä»–è¢‹å­
>* æ·±æ©™è‰²çš„è¢‹å­ï¼Œå®ƒå¯ä»¥è£…æ˜äº®çš„ç™½è‰²å’ŒæŸ”å’Œçš„é»„è‰²è¢‹å­ï¼Œå…¶ä¸­ä»»ä½•ä¸€ä¸ªéƒ½å¯ä»¥è£…é—ªäº®çš„é‡‘è‰²è¢‹å­
>* æµ…çº¢è‰²çš„è¢‹å­ï¼Œå®ƒå¯ä»¥è£…æ˜äº®çš„ç™½è‰²å’ŒæŸ”å’Œçš„é»„è‰²è¢‹å­ï¼Œå…¶ä¸­ä»»ä½•ä¸€ä¸ªéƒ½å¯ä»¥è£…é—ªäº®çš„é‡‘è‰²è¢‹å­

é…·ç†Šï¼šå°±è¿™æ ·ç»“æŸäº†ï¼Ÿ

Amosï¼šå¥½å§ã€‚

æˆ‘è¿˜æƒ³è¯•è¯•åˆ«çš„ã€‚å½“æˆ‘ä»¬ä»æ‰€æœ‰èŠ‚ç‚¹å¼€å§‹éå†å›¾æ—¶ï¼Œæˆ‘ä»¬ä¼šå¤šæ¬¡éå†ç›¸åŒçš„å­å›¾ã€‚

ä¾‹å¦‚ï¼Œä»â€œæµ…çº¢è‰²â€å’Œä»â€œæ·±æ©™è‰²â€ç§»åŠ¨æ—¶ï¼Œæ„å‘³ç€è®¿é—®â€œæ˜äº®çš„ç™½è‰²â€ã€â€œæŸ”å’Œçš„é»„è‰²â€ã€â€œè¤ªè‰²çš„è“è‰²â€å’Œâ€œé—ªäº®çš„é‡‘è‰²â€ä¸¤æ¬¡ï¼š

![](https://fasterthanli.me/content/series/advent-of-code-2020/part-7/assets/overlapping-walk.087b7be0e3c52141.svg)

æˆ‘ä»¬å¯ä»¥åšå‡ºå°å°çš„æ”¹å˜ï¼Œå°±èƒ½æ‘†è„±æ‰€æœ‰è¿™äº›é‡å¤çš„å·¥ä½œ

å°±åƒ [gittup](http://gittup.org/tup/) ä¸€æ ·ï¼Œæˆ‘ä»¬è¦è®©ç®­å¤´ä¸Šå‡ï¼Œè®©äº‹æƒ…å˜å¾—æ›´å¿«ã€‚

å‡å®šæˆ‘ä»¬çš„å›¾è¡¨çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„:

![](https://fasterthanli.me/content/series/advent-of-code-2020/part-7/assets/arrows-go-up.3ad1e767e37b0a47.svg)

ç°åœ¨æˆ‘ä»¬çš„ç®­å¤´æˆ–è¾¹ï¼Œæ„å‘³ç€â€œè¢‹å­ N å¯ä»¥å­˜å‚¨åœ¨é‚£ä¸ªè¢‹å­â€ã€‚

å¦‚æœæˆ‘ä»¬æ€è€ƒâ€œå“ªäº›è¢‹å­å¯ä»¥å‚¨å­˜é—ªäº®é‡‘çš„è¢‹å­ï¼Ÿâ€æˆ‘ä»¬åªéœ€è¦ä»â€œé—ªäº®é‡‘â€ï¼ˆshiny goldï¼‰å¼€å§‹ï¼Œéå†æ•´ä¸ªå­å›¾ã€‚

![](https://fasterthanli.me/content/series/advent-of-code-2020/part-7/assets/arrows-go-up-2.f3acf2ea8f183d1a.svg)

é…·ç†Šï¼šä½†æ˜¯æ€æ ·æ‰èƒ½è®©ç®­å¤´å¾€ä¸Šå‘¢ï¼Ÿ

å…¶å®å¾ˆç®€å•:

```rust
fn reverse_graph<'a>(graph: &Rules<'a>) -> Rules<'a> {
    let mut reverse: Rules = Default::default();
    for (&node, neighbors) in graph.iter_all() {
        for &(quantity, neighbor) in neighbors {
            reverse.insert(neighbor, (quantity, node));
        }
    }
    reverse
}
```

é…·ç†Šï¼šç­‰ç­‰ï¼Œä½ å¯ä»¥å°†å®ƒæ”¶é›†åˆ°ä¸€ä¸ª `MultiMap` ä¸­å—ï¼Ÿ

Amosï¼šå™¢ï¼Œå¯ä»¥ã€‚

```rust
fn reverse_graph<'a>(graph: &Rules<'a>) -> Rules<'a> {
    graph
        .iter_all()
        .map(|(&node, neighbors)| {
            neighbors
                .iter()
                .map(move |&(quantity, neighbor)| (neighbor, (quantity, node)))
        })
        .flatten()
        .collect()
}
```

é…·ç†Šï¼šå™¢ï¼Œæ•°æ®å±•å¼€äº†ï¼Œè¿™æ˜¯æœ€æ–°çš„å—ï¼Ÿ

Amosï¼š[å’Œè¿™ä¸ªä¸–ç•Œä¸€æ ·å†å²æ‚ ä¹…](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.flatten)ã€‚æˆ‘ä»¬éœ€è¦å®ƒæ˜¯å› ä¸º `.iter_all()` è¿”å› `Iterator<Item = (tuple, Vec<tuple>)>` â€”â€” å› ä¸ºå®ƒæ˜¯ä¸€ä¸ª multimapï¼Œè®°å¾—å—ï¼Ÿ

é…·ç†Šï¼šå¤ªæ£’äº†ï¼éšåï¼Œæˆ‘ä»¬æ„é€ ä¸€ä¸ªéå†â€œå­å›¾â€çš„å‡½æ•°ï¼Œå¯¹å—ï¼Ÿ

Amosï¼šæ˜¯çš„ï¼Œä½†æ˜¯å®ƒåº”è¯¥è¿”å›ä»€ä¹ˆå‘¢ï¼Ÿ

é…·ç†Šï¼šè¿­ä»£å™¨ï¼Ÿ

æˆ‘ä»¬å…ˆä» `Vec` å¼€å§‹:

```rust
fn walk_subgraph<'a>(graph: &Rules<'a>, root: &(&str, &str)) -> Vec<(&'a str, &'a str)> {
    let mut res: Vec<_> = Default::default();
    if let Some(neighbors) = graph.get_vec(root) {
        for &(_quantity, neighbor) in neighbors {
            res.push(neighbor);
            res.extend(walk_subgraph(graph, &neighbor));
        }
    }
    res
}
```

çœ‹çœ‹æˆ‘ä»¬èƒ½å¾—åˆ°ä»€ä¹ˆæ‰§è¡Œç»“æœï¼š

```rust
fn main() {
    let rules = parse_rules(include_str!("input.txt"));
    let rev_rules = reverse_graph(&rules);

    let colors_that_contain_shiny_gold = walk_subgraph(&rev_rules, &("shiny", "gold"));
    println!("{:?}", colors_that_contain_shiny_gold);
}
```

```shell
$ cargo run --quiet
[("bright", "white"), ("light", "red"), ("dark", "orange"), ("muted", "yellow"), ("light", "red"), ("dark", "orange")]
```

é…·ç†Šï¼šå˜¿! æœ‰é‡å¤çš„ï¼

äº‹å®ä¸Šï¼Œå¦‚æœæˆ‘ä»¬å¤©çœŸåœ°ä»â€œé—ªäº®é‡‘â€å¼€å§‹éå†å›¾è¡¨ï¼Œæˆ‘ä»¬å°†ä¸æ­¢ä¸€æ¬¡åœ°è®¿é—®æŸäº›èŠ‚ç‚¹ã€‚

æˆ‘ä»¬å¯ä»¥æ”¶é›†åˆ°ä¸€ä¸ª [`HashSet`](https://doc.rust-lang.org/stable/std/collections/struct.HashSet.html) ä¸­ï¼Œæˆ–è€…ç”¨ä¸€äº›å…¶ä»–æ–¹å¼å»é‡ â€”â€” ç°åœ¨è®©æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹ï¼Œä¸è¦åœ¨æ¯æ¬¡éå†ä¸€ä¸ªå­å›¾æ—¶éƒ½åˆ†é…ä¸€ä¸ª Vecã€‚

å¯ä»¥é€‰æ‹© `&mut Vec`ï¼Œè¿™æ˜¯å®Œå…¨åˆç†çš„ï¼š

```rust
fn walk_subgraph1<'a>(graph: &Rules<'a>, root: &(&str, &str), res: &mut Vec<(&'a str, &'a str)>) {
    if let Some(neighbors) = graph.get_vec(root) {
        for &(_quantity, neighbor) in neighbors {
            res.push(neighbor);
            walk_subgraph1(graph, &neighbor, res);
        }
    }
}

fn main() {
    let rules = parse_rules(include_str!("input.txt"));
    let rev_rules = reverse_graph(&rules);

    let mut colors_that_contain_shiny_gold = Default::default();
    walk_subgraph1(
        &rev_rules,
        &("shiny", "gold"),
        &mut colors_that_contain_shiny_gold,
    );
    println!("{:?}", colors_that_contain_shiny_gold);
}
```

è¿™ç»™äº†æˆ‘ä»¬å®Œå…¨ç›¸åŒçš„ç»“æœï¼Œä½†åˆ†é…æ›´å°‘ã€‚åŒæ ·ï¼Œè¿™æ˜¯ä¸€ä¸ªåˆæ³•çš„æŠ€æœ¯ï¼Œæˆ‘ä»¬ä¸ç”¨å¤ªæ‹…å¿ƒå€Ÿç”¨æ£€æŸ¥å™¨ã€‚

å½“ç„¶ï¼Œç°åœ¨æˆ‘ä»¬ä¸èƒ½æ”¶é›†åˆ°ä¸€ä¸ª `HashSet` æ¥å»é‡ã€‚æˆ‘ä»¬ä¸€å¼€å§‹æ ¹æœ¬ä¸æ‰“ç®—è¿™ä¹ˆåšï¼Œæˆ‘ä»¬åªéœ€è¦é€šè¿‡è®¡æ•°å°±èƒ½å®ç°ï¼

å› æ­¤ï¼Œè®©æˆ‘ä»¬å°è¯•åˆ›å»ºä¸€ä¸ªè¿”å›è¿­ä»£å™¨çš„ç‰ˆæœ¬ã€‚æˆ‘ä»¬å°†è¦é‡åˆ°çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬çš„å›¾å¯ä»¥æ˜¯æ— é™å¤§çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬çš„è¿­ä»£å™¨ç±»å‹ï¼Œå¦‚æœä¸åŠ ä»¥è°ƒæ•´ï¼Œä¹Ÿå°†æ˜¯æ— é™å¤§çš„ â€”â€” æˆ‘åœ¨ [2019 å¹´ 5 æœˆ](https://fasterthanli.me/articles/recursive-iterators-rust)è°ˆåˆ°è¿‡è¿™ä¸€ç‚¹ã€‚

é…·ç†Šï¼šæ˜¯å•Šï¼Œé‚£æ—¶å€™ä½ çš„æ–‡ç« éƒ½æ˜¯åœ¨å–å’–å•¡ä¼‘æ¯æ—¶é—´é‡Œå†™çš„ã€‚

è¿™ç¯‡æ–‡ç« çš„ tl; dr æ˜¯: `Box` æ˜¯ä½ çš„æœ‹å‹ï¼ˆ`Box` is your friendï¼‰ï¼Œæ‰€ä»¥ï¼ŒåºŸè¯ä¸å¤šè¯´ï¼š

```rust
fn walk_subgraph2<'iter, 'elems: 'iter>(
    graph: &'iter Rules<'elems>,
    root: &(&'iter str, &'iter str),
) -> Box<dyn Iterator<Item = (&'elems str, &'elems str)> + 'iter> {
    Box::new(
        graph
            .get_vec(root)
            .into_iter()
            .flatten()
            .map(move |&(_, neighbor)| {
                std::iter::once(neighbor).chain(walk_subgraph2(graph, &neighbor))
            })
            .flatten(),
    )
}
```

é…·ç†Šï¼šå¿«é€Ÿé—®ç­”ï¼æˆ‘ç†è§£ `into_iter()` â€”â€” æˆ‘ä»¬æœ‰ `&Vec<V>`ï¼ŒæŠŠå®ƒè½¬æ¢æˆ `Iterator<Item = V>`ã€‚ä½†æ˜¯ `flatten()` æ˜¯æ€ä¹ˆå¤„ç†ï¼Ÿ

Amosï¼šå®é™…ä¸Š... æˆ‘ä»¬æ²¡æœ‰ `&Vec<T>`ã€‚

é…·ç†Šï¼šæ²¡æœ‰å—ï¼Ÿ

```rust
    pub fn get_vec<Q: ?Sized>(&self, k: &Q) -> Option<&Vec<V>>
        where K: Borrow<Q>,
              Q: Eq + Hash
```

é…·ç†Šï¼šå“¦ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ª `Option<&Vec<V>>`ï¼Œå®ƒæ˜¯å¯è¿­ä»£çš„ï¼Ÿ

Amosï¼šå½“ç„¶ï¼å®ƒæ˜¯ä¸€ä¸ªè¿­ä»£å™¨ï¼Œå¦‚æœå®ƒæ˜¯ `Some` çš„ï¼Œå®ƒä¼šå¾—åˆ°ä¸€ä¸ªå…ƒç´ ; å¦‚æœå®ƒæ˜¯ `None`ï¼Œåˆ™æ²¡æœ‰å…ƒç´ ã€‚

é…·ç†Šï¼šå¤ªæ£’äº†ï¼Œè€Œ `flatten()` ç»™æˆ‘ä»¬è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼Œå®ƒè¦ä¹ˆç”Ÿæˆå…ƒç´ çš„ `Vec`ï¼Œè¦ä¹ˆä»€ä¹ˆéƒ½ä¸ç”Ÿæˆï¼ŸOHHHhhhh è¿™å°±æ˜¯ä½ æåˆ°çš„å¯ä»¥ç”¨æ›´å¥½çš„ä¸œè¥¿æ›¿æ¢ `.unwrap_or(&Default::default()) ` çš„æŠ€å·§å—ï¼Ÿ

Amosï¼šæ²¡é”™ï¼ŒğŸ˜ï¼

ç°åœ¨æˆ‘ä»¬æœ‰äº†ä¸€ä¸ªè¿­ä»£å™¨ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `itertools` ä¸­çš„å¦ä¸€ä¸ªå¥½ä¸œè¥¿ï¼Œè€Œä¸”æˆ‘å·²ç»ä¸‰æ¬¡æ£€æŸ¥å®ƒæ˜¯å¦åœ¨æ ‡å‡†åº“ä¸­ï¼ˆæ ‡å‡†åº“ä¸­æ²¡æœ‰ï¼‰ï¼š

```shell
$ cargo add itertools
      Adding itertools v0.9.0 to dependencies
```

```rust
use itertools::Itertools;

fn main() {
    let rules = parse_rules(include_str!("input.txt"));
    let rev_rules = reverse_graph(&rules);

    let needle = ("shiny", "gold");
    let answer = walk_subgraph2(&rev_rules, &needle).unique().count();
    println!("{} colors can contain {:?} bags", answer, needle);
}
```

```shell
$ cargo run --quiet
4 colors can contain ("shiny", "gold") bags
```

é…·ç†Šï¼šå“¦ï¼Œæˆ‘çœ‹åˆ°ä½ åœ¨é‚£é‡Œåšä»€ä¹ˆ â€”â€” `&str` å®ç° `Debug` traitï¼Œæ‰€ä»¥ `(&strï¼Œ&str)` ä¹Ÿè¿™æ ·åšã€‚æ•´æ´ï¼
ä½†æ˜¯ `.unique()` æ˜¯å¦‚ä½•èµ·ä½œç”¨å‘¢ï¼Ÿ

Amosï¼šå®ƒ... å®ƒæ”¶é›†åˆ°ä¸€ä¸ª `HashSet`ã€‚ä½†è¿™æ˜¯éšè—çš„ï¼æ‰€ä»¥æˆ‘ä»¬çš„ä»£ç å¾ˆä¸é”™å¹¶ä¸”æ˜¯**åŠŸèƒ½æœ‰æ•ˆ**çš„ã€‚

è®©æˆ‘ä»¬ç”¨é¢˜ç›®æä¾›çš„è¾“å…¥ï¼Œæ¥è¿è¡Œå®ƒï¼š

```shell
$ cargo run --quiet
103 colors can contain ("shiny", "gold") bags
```

é…·ç†Šï¼šæ­£ç¡®ï¼

## ç¬¬äºŒéƒ¨åˆ†

ç°åœ¨ï¼Œæˆ‘ä»¬è¦æ±‚è®¡ç®—ä½ å¿…é¡»è´­ä¹°å¤šå°‘è¢‹æ‰èƒ½è£…è¿›ä¸€ä¸ªâ€œé—ªäº®é‡‘â€è¢‹å­ã€‚æˆ‘ä»¬ç»ˆäºå¯ä»¥åˆ©ç”¨è¿™äº›æ•°å­—äº†ï¼

æ˜¯æ—¶å€™ä½¿ç”¨å¦ä¸€ä¸ª `walk_subgraph`  æ–¹æ³•äº† â€”â€” è¿™ä¸ªæ–¹æ³•å®é™…ä¸ŠåŒ…å«äº†æ•°é‡ã€‚

åªéœ€è¦åšå‡ é¡¹æ”¹å˜ï¼š

```rust
fn walk_subgraph3<'iter, 'elems: 'iter>(
    graph: &'iter Rules<'elems>,
    root: &(&'iter str, &'iter str),
                          // ğŸ‘‡ we're now returning the quantity as well
) -> Box<dyn Iterator<Item = (usize, (&'elems str, &'elems str))> + 'iter> {
    Box::new(
        graph
            .get_vec(root)
            .into_iter()
            .flatten()
            // ğŸ‘‡ this is even simpler, since we're not destructing the tuple anymore
            .map(move |&n| std::iter::once(n).chain(walk_subgraph3(graph, &n.1)))
            .flatten(),
    )
}
```

æˆ‘ä»¬å°†ä½¿ç”¨å¸¦æœ‰å‘ä¸‹ç®­å¤´çš„å›¾å½¢ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸å†éœ€è¦é€†è½¬è§„åˆ™ã€‚è€Œä¸”ï¼Œæˆ‘ä»¬ä¸ç”¨å†å¤„ç† `.unique()`ã€‚

å¦‚æœâ€œé—ªäº®é‡‘â€è¢‹å­åŒæ—¶åŒ…å«â€œæš—çº¢è‰²â€å’Œâ€œæµ…çº¢è‰²â€è¢‹å­ï¼Œå¹¶ä¸”è¿™ä¸¤ç§è¢‹å­éƒ½åŒ…å«â€œæš—é’è‰²â€è¢‹å­ â€”â€” æˆ‘ä»¬å¿…é¡»å¯¹â€œæš—é’è‰²â€è¢‹å­è®¡æ•°ä¸¤æ¬¡ã€‚

å› æ­¤ï¼Œæˆ‘ä»¬çš„ `main` å‡½æ•°æ›´ç®€å•:

```rust
fn main() {
    let rules = parse_rules(include_str!("input.txt"));
    let root = ("shiny", "gold");
    let answer = walk_subgraph3(&rules, &root).count();
    println!("you must buy {} bags to fill a {:?} bag", answer, root);
}
```

```shell
$ cargo run --quiet
you must buy 63 bags to fill a ("shiny", "gold") bag
```

é…·ç†Šï¼šè¿™ä¸æ˜¯æ­£ç¡®ç­”æ¡ˆï¼åˆ«æ‹…å¿ƒï¼Œæˆ‘ä»¬ä¸­æœ€ä¼˜ç§€çš„äººéƒ½ä¼šé‡åˆ°é”™è¯¯æƒ…å†µï¼Œä¸è¿‡æ— æ³•â€œè¿èƒœâ€äº†ã€‚

å“¦ï¼Œå¯¹äº†ï¼Œæˆ‘å¤ªå…´å¥‹äº†ï¼Œå¿˜äº†æˆ‘ä»¬éœ€è¦æŠŠä¸œè¥¿æ”¾åœ¨ä¸€èµ·ï¼

å¦‚æœæ¯ä¸ªâ€œé—ªäº®é‡‘â€è¢‹å­å«æœ‰ä¸¤ä¸ªâ€œæ·±çº¢è‰²â€è¢‹å­ï¼Œè€Œé‚£äº›è¢‹å­æœ‰ä¸‰ä¸ªâ€œæµ…å“çº¢è‰²â€ï¼ˆlight magentaï¼‰è¢‹å­ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æœ‰ `2 * 3 = 6` ä¸ªâ€œæµ…å“çº¢è‰²â€è¢‹å­ã€‚

æˆ‘æƒ³æˆ‘ä»¬ä¸å¯èƒ½æœ‰ä¸€ä¸ªåƒ  `walk_subgraph3` è¿™æ ·é€šç”¨çš„æ–¹æ³• â€”â€” åˆ›å»ºä¸€ä¸ªè‡ªå®šä¹‰çš„æ–¹æ³•ã€‚

```rust
fn bag_quantities<'iter, 'elems: 'iter>(
    graph: &'iter Rules<'elems>,
    root: &(&'iter str, &'iter str),
) -> Box<dyn Iterator<Item = usize> + 'iter> {
    Box::new(
        graph
            .get_vec(root)
            .into_iter()
            .flatten()
            .map(move |&(qt, n)| {
                std::iter::once(qt).chain(bag_quantities(graph, &n).map(move |x| x * qt))
            })
            .flatten(),
    )
}
```

```rust
fn main() {
    let rules = parse_rules(include_str!("input.txt"));
    let root = ("shiny", "gold");
    let answer: usize = bag_quantities(&rules, &root).sum();
    println!("you must buy {} bags to fill a {:?} bag", answer, root);
}
```

```shell
$ cargo run --quiet
you must buy 1469 bags to fill a ("shiny", "gold") bag
```

é…·ç†Šï¼šè¿™æ‰åƒè¯ï¼

Amosï¼šæˆ‘çŸ¥é“ 63 å¾ˆå°‘ã€‚

ä¸‹æ¬¡è§ï¼Œä¿é‡ï¼


























































