>* Ownership and impl Trait 译文（Rust 中的所有权和 impl trait）
>* 原文链接：https://www.fpcomplete.com/rust/ownership-and-impl-trait/
>* 原文作者：[FPComplete](https://www.fpcomplete.com/)
>* 译文来自：https://github.com/suhanyujie/article-transfer-rs/
>* 译者：[suhanyujie](https://ishenghuo.cnblogs.com/)
>* ps：水平有限，如有不当之处，欢迎指正
>* 标签：Rust，onwership，impl

Rust API 中有一个常见的模式: 返回一个相对复杂的数据类型，且该类型提供了我们想要使用的 trait 实现。许多 Rust 新手首先遇到的问题之一就是迭代器。例如，如果我想提供一个返回数字 1 到 10 范围的函数，它可能看起来像这样:

```rust
use std::ops::RangeInclusive;

fn one_to_ten() -> RangeInclusive<i32> {
    1..=10i32
}
```

这模糊了这里所发生事情的迭代性。因而，当需求变得更复杂时，情况会变得更糟，例如:

```rust
use std::iter::Filter;

fn is_even(x: &i32) -> bool {
    x % 2 == 0
}

fn evens() -> Filter<RangeInclusive<i32>, for<'r> fn(&'r i32) -> bool> {
    one_to_ten().filter(is_even)
}
```

再复杂一点：

```rust
use std::iter::Map;

fn double(x: i32) -> i32 {
    x * 2
}

fn doubled() ->
    Map<
        Filter<
               RangeInclusive<i32>,
               for<'r> fn(&'r i32) -> bool
              >,
        fn(i32) -> i32
       > {
    evens().map(double)
}
```

这显然不是我们想要编写的代码！幸运的是，我们现在有了一种更优雅的方式来表达我们的意图: `impl Trait`。这个特性允许我们表达一个函数返回一个值，且该值实现了某个 trait，而非显式地声明具体的类型。我们可以用以下方法重写上面的签名:

```rust
fn one_to_ten() -> impl Iterator<Item = i32> {
    1..=10i32
}

fn is_even(x: &i32) -> bool {
    x % 2 == 0
}

fn evens() -> impl Iterator<Item = i32> {
    one_to_ten().filter(is_even)
}

fn double(x: i32) -> i32 {
    x * 2
}

fn doubled() -> impl Iterator<Item = i32> {
    evens().map(double)
}

fn main() {
    for x in doubled() {
        println!("{}", x);
    }
}
```

这对于开发来说是一个福音，特别是当我们遇到更复杂的情况时(比如 future 和 Tokio 重代码)。然而，我想展示一个 impl Trait 示例。希望这将有助于解释所有权的一些细微差别及其与该特性的交互。

## 介绍一下谜语
看一下这段不能编译的代码:

```rust
// 试试用 (_: &String) 替换
fn make_debug<T>(_: T) -> impl std::fmt::Debug {
    42u8
}

fn test() -> impl std::fmt::Debug {
    let value = "value".to_string();

    // try removing the ampersand to get this to compile
    // 尝试移除 `&` 以通过编译
    make_debug(&value)
}

pub fn main() {
    println!("{:?}", test());
}
```

在这段代码中，有一个 `make_debug` 函数，它接受任何值，完全忽略该值，并返回一个 `u8`。但是，在函数签名中并未包含 `u8`，而是 `impl Debug` (这是完全有效的: `u8` 实际上实现了 `Debug`)。`test` 函数通过向 `make_debug` 传入 `&String` 来返回 `impl Debug`。

当我尝试编译它时，我得到了错误消息:

```
error[E0597]: `value` does not live long enough
  --> src/main.rs:10:16
   |
6  | fn test() -> impl std::fmt::Debug {
   |              -------------------- opaque type requires that `value` is borrowed for `'static`
...
10 |     make_debug(&value)
   |                ^^^^^^ borrowed value does not live long enough
11 | }
   | - `value` dropped here while still borrowed
```

在我们试图理解这个错误消息之前，我想在这里深化该问题点。我可以对这段代码进行一些更改，以使其通过编译。例如:

* 如将 `make_debug` 中的 `T` 参数替换为 `&String`（或者更常用的 `&str`）。由于某种原因，多态性会导致一些问题。
* 把签名由 `make_debug<T>(_: T)` 改为 `make_debug<T>(_: &T)` 也能修复，但可能会更奇怪。
* 最后，在调用 `make_debug` 后，如果入参是值本身吗，而非值的引用，就能编译了。即：`make_debug(value)` 而非 `make_debug(&value)`。直觉上，希望使用引用时，不要遇到生命周期错误。

一些事情正在变的微妙，我们试着慢慢理解它。

## 具体类型的生命周期
让我们将 `make_debug` 函数简化为显式接受一个 `String`:

```rust
fn make_debug(_: String) -> impl std::fmt::Debug {
    42u8
}
```

这时，参数的生命周期是多少？`make_debug` 完全使用该值，然后丢弃它。该值不能再在函数之外使用。但有趣的是，`make_debug` 丢弃它的事实并没有反映在函数类型签名中; 它只表明返回一个 `impl Debug`。为了证明这一点，我们可以返回参数本身，而不是我们的 `42u8`：

```rust
fn make_debug(message: String) -> impl std::fmt::Debug {
    //42u8
    message
}
```

在这种情况下，`message` 的所有权从 `make_debug` 函数本身转移到返回的 `impl Debug` 值上。这是一个有趣而重要的现象，我们一会儿再回来。让我们继续探索，看看接受 `&String` 版本的 `make_debug`：

```rust
fn make_debug(_: &String) -> impl std::fmt::Debug {
    42u8
}
```

那个引用的生命周期是多久？由于生命周期参数省略了，我们不必明确地说明它。但是隐含的生命周期在函数本身的生存期内。换句话说，当函数退出时，`String` 的借用则过期。我们可以通过返回引用来证明这一点：

```rust
fn make_debug(message: &String) -> impl std::fmt::Debug {
    //42u8
    message
}
```

我们得到的错误消息有点出人意料，但相当有帮助:

```rust
error: cannot infer an appropriate lifetime
 --> src/main.rs:4:5
  |
2 | fn make_debug(message: &String) -> impl std::fmt::Debug {
  |                                    -------------------- this return type evaluates to the `'static` lifetime...
3 |     //42u8
4 |     message
  |     ^^^^^^^ ...but this borrow...
  |
note: ...can't outlive the anonymous lifetime #1 defined on the function body at 2:1
 --> src/main.rs:2:1
  |
2 | / fn make_debug(message: &String) -> impl std::fmt::Debug {
3 | |     //42u8
4 | |     message
5 | | }
  | |_^
help: you can add a constraint to the return type to make it last less than `'static` and match the anonymous lifetime #1 defined on the function body at 2:1
  |
2 | fn make_debug(message: &String) -> impl std::fmt::Debug + '_ {
  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
```

现在的情况是，我们的签名本质上有两个生命周期。`message` 的隐含生命周期就是函数的生命周期，而 `impl Debug` 的生命周期是 `'static`，这意味着它要么不借用数据，要么只借用持续整个程序的值(比如字符串文字)。我们甚至可以尝试贯彻这个建议，并添加一些明确的生命周期：

```rust
fn make_debug<'a>(message: &'a String) -> impl std::fmt::Debug + 'a {
    message
}

fn test() -> impl std::fmt::Debug {
    let value = "value".to_string();
    make_debug(&value)
}
```

虽然这个修复程序 `make_debug` 本身，但是我们不能再通过 `test` 调用 `make_debug`:

```
error[E0597]: `value` does not live long enough
  --> src/main.rs:11:16
   |
7  | fn test() -> impl std::fmt::Debug {
   |              -------------------- opaque type requires that `value` is borrowed for `'static`
...
11 |     make_debug(&value)
   |                ^^^^^^ borrowed value does not live long enough
12 | }
   | - `value` dropped here while still borrowed
```

换句话说，我们假设 `test()` 的返回值比 `test` 本身存在时间长，但是 `value` 不会比 `test` 存在时间长。

**思考问题**确保你可以向你自己(或者一只橡皮鸭)解释: 为什么返回的 `message` 可以通过值传递而不是通过引用传递呢？

对于 `make_debug` 的具体类型版本，我们基本上有一个二乘二的矩阵: 是通过值传递还是通过引用传递，以及是返回提供的参数还是虚拟的 `42u8` 值。让我们清楚地记录下来:

|        | 值传递| 引用传递 |
| ----------- | ----------- |---|
| Use message |  Success: 返回值拥有所有权 | 失败: 返回值超过引用的生存期  |
| Use dummy |  Success: 返回值无需参数 | 失败: 返回值无需引用  |

## 为什么多态会破坏 Rust 机制？
在下面的行中可以看到，当返回 42 时，使用值传递和引用传递都是安全的，因为返回的值根本不需要生命周期参数。但是由于某种原因，当我们使用参数 T 而不是 `String` 或 `&String` 时，我们会得到一个错误消息。让我们用代码来回忆一下：

```rust
fn make_debug<T>(_: T) -> impl std::fmt::Debug {
    42u8
}

fn test() -> impl std::fmt::Debug {
    let value = "value".to_string();
    make_debug(&value)
}
```

错误消息：

```
error[E0597]: `value` does not live long enough
  --> src/main.rs:10:16
   |
6  | fn test() -> impl std::fmt::Debug {
   |              -------------------- opaque type requires that `value` is borrowed for `'static`
...
10 |     make_debug(&value)
   |                ^^^^^^ borrowed value does not live long enough
11 | }
   | - `value` dropped here while still borrowed
```
