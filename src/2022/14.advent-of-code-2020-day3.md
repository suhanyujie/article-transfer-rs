>* Advent of Code 2020 Day3 译文（Advent of Code 2020 第3天）
>* 原文链接：https://fasterthanli.me/series/advent-of-code-2020/part-3
>* 原文作者：[Amos](https://twitter.com/fasterthanlime)
>* 译文来自：https://github.com/suhanyujie/article-transfer-rs/
>* 译者：[suhanyujie](https://ishenghuo.cnblogs.com/)
>* ps：水平有限，如有不当之处，欢迎指正
>* 标签：Rust，advent of code, algo

大家好，欢迎回到《Advent of Code 2020》，欢迎主角酷熊。

酷熊：大家好！

我们开门见山吧。

[第 3 天](https://adventofcode.com/2020/day/3) 的问题陈述如下: 我们有一张地图，看起来像这样:

```
..##.......
#...#...#..
.#....#..#.
..#.#...#.#
.#...##..#.
..#.##.....
.#.#.#....#
.#........#
#.##...#...
#...##....#
.#..#...#.#
```

我们想象它向右无限重复，就像这样:

```
..##.........##....... (etc.)
#...#...#..#...#...#.. (etc.)
.#....#..#..#....#..#. (etc.)
..#.#...#.#..#.#...#.# (etc.)
.#...##..#..#...##..#. (etc.)
..#.##.......#.##..... (etc.)
.#.#.#....#.#.#.#....# (etc.)
.#........#.#........# (etc.)
#.##...#...#.##...#... (etc.)
#...##....##...##....# (etc.)
.#..#...#.#.#..#...#.# (etc.)
```

我们的 sled 从左上角开始，每次向右移动 3 个单位，向下移动 1 个单位。问题是，如果我们沿着那条路走，会遇到多少棵树？

可能有几种方法可以解决这个问题，但是当我看到这样的问题时，我会想到一个 2D 地图(带有 x 的物体)。这让我想起了我的游戏开发时代！

```shell
$ cargo new day3
     Created binary (application) `day3` package
```

让我们再试着从类型的角度来思考。

我们需要以某种方式表示地图上的位置。我们可以给每个函数传递 `x`、`y` 或者 `col`、`row`，或者我们可以为它创建一个类型。

我们将使用有符号的数字，这样我们就可以从技术上表示 0 左边的位置，假设地图左右两边都有:

```rust
#[derive(Debug, Clone, Copy, PartialEq)]
struct Vec2 {
    x: i64,
    y: i64,
}
```

为了方便起见，我们先从元组（tuple）构建 `Vec2`:

```rust
impl From<(i64, i64)> for Vec2 {
    fn from((x, y): (i64, i64)) -> Self {
        Self { x, y }
    }
}
```

我们为此编写一个测试:

```rust
#[test]
fn test_tuple() {
    let v: Vec2 = (5, 8).into();
    assert_eq!(v.x, 5);
    assert_eq!(v.y, 8);
}
```

我们还需要一个类型表示 tile:

```rust
#[derive(Clone, Copy, PartialEq)]
enum Tile {
    Open,
    Tree,
}
```

默认情况下，所有 tile 是打开的:

```rust
impl Default for Tile {
    fn default() -> Self {
        Self::Open
    }
}
```

我们还将添加一个 `Debug` 实现，它将输出 tile 的图形表示:

```rust
use std::fmt;

impl fmt::Debug for Tile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let c = match self {
            Tile::Open => '.',
            Tile::Tree => '#',
        };
        write!(f, "{}", c)
    }
}
```

我们的 `Map` 类型可以是一个 `struct`，只有几个字段: 它的 `size`，以及它包含的所有 tile 的 `Vec`:

```rust
struct Map {
    size: Vec2,
    tiles: Vec<Tile>,
}
```

接下来，我们需要一些方法:

```rust
impl Map {
    fn new(size: Vec2) -> Self {
        todo!()
    }

    fn set(&mut self, pos: Vec2, tile: Tile) {
        todo!()
    }

    fn get(&self, pos: Vec2) -> Tile {
        todo!()
    }
}
```

让我们从最简单的开始: `new`。

我们将所有的 tile 存储在一个二维数组中，按照行-主数组的顺序，这意味着我们首先存储来自第一行的所有 tile，然后转移到第二行，以此类推。


