>* Parsing Text with Nom（【译】使用 Nom 解析文本）
>* 原文链接：https://blog.adamchalmers.com/nom-chars/
>* 原文作者：[Adam Chalmers](https://twitter.com/adam_chal)
>* 译文来自：https://github.com/suhanyujie/article-transfer-rs/
>* ps：水平有限，如有不当之处，欢迎指正。
>* 标签：Rust, Nom, parsing

"Parsing" is turning a stream of raw text or binary into some structured data types, i.e. a Rust type that your code can understand and use. This isn't the textbook definition of parsing, but damnit, this is my blog and my opinion. This tutorial is about _[nom](https://docs.rs/nom)_, my favourite Rust parsing library. It uses a _parser combinator_ approach: you start writing tiny parsers that match, say, a single number or a character. These become building blocks for larger parsers, that match, say, a date or a phone number. By combining many small parsers together, you can build a big parser that decodes a file or stream into nice Rust structs and enums. In this tutorial we'll use Nom to parse the input file to an [Advent of Code](https://adventofcode.com) puzzle.
> “Parsing”是将原始文本或二进制流转换为一些结构化的数据类型，即你的代码可以理解和使用的 Rust 类型。这不是这个词的教科书定义，但，这是我的博客中我的见解。本教程是关于 _[nom](https://docs.rs/nom)_（我最喜欢的 Rust 解析库）的。它使用 _parser combinator_ 方法：从编写匹配单个数字或字符的微小解析器开始。这些能成为更大的解析器的构建模块（基础），比如，这些解析器匹配日期或电话号码，通过将许多小型解析器组合在一起，您可以构建一个大型解析器，将文件或流解码为漂亮的 Rust 结构和枚举。在本教程中，我们使用 Nom 将输入文件解析为 [Advent of Code](https://adventofcode.com) 谜题。

# What are parsers\?

Most programs need to read some input before they know what to do. A video game will move a character based on keyboard input, the `cat` command will display different text based on its arguments, and accounting software will output a very good or a very worrying message depending on the spreadsheet it loads.
> 大多数程序在知道要做什么之前需要读取一些输入。电子游戏将根据键盘输入移动一个字符，`cat` 命令将根据其参数显示不同的文本，会计软件将根据其加载的电子表格输出一个非常好的或非常令人担忧的信息。

Program input can come in many different forms. Sometimes the input is already structured, for example, most video game programming environments can recognize when a mouse button is pressed, know which mouse button it was, and call the appropriate code to react to that. But sometimes input is unstructured \-- it can't be easily understood by your program. For example, the input could be a text file. Your programming languages probably understands that it's been given a text file. But it doesn't understand what the text _means_ or what it should do in response. So programmers use parsers to take this unstructured file and examine it, match it against some logical rules. Once the data has been structured, you can call the appropriate functions to handle it.
> 程序输入可以有许多不同的形式。有时候，输入已经是结构化的，例如，大多数电子游戏编程环境可以识别鼠标按钮被按下的时间，知道是哪个鼠标按钮，并调用适当的代码来对此做出反应。但有时输入是非结构化的 —— 它不容易被你的程序理解。例如，输入可以是一个文本文件。您的编程语言可能会理解它得到了一个文本文件。但是它不理解文本的**意思**，也不知道它应该怎么回应。因此，程序员使用解析器来获取这个非结构化文件并检查它，将其与一些逻辑规则进行匹配。一旦数据被结构化，就可以调用适当的函数来处理它。

For example, in [Advent of Code day 5](https://adventofcode.com/2021/day/5) you're given a list of lines and must find points where two or more lines overlap. The Advent of Code website gives the puzzle input in a text file like this:
> 例如，在 [Advent of Code day 5](https://adventofcode.com/2021/day/5) 中，已知一个行列表，必须找到两行或更多行重叠的点。The Advent of Code 网站提供的谜题输入文本如下:

```
0,9 -> 5,9
8,0 -> 0,8
9,4 -> 3,4
2,2 -> 2,1
7,0 -> 7,4
6,4 -> 2,0
0,9 -> 2,9
3,4 -> 1,4
0,0 -> 8,8
5,5 -> 8,2
```

Rust doesn't natively know to interpret this file as a list of lines in 2D space. To the Rust compiler, this text file is just a big String. We have to write a _parser_ which takes that string and parses it into types Rust can understand, like
> Rust 并不知道如何将这个文件解释为 2D 空间中的行列表。对于 Rust 编译器来说，这个文本文件只是一个大的 String。我们必须编写一个 _parser_，它接受字符串并将其解析为 Rust 可以理解的类型，比如

```rust
/// 2D 空间中的点（point）
pub struct Point {
    pub x: u32,
    pub y: u32,
}

/// 横跨两点的直线
pub struct Line(pub Point, pub Point);
```

If you already know the basics of Nom, or you've used parser combinators in other languages, feel free to [skip ahead](https://blog.adamchalmers.com/nom-chars/#solve-aoc), but for now, let's take a closer look at Nom.
> 如果您已经了解了 Nom 的基础知识，或者已经在其他语言中使用过解析器组合子，那么您可以[跳过](https://blog.adamchalmers.com/nom-chars/#solve-aoc)，但是现在，让我们进一步了解 Nom。

# Building parsers with Nom

Nom is a _parser combinator_ library. In general, a _combinator_ framework gives you
> Nom 是一个 _parser combinator_ （解析器组合子）库。一般来说，_combinator_ 框架会给你如下东西：

1.  A set of tiny primitive tools for doing small, simple tasks.
> 1.一批小而基础的简单解析器，用来解析简单的文本。

2.  Ways to combine those tools to accomplish more complex tasks. These are called combinators.
> 2.组合这些工具以完成更复杂任务的方法。这些叫做组合子。

For example, you can think of the Bash shell as a combinator approach. You have
> 例如，您可以将 Bash shell 看作一种组合器方法，具有如下特点

1.  A set of primitive tools like ls, cd, cat and grep that do one thing, and do it well.
> 一组基本的工具，如 ls、cd、cat 和 grep，它们只做一件事，而且做得很好。

2.  Ways to combine tools, for example |, \&\&, loops and `if` statements.
> 组合工具的方法，例如 `|`，`&&`，`loops` 和 `if` 语句。

Another example of the combinator pattern is Rust's [Result\<T,E>](https://doc.rust-lang.org/stable/std/result/enum.Result.html) type. Your primitive tools might be closures like `Fn(T) \-> Result<V, U>`. The combinators are methods like `map`, `and_then` and `or_else`.
> 组合符模式的另一个例子是 Rust 的 [Result<T,E>](https://doc.rust-lang.org/stable/std/result/enum.Result.html) 类型。`<T,E>` 你的原始工具可能是类似于 `Fn(T) -> Result<V, U>` 的闭包。组合子就是像 `map`, `and_then` 和 `or_else` 这样的方法。

Nom takes a similar approach, using combinators to combine parsers[1](#1). There are primitive parsers that match one simple value from the input string, and functions \(called combinators\) which let you combine multiple primitive parsers into a more complex \(composite\) parser. Let's look at the primitives first.
> Nom 采用了类似的方法，使用组合符来组合解析器[1](#1)。有匹配输入字符串中一个简单值的原语解析器，以及允许您将多个原语解析器组合成更复杂的(复合)解析器的函数(称为组合器)。让我们先看看基础的解析器。

## Primitive parsers

A parser's job is to consume bytes from some _input_, and try converting them into some _output_ Rust value. If this conversion succeeds, the parser should return two things:
> 解析器的工作是使用来自某个 _input_ 的字节，并尝试将它们转换为某个 _output_（Rust 值）。如果转换成功，解析器应该返回两个东西:

1.  The **remaining input** which wasn't parsed, so that you can continue running other parsers on the rest of the input file
> 1.未被解析的**剩余输入**，以便您可以继续在输入的剩余部分上运行其他解析器

2.  The parsed **output** value
> 2.解析的输出值

If the conversion failed, the parser should return some helpful error.
> 如果转换失败，解析器应该返回一些有用的错误。

In Nom, parsers are just functions. Each parser function has three generic types:
> 在 Nom 中，解析器只是函数。每个解析器函数都有三种泛型类型:

* `I` is for _input_. In this tutorial, our input will always be a string, but you can use Nom to parse binary \(`Vec<u8>` or `Bytes`\) or your own custom type, for example tokens output by a [lexer](https://en.wikipedia.org/wiki/Lexical_analysis).
> `I` 代表 _input_。在本教程中，我们的输入将始终是一个字符串，但您可以使用 Nom 来解析二进制(`Vec<u8>` 或 `Bytes`)或您自己的自定义类型，例如由 [lexer](https://en.wikipedia.org/wiki/Lexical_analysis) 输出的令牌。

* `O` is for _output_. The parser reads some bytes from the input and tries to convert them to its output value. Some parsers will output a number, a string, or some "business logic" type like a Person or User struct. In our Advent of Code above, we'll write parsers that output Points and Lines.
> `O` 代表 _output_。解析器从输入中读取一些字节，并尝试将它们转换为输出值。一些解析器将输出一个数字、一个字符串或一些“业务逻辑”相关的类型，比如 Person 或 User 结构体。在上面的代码实现中，我们将编写输出 Points 和 Lines 的解析器。

* `E` is for _error_ \(just like in the stdlib `Result<T,E>`\). It's generic because Nom supports different error types with different trade-offs. We'll discuss them later.
> `E` 是 _error_ (就像标准库中的 `Result<T,E>`)。因为 Nom 支持不同的错误类型的权衡，因而它是通用的。我们以后再讨论。

Each function's type signature is basically the same: `Fn(I) \-> Result<(I, O), E>`. It's just a function that takes the input string, reads some bytes, and tries to convert them into an output value `O`. If that conversion succeeds, it returns the rest of the input \(the remainder, the part the parser didn't need to read to get a value\) and the value, which is why the OK branch is `(I, O)`. If it fails, it just returns the error `E`.
> 每个函数的类型签名基本相同: `Fn(I) -> Result<(I, O)， E>`。它只是一个接受输入字符串的函数，读取一些字节，并试图将它们转换为输出值 `O`。如果转换成功，它返回输入的剩余部分(剩余部分，解析器不需要读取来获得值)和值，这就是为什么 Ok 分支下的类型是 `(I, O)`。如果失败，它只返回错误 `E`。

Here's a very simple example parser: [`digit1`](https://docs.rs/nom/latest/nom/character/complete/fn.digit1.html). Technically it's `nom::character::complete::digit1`[2](#2). The nom docs are usually really good, so let's take a look at their example.
> 这里有一个非常简单的解析器示例: [`digit1`](https://docs.rs/nom/latest/nom/character/complete/fn.digit1.html)。技术上是 `nom::character::complete::digit1`[2](#2)。nom 文档非常好，我们直接看看他们的例子。

```rust
use nom::character::complete::newline;

fn parser(input: &str) -> IResult<&str, &str> {
    digit1(input)
}

assert_eq!(parser("21c"), Ok(("c", "21")));
assert_eq!(parser("c1"), Err(Err::Error(Error::new("c1", ErrorKind::Digit))));
assert_eq!(parser(""), Err(Err::Error(Error::new("", ErrorKind::Digit))));
```

So, we see that `digit1` is just a function. It takes one argument, the input string. The parser reads characters from the start of the input string, and if the character is a digit, it adds it to the output. When it finds a non-digit character, it terminates. Once it terminates it returns an [IResult](https://docs.rs/nom/latest/nom/type.IResult.html)... what's that\?
> 因此，我们看到 `digit1` 只是一个函数。它接受一个参数，即输入字符串。解析器从输入字符串的开头读取字符，如果字符是数字，则将其添加到输出中。当它发现一个非数字字符时，它终止。一旦它终止，它返回一个 [IResult](https://docs.rs/nom/latest/nom/type.IResult.html)… 那又是什么?

Remember above, we said that parsers should return `(I, O)` if they succeed \(the remaining input string that _wasn't_ consumed to get an output value, and the output value itself\), and `E` if they fail. Well, `IResult` is just shorthand for this. It's a convenience [type alias](https://doc.rust-lang.org/book/ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases): `type IResult<I, O, E = nom::error::Error<I>> = Result<(I, O), E>`. Note that `E`, the error type, defaults to a certain Nom error type \-- we'll talk about that in a second. The docs explain `IResult` well:
> 记住上面，我们说过，解析器应该返回 `(I, O)`，如果它们成功(_不是_ 获取输出值的剩余输入字符串，以及输出值本身)，如果它们失败，则返回 `E`。`IResult` 是这个的缩写。这是一个方便的[类型别名](https://doc.rust-lang.org/book/ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases): `type IResult<I, O, E = nom::error::Error<I>> = Result<(I, O), E>` 注意，错误类型 `E` 默认为特定的 Nom 错误类型 —— 我们马上就会讨论这个问题。文档中也很好地解释了 `IResult`:

> Holds the result of parsing functions. The `Ok` side is a pair containing the remainder of the input \(the part of the data that was not parsed\) and the produced value. The `Err` side contains an instance of [`nom::Err`](https://docs.rs/nom/latest/nom/enum.Err.html).

As expected, if the input string _doesn't_ start with any digits, Nom returns an error. The example uses Nom's default Error type, which tells you two things:
> 正如预期的那样，如果输入字符串 _不_ 以任何数字开头，Nom 将返回一个错误。这个例子使用了 Nom 的默认 Error 类型，它告诉你两件事:

1.  Where in the input string Nom failed.
> 1.入参有问题
2.  What Nom was trying to parse when it failed.
> 2.Nom 尝试解析失败了

If you want more detail, you can use `E` = [`VerboseError`](https://docs.rs/nom/latest/nom/error/struct.VerboseError.html) instead of the default error type. This has a bit more overhead at runtime, but makes debugging easier.
> 如果你想要更多的细节，你可以使用 `E` = [`VerboseError`](https://docs.rs/nom/latest/nom/error/struct.VerboseError.html) 来代替默认的错误类型。这给运行时增加了一点开销，但使调试更容易。

Let's look at another parser, named [`tag`](https://docs.rs/nom/latest/nom/bytes/complete/fn.tag.html). It matches some specific substring chosen by the programmer. The Nom docs have an example, using `tag` to match the substring "Hello":
> 让我们看看另一个名为 [`tag`](https://docs.rs/nom/latest/nom/bytes/complete/fn.tag.html) 的解析器。它匹配由程序员选择的特定子字符串。Nom 文档中有一个例子，使用 `tag` 来匹配子字符串 “Hello”：

```rust
use nom::bytes::complete::tag;

fn parser(s: &str) -> IResult<&str, &str> {
  tag("Hello")(s)
}

assert_eq!(parser("Hello, World!"), Ok((", World!", "Hello")));
assert_eq!(parser("Something"), Err(Err::Error(Error::new("Something", ErrorKind::Tag))));
assert_eq!(parser(""), Err(Err::Error(Error::new("", ErrorKind::Tag))));
```

Notice the `tag` function has a different type signature to the `digit1` function\! That's because `digit1` is a parser \-- it takes an input string and outputs an `IResult`, defined as ["the result of parsing functions"](https://docs.rs/nom/latest/nom/type.IResult.html). But `tag` isn't exactly a parser \-- it's a function which _outputs_ a parser. It takes one argument, the substring to match on, and returns a parser which matches that string.
> 注意，`tag` 函数与 `digit1` 函数有不同的类型签名！这是因为 `digit1` 是一个解析器 —— 它接受一个输入字符串并输出一个 `IResult`，定义为["解析函数的结果"](https://docs.rs/nom/latest/nom/type.IResult.html)。但是 `tag` 并不是一个解析器 —— 它是一个 _输出_ 为解析器的函数。它接受一个参数，即要匹配的子字符串，并返回匹配该字符串的解析器。

* `digit` is a parser which takes one argument \(an input string\) and returns `IResult`.
> `digit` 是一个解析器，它接受一个参数(一个输入字符串)并返回 `IResult`。
* `tag` takes one argument, a string to match, and returns a parser. That parser takes one argument \(an input string\) and returns `IResult`.
* `tag` 接受一个参数，一个要匹配的字符串，并返回一个解析器。该解析器接受一个参数(一个输入字符串)并返回 `IResult`。

Nom's other primitive parsers fall into these categories: they're either actually parsers, or functions that return a parser. For example:
> Nom 的其他基本解析器可以分为以下几类：它们要么是真正的解析器，要么是返回解析器的函数。例如:

* [`digit0`](https://docs.rs/nom/latest/nom/character/complete/fn.digit0.html), [`alpha1`](https://docs.rs/nom/latest/nom/character/complete/fn.alpha1.html) and [`line_ending`](https://docs.rs/nom/latest/nom/character/complete/fn.line_ending.html) are parsers
> [`digit0`](https://docs.rs/nom/latest/nom/character/complete/fn.digit0.html)，[`alpha1`](https://docs.rs/nom/latest/nom/character/complete/fn.alpha1.html) 和 [`line_ending`](https://docs.rs/nom/latest/nom/character/complete/fn.line_ending.html) 是解析器
* [`char`](https://docs.rs/nom/latest/nom/character/complete/fn.char.html) 接受一个字符，并返回匹配该字符的解析器。

OK, so we can now build small parsers that recognize particular characters. But that's not going to be enough to parse the Advent of Code input file. We need a parser that can parse the text "\(3,4\)" into `Point{x: 3, y: 4}`. To do that, we need to combine these small parsers into a composite parser that can convert text into a Point.
> 好了，现在我们可以构建小型的解析器来识别特定的字符。但是这还不足以解析 Advent of Code 输入文件。我们需要一个解析器来解析文本“(3,4)”为 `Point{x: 3, y: 4}`。为此，我们需要将这些小型解析器组合到一个复合解析器中，该复合解析器可以将文本转换为 Point。

## Combining parsers with... combinators
> 用。。。组合解析器 组合子

So far we've seen two types of Nom functions:
> 到目前为止，我们已经看到了两种类型的 Nom 函数:

1.  解析器, 如：`digit1`
2. 返回解析器的函数, 如：`tag`

We're about to examine a third kind:
> 我们将研究第三种:

3.  Functions that take a parser as an argument, and return a new parser, e.g. [`pair`](https://docs.rs/nom/latest/nom/sequence/fn.pair.html).
> 接受一个解析器作为参数并返回一个新的解析器的函数，例如 [`pair`](https://docs.rs/nom/latest/nom/sequence/fn.pair.html)。

The `pair` function takes two parsers as arguments \(call them `p1` and `p2`\). It returns a new parser that chains them together. Each parser takes its input type I \(usually string\) and outputs \(I, O\) for the remaining input and the output value it parsed:
>  `pair` 函数以两个解析器作为参数(分别称为 `p1` 和 `p2`)。它返回一个新的解析器，将它们链接在一起。每个解析器接受它的输入类型 I (通常是字符串)，并输出 (I, O) 作为剩余的输入和它解析的输出值：

![the input remaining after p1 becomes the input to p2, and their outputs get paired together](/nom-chars/parser_pair_railroad.png)

So basically it:

1.  Runs `p1`
> 1. 执行 `p1`
2.  If `p1` failed, return the error.
> 2.如果 `p1` 解析失败，返回错误
3.  Otherwise, the remaining input from `p1` becomes the input for `p2`
> 3.否则，`p1` 执行后的“剩余输入”将成为 `p2` 的输入
4.  Run `p2`
> 4.执行 `p2`

As usual, the official docs have a good example:
> 通常，官方文档中有一个很好的示例：

```rust
use nom::sequence::pair;
use nom::bytes::complete::tag;

// `pair` gets an object from the first parser, then gets another object from the second parser.
let mut parser = pair(tag("abc"), tag("efg"));

assert_eq!(parser("abcefg"), Ok(("", ("abc", "efg"))));
assert_eq!(parser("abcefghij"), Ok(("hij", ("abc", "efg"))));
assert_eq!(parser(""), Err(Err::Error(("", ErrorKind::Tag))));
assert_eq!(parser("123"), Err(Err::Error(("123", ErrorKind::Tag))));
```

So, that's a very simple parser combinator which takes two parsers and outputs a new parser. Nom is full of these helpful little functions. For example, there's [`separated_pair`](https://docs.rs/nom/latest/nom/sequence/fn.separated_pair.html) which takes _three_ parsers: it runs all three in sequence and discards the middle parser's output. It's useful for removing separators, e.g. parsing "1,2" into "1" and "2".
> 这是一个非常简单的解析器组合子它接受两个解析器并输出一个新的解析器。Nom 有很多这些有用的小功能。例如，有 [`separated_pair`](https://docs.rs/nom/latest/nom/sequence/fn.separated_pair.html)，它接受 _three_ 解析器：它依次运行所有三个解析器，并丢弃中间解析器的输出。它对删除分隔符很有用，例如将“1,2”解析为“1”和“2”。

```rust
fn main() {
    use nom::{character::complete::{char, digit1}, sequence::separated_pair};

    let mut parser = separated_pair(digit1, char(','), digit1);
    assert_eq!(parser("1,2"), Ok(("", ("1", "2"))));
}
```

So far we've looked at combinators that take multiple parsers as arguments. But here's one that only takes a single parser: it's called [`map`](https://docs.rs/nom/latest/nom/combinator/fn.map.html). It wraps a parser, then passes the output into a closure.

```rust
use nom::{
    character::complete::{alpha1, char},
    combinator::map,
    sequence::separated_pair,
    IResult,
};

/// Some example business logic type that our program uses
#[derive(PartialEq, Eq, Debug)]
struct Person {
    first_name: String,
    last_name: String,
}

impl Person {
    fn parse(input: &str) -> IResult<&str, Self> {
        // Parses two words, separated by a space.
        // Note: alpha1 recognizes one or more letters from A to Z.
        let two_words_parser = separated_pair(alpha1, char(' '), alpha1);

        // Defines a new parser which wraps the `two_words_parser`, then
        // passes the resulting pair into a closure.
        let mut person_parser = map(
            two_words_parser,
            |(first_name, last_name)| Self {
                first_name: String::from(first_name),
                last_name: String::from(last_name),
            },
        );

        // Use the parser
        person_parser(input)
    }
}

fn main() {
    let (remaining_input, actual) = Person::parse("Adam Chalmers_").unwrap();
    let expected = Person {
        first_name: "Adam".to_owned(),
        last_name: "Chalmers".to_owned(),
    };
    assert_eq!(remaining_input, "_");
    assert_eq!(expected, actual);
}
```

The `map` combinator expects a closure that always succeeds. But sometimes you want a closure that might fail. For example, you might have a parser that outputs a string, and then try to convert that string into a number. If the closure returns a Result, we can use `map_res`.

```rust
use nom::{character::complete::digit1, combinator::map_res, IResult};
use std::str::FromStr;

/// Parse a number from the string, but return it as an actual Rust number, not a string.
pub fn parse_numbers(input: &str) -> IResult<&str, u32> {
    let mut parser = map_res(digit1, u32::from_str);
    parser(input)
}

fn main() {
    let (actual_input_remaining, actual_output) = parse_numbers("123").unwrap();
    let expected_output = 123;
    let expected_input_remaining = "";
    assert_eq!(actual_output, expected_output);
    assert_eq!(actual_input_remaining, expected_input_remaining);
}
```

There are many other combinators in Nom's modules:

* [`nom::sequence`](https://docs.rs/nom/latest/nom/sequence/index.html) contains the `pair` and `separated_pair` combinators we've already seen. Others include [`tuple`](https://docs.rs/nom/latest/nom/sequence/fn.tuple.html) which takes any number of different parsers and runs them. `pair` is a special case of `tuple` where the tuple has length 2.
* [`nom::multi`](https://docs.rs/nom/latest/nom/multi/index.html) has combinators that take a parser and run it many times, e.g. [`many0`](https://docs.rs/nom/latest/nom/multi/fn.many0.html) wraps another parser and runs it 0 or more times, or [`separated_list1`](https://docs.rs/nom/latest/nom/multi/fn.separated_list1.html) which can parse `"1,2,3"` into `vec![1,2,3]`.
* [`nom::branch`](https://docs.rs/nom/latest/nom/branch/index.html) has combinators like [`alt`](https://docs.rs/nom/latest/nom/branch/fn.alt.html) for trying one of several different parsers \(e.g. parsing either "3" or 0003 into the numeric value 3\)
* [`nom::combinator`](https://docs.rs/nom/latest/nom/combinator/index.html) has general-purpose combinators e.g. [`map_opt`](https://docs.rs/nom/latest/nom/combinator/fn.map_opt.html) \(like `map_res` but the closure returns Option, not Result\)

OK\! That's the basics of Nom: parsers consume bytes from an input \(often a string\) and output a Rust value. There are primitive parsers that match simple patterns, like some alphanumeric characters or whitespace. Then there are combinators, which take one or more parsers and produce more complex ones. Those parsers can then become the input for yet more combinators to make even more complex parsers. If you keep applying this process, you can parse some pretty complicated formats, like HTTP or EXIF. Let's take a look at a real-world example I used Nom for: parsing Advent of Code, day 5.

# Solving problems with Nom

Above we [described the problem](https://blog.adamchalmers.com/nom-chars/#what-are-parsers): read a text file and parse it into `Line` objects. The key to parsing with Nom is to **start small**. Find a small part of the input that you _do_ know how to parse, and unit test it to make sure it works. Then build up more complex parsers from there.

Obviously, we'll need to know how to parse a single 2D point.

```rust
use nom::{
    character::complete::{char, digit1},
    combinator::{map, map_res},
    sequence::separated_pair,
    IResult,
};
use std::str::FromStr;

/// Parse a `u32` from the start of the input string.
/// (this is copied/pasted from earlier in the blog post!)
pub fn parse_numbers(input: &str) -> IResult<&str, u32> {
    map_res(digit1, u32::from_str)(input)
}

/// A point in 2D space
#[derive(Debug, Eq, PartialEq)]
pub struct Point {
    pub x: u32,
    pub y: u32,
}

impl Point {
    /// Parse a point.
    /// Like all Nom parsers, this has an Input type, Output type and Error type.
    /// Its Input type is &str (because we're parsing a text file that gets read into a string)
    /// Its Output type is Point (which we can refer to as Self inside an `impl Point` block)
    /// Its Error type will be the default Nom error type, so we don't have to
    /// specify it here.
    fn parse(input: &str) -> IResult<&str, Self> {

        // This parser outputs a (u32, u32).
        // It uses the `parse_numbers` parser
        // and the `separated_pair` combinator discussed earlier.
        let parse_two_numbers = separated_pair(parse_numbers, char(','), parse_numbers);

        // Map the (u32, u32) into a Point.
        // Uses the `parse_two_numbers` parser defined on the previous line,
        // and the `map` combinator discussed earlier.
        map(parse_two_numbers, |(x, y)| Point { x, y })(input)
    }
}

// Because each parser is just a pure, deterministic function,
// it's very easy to unit test them!
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_point() {
        let tests = [
            ("1,2", Point { x: 1, y: 2 }, ""),
            ("1,2asdf", Point { x: 1, y: 2 }, "asdf"),
        ];
        for (input, expected_output, expected_remaining_input) in tests {
            let (remaining_input, output) = Point::parse(input).unwrap();
            assert_eq!(output, expected_output);
            assert_eq!(remaining_input, expected_remaining_input);
        }
    }
}
```

OK, great. Now we can reuse that Point parser for a Line parser. The Advent of Code text file stores lines like this:

> 0,9 \-> 5,9

```rust
/// A line spanning two points.
#[derive(Debug, Eq, PartialEq)]
pub struct Line(pub Point, pub Point);

impl Line {
    /// Parse a Line from the input string.
    fn parse(input: &str) -> IResult<&str, Self> {
        let parse_arrow = tag(" -> ");

        // Parse two points, separated by an arrow
        let parse_points = separated_pair(Point::parse, parse_arrow, Point::parse);

        // If the parse succeeded, put those two points into a Line
        map(parse_points, |(p0, p1)| Line(p0, p1))(input)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_line() {
        let tests = [
            (
                "0,9 -> 5,9",
                Line(Point { x: 0, y: 9 }, Point { x: 5, y: 9 }),
                "",
            ),
            (
                "0,9 -> 5,9xyz",
                Line(Point { x: 0, y: 9 }, Point { x: 5, y: 9 }),
                "xyz",
            ),
        ];
        for (input, expected_output, expected_remaining_input) in tests {
            let (remaining_input, output) = Line::parse(input).unwrap();
            assert_eq!(remaining_input, expected_remaining_input);
            assert_eq!(output, expected_output);
        }
    }
}
```

Now it should be easy to parse the rest. We know each line in the text file should encode one Line object. We can use [`separated_list1`](https://docs.rs/nom/latest/nom/multi/fn.separated_list1.html) to match a line, then match and discard a newline, then match a line, then match and discard a newline, etc etc until the end of the file.

```rust
use nom::character::complete::line_ending;

/// Parse the whole Advent of Code day 5 text file.
pub fn parse_input(s: &str) -> Vec<Line> {
    let (remaining_input, lines) = separated_list1(line_ending, Line::parse)(s).unwrap();
    assert!(remaining_input.is_empty());
    lines
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_file() {
        // Assuming you're logged in, you can download your Day 5 puzzle input from
        // https://adventofcode.com/2021/day/5/input
        // Then save it under src/data/input.txt
        // The `include_str!` macro reads a file into a String at compile-time.
        // I use it for all my AoC problems!
        let input = include_str!("data/input.txt");
        let lines = parse_input(input);
        assert_eq!(lines.len(), 500);
    }
```

Now we can parse the entire text file\! You can see the full code [on GitHub](https://github.com/adamchalmers/aoc21/blob/master/day5/src/parse.rs), feel free to open PRs if you've got any suggestions.

I find the "start small" approach really productive. Using many small parsers instead of one big parser makes it very easy to understand and test each little step. I can choose any parser here and tell exactly what it does just by looking at the type signature. If I want to know the exact kind of text it parses, I can check the unit tests. This makes it easy to understand the code even years after I last touched it. I should know, because a few years ago I wrote the [fountain crate](https://crates.io/crates/fountain) which parses the [Fountain markdown language](https://fountain.io/) in Nom, and I still find the code [pretty readable](https://github.com/adamchalmers/fountain-rs/blob/master/fountain/src/parse.rs)[3](#3).

# Next steps

I hope this helped you understand Nom and parser combinators\! If you want to learn more, I suggest taking a look at Nom's [README.md](https://github.com/Geal/nom/blob/main/README.md) \-- it has a list of links to different docs, including the API docs, some design documents and even a "which combinator should I use" guide. Nom's creator Geoffroy Couprie has really gone above and beyond to make some good docs\!

We'll dive further into Nom in future posts. For now, if you have any questions, leave a comment below or talk to me on twitter [\@adam\_chal](https://twitter.com/adam_chal). And if you liked this article, and want to get paid to talk about Rust full time with me: email your resume to ehfg-wbof\@pybhqsyner.pbz after rot13. The last person who reached out like this got hired, so don't be shy\! We're currently hiring remote workers based in the EU and USA \(we have offices in [a lot of cities](https://www.cloudflare.com/careers/jobs/)\).

_Thank you to Joshua Nelson, Michael Sproul and Stephen Merity for reading the draft\!_

* * *

#### Footnotes

1.Nom is inspired by Parsec, the original parser combinator library from Haskell. I first learned about Parsec from its chapter in [Real World Haskell](http://book.realworldhaskell.org/read/using-parsec.html) and was impressed by how easily the concept could be ported into Rust.

2.There are two kinds of parsers, _complete_ for when you can read the whole input into memory, and _streaming_ for when you're getting the input bit by bit. For Advent of Code, the input files are always big enough to fit into memory. But if you were streaming, say, really huge datasets that couldn't fit into memory, you'd use _streaming_. Or if you were reading from a streaming protocol like an HTTP or gRPC body, you'd probably use streaming there too.

3.Note the type a lot of complicated boilerplate \-- that's because I wanted the parsers to support either the default Nom error, or Nom's VerboseError. If you have a suggestion for improving it without breaking backwards compatibility, please let me know\!
