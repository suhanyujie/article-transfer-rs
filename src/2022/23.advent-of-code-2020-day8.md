>* Advent of Code 2020 Day8 è¯‘æ–‡ï¼ˆç”¨ Rust å®ç° Advent of Code 2020 ç¬¬8å¤©ï¼‰
>* åŸæ–‡é“¾æ¥ï¼šhttps://fasterthanli.me/series/advent-of-code-2020/part-8
>* åŸæ–‡ä½œè€…ï¼š[Amos](https://twitter.com/fasterthanlime)
>* è¯‘æ–‡æ¥è‡ªï¼šhttps://github.com/suhanyujie/article-transfer-rs/
>* è¯‘è€…ï¼š[suhanyujie](https://ishenghuo.cnblogs.com/)
>* psï¼šæ°´å¹³æœ‰é™ï¼Œå¦‚æœ‰ä¸å½“ä¹‹å¤„ï¼Œæ¬¢è¿æŒ‡æ­£
>* æ ‡ç­¾ï¼šRustï¼Œadvent of code, algo

åˆä¸€ä¸ª [Advent of Code 2020](https://adventofcode.com/2020/day/8) é—®é¢˜æ—¶é—´ã€‚

è¿™é¢˜å¬èµ·æ¥ä¼šå¾ˆæœ‰è¶£ï¼Œæˆ‘ä»¬çš„è¾“å…¥æœ‰ç‚¹åƒæ±‡ç¼–ï¼Œç±»ä¼¼äºè¿™æ ·:

```text
nop +0
acc +1
jmp +4
acc +3
jmp -3
acc -99
acc +1
jmp -4
acc +6
```

æˆ‘ä»¬è¦åšçš„ç¬¬ä¸€ä»¶äº‹å°±æ˜¯å®šä¹‰ç±»å‹ã€‚

è§£å†³è¿™ä¸ªé—®é¢˜çš„æ–¹æ³•å¯èƒ½ä¸æ­¢ä¸€ç§ï¼Œä½†æ˜¯è®©æˆ‘ä»¬çœ‹çœ‹è¿™ä¸ª:

```rust
#[derive(Debug, Clone, Copy)]
enum InstructionKind {
    Nop,
    Acc,
    Jmp,
}

#[derive(Debug, Clone, Copy)]
struct Instruction {
    kind: InstructionKind,
    operand: isize,
}

type Program = Vec<Instruction>;
```

é‚£ä¹ˆè®©æˆ‘ä»¬ç¼–å†™ä¸€ä¸ªéå¸¸å¿«é€Ÿçš„è§£æå™¨ â€”â€” è¿™æ¬¡æˆ‘ä»¬ç”šè‡³ä¸éœ€è¦ä½¿ç”¨ `peg`ã€‚

```rust
fn parse_program(input: &str) -> Program {
    input
        .lines()
        .map(|l| {
            let mut tokens = l.split(' ');
            Instruction {
                kind: match tokens.next() {
                    Some(tok) => match tok {
                        "nop" => InstructionKind::Nop,
                        "acc" => InstructionKind::Acc,
                        "jmp" => InstructionKind::Jmp,
                        _ => panic!("unknown instruction kind {}", tok),
                    },
                    None => panic!("for line {}, expected instruction kind", l),
                },
                operand: match tokens.next() {
                    Some(tok) => tok.parse().unwrap(),
                    None => panic!("for line {}, expected operand", l),
                },
            }
        })
        .collect()
}
```

```rust
fn main() {
    let program = parse_program(include_str!("input.txt"));
    dbg!(program);
}
```

```shell
$ cargo run --quiet
[src/main.rs:42] program = [
    Instruction {
        kind: Nop,
        operand: 0,
    },
    Instruction {
        kind: Acc,
        operand: 1,
    },
    Instruction {
        kind: Jmp,
        operand: 4,
    },
    Instruction {
        kind: Acc,
        operand: 3,
    },
    Instruction {
        kind: Jmp,
        operand: -3,
    },
    Instruction {
        kind: Acc,
        operand: -99,
    },
    Instruction {
        kind: Acc,
        operand: 1,
    },
    Instruction {
        kind: Jmp,
        operand: -4,
    },
    Instruction {
        kind: Acc,
        operand: 6,
    },
]
```

ä¸‹ä¸€æ­¥ â€”â€” æˆ‘ä»¬è¦æ¨¡æ‹Ÿä¸€å°æœºå™¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„æœºå™¨çŠ¶æ€æ˜¯ä»€ä¹ˆæ ·çš„ï¼Ÿ

æˆ‘ä»¬æœ‰ä¸€ä¸ªç´¯åŠ å™¨å’Œä¸€ä¸ªç¨‹åºè®¡æ•°å™¨ â€”â€” å®ƒä»¬éƒ½ä» 0 å¼€å§‹ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°æ´¾ç”Ÿ `Default` traitã€‚

```rust
#[derive(Debug, Clone, Copy, Default)]
struct State {
    /// Program counter
    pc: usize,
    /// Accumulator
    acc: isize,
}
```

ä»é‚£é‡Œï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ `State` ä¸Šå®ç°ä¸€ä¸ª `.next()` æ–¹æ³•ï¼Œå®ƒæ¥å—ä¸€ä¸ªç¨‹åºï¼Œå¹¶è¿”å›ä¸‹ä¸€ä¸ª `State`ï¼

æˆ‘ä»¬çš„ `State` å¾ˆå°ï¼Œè€Œä¸”æ˜¯ `Copy`ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡å€¼è·å–å®ƒï¼Œå¹¶é€šè¿‡å€¼è¿”å›å®ƒã€‚æˆ‘ä»Šå¤©ä¸æƒ³åšé”™è¯¯å¤„ç†ï¼Œæ‰€ä»¥æˆ‘ä»¬åªèƒ½ `panic!` äº†ï¼å¦‚æœæˆ‘ä»¬é‡åˆ°ä¸€ä¸ªæ— æ•ˆçš„æŒ‡ä»¤ï¼Œæ¯”å¦‚è·³è½¬åˆ° 0 ä¹‹å‰æˆ–è€…ç¨‹åºç»“æŸåè·³è½¬ã€‚

```rust
use std::convert::TryInto;

impl State {
    fn next(self, program: &Program) -> Self {
        let ins = program[self.pc];
        match ins.kind {
            InstructionKind::Nop => Self {
                pc: self.pc + 1,
                ..self
            },
            InstructionKind::Acc => Self {
                pc: self.pc + 1,
                acc: self.acc + ins.operand,
            },
            InstructionKind::Jmp => Self {
                pc: (self.pc as isize + ins.operand).try_into().unwrap(),
                ..self
            },
        }
    }
}
```

ç„¶åæˆ‘ä»¬å¯ä»¥è¯•è¯•äº†ï¼

```rust
fn main() {
    let program = parse_program(include_str!("input.txt"));

    let mut state: State = Default::default();
    dbg!("initial state", state);

    for _ in 0..5 {
        println!("will execute {:?}", program[state.pc]);
        state = state.next(&program);
        dbg!(state);
    }
}
```

```shell
$ cargo run --quiet
[src/main.rs:74] "initial state" = "initial state"
[src/main.rs:74] state = State {
    pc: 0,
    acc: 0,
}
will execute Instruction { kind: Nop, operand: 0 }
[src/main.rs:79] state = State {
    pc: 1,
    acc: 0,
}
will execute Instruction { kind: Acc, operand: 1 }
[src/main.rs:79] state = State {
    pc: 2,
    acc: 1,
}
will execute Instruction { kind: Jmp, operand: 4 }
[src/main.rs:79] state = State {
    pc: 6,
    acc: 1,
}
will execute Instruction { kind: Acc, operand: 1 }
[src/main.rs:79] state = State {
    pc: 7,
    acc: 2,
}
will execute Instruction { kind: Jmp, operand: -4 }
[src/main.rs:79] state = State {
    pc: 3,
    acc: 2,
}
```

æˆ‘ä»¬éœ€è¦å›ç­”çš„é—®é¢˜æ˜¯: **åœ¨ç¬¬äºŒæ¬¡æ‰§è¡ŒæŒ‡ä»¤ä¹‹å‰ï¼Œç´¯åŠ å™¨ä¸­çš„å€¼æ˜¯ä»€ä¹ˆï¼Ÿ**

æˆ‘ä»¬å¯ä»¥ç”¨å‘½ä»¤å¼çš„æ–¹æ³•æ¥è§£å†³ï¼Œæˆ–è€…æˆ‘ä»¬å¯ä»¥æŠŠé—®é¢˜ç¡¬å¡è¿› `Iterator` é‡Œï¼Œå°±åƒè¿™é‡Œçš„æƒ¯ä¾‹ä¸€æ ·ã€‚

```rust
fn main() {
    let program = parse_program(include_str!("input.txt"));

    let mut state: State = Default::default();

    let iter = std::iter::from_fn(|| {
        state = state.next(&program);
        Some(state)
    });

    dbg!(iter.take(5).collect::<Vec<_>>());
}
```

```shell
$ cargo run --quiet
[src/main.rs:81] iter.take(5).collect::<Vec<_>>() = [
    State {
        pc: 1,
        acc: 0,
    },
    State {
        pc: 2,
        acc: 1,
    },
    State {
        pc: 6,
        acc: 1,
    },
    State {
        pc: 7,
        acc: 2,
    },
    State {
        pc: 3,
        acc: 2,
    },
]
```

ç„¶è€Œï¼Œè¿˜æœ‰ä¸€ç§æ›´å¥½çš„æ–¹æ³•æ¥ç¼–å†™è¿™ä¸ªä»£ç ï¼Œä½¿ç”¨ `itertools`ï¼Œæ‰€ä»¥è®©æˆ‘ä»¬æ¥è¯•ä¸€è¯•:

```shell
$ cargo add itertools
      Adding itertools v0.9.0 to dependencies
```

```rust
fn main() {
    let program = parse_program(include_str!("input.txt"));

    let iter = itertools::iterate(State::default(), |s| s.next(&program));
    dbg!(iter.take(5).collect::<Vec<_>>());
}
```

ç°åœ¨è¾“å‡ºä¸­è¿˜åŒ…æ‹¬åˆå§‹çš„çŠ¶æ€:

```shell
$ cargo run --quiet
[src/main.rs:74] iter.take(5).collect::<Vec<_>>() = [
    State {
        pc: 0,
        acc: 0,
    },
    State {
        pc: 1,
        acc: 0,
    },
    State {
        pc: 2,
        acc: 1,
    },
    State {
        pc: 6,
        acc: 1,
    },
    State {
        pc: 7,
        acc: 2,
    },
]
```

ç°åœ¨ï¼Œç”±äºæˆ‘ä»¬éœ€è¦ç¡®å®šä½•æ—¶ç¬¬äºŒæ¬¡è¿è¡ŒæŒ‡ä»¤ï¼Œå› æ­¤æˆ‘å¸Œæœ›ç»´æŠ¤ä¸€ä¸ªå“ˆå¸Œé›†ï¼ˆhashsetï¼‰ï¼Œå…¶ä¸­åŒ…å«æˆ‘ä»¬å·²ç»æ‰§è¡Œçš„æ‰€æœ‰æŒ‡ä»¤çš„ä½ç½®ã€‚

åªè¦ `HashSet::insert` è¿”å› `false` (å®ƒå·²ç»å­˜åœ¨è¿™ä¸ªå€¼) ï¼Œæˆ‘ä»¬å°±å¯ä»¥åœæ­¢å¹¶è¿”å›ç´¯åŠ å™¨ä¸­çš„å†…å®¹ã€‚

```rust
use std::collections::HashSet;

fn main() {
    let program = parse_program(include_str!("input.txt"));

    let mut iter = itertools::iterate(State::default(), |s| s.next(&program));
    let mut set: HashSet<usize> = Default::default();
    let answer = iter.find(|state| !set.insert(state.pc)).unwrap();

    println!(
        "Before executing {} a second time, the accumulator was {}",
        answer.pc, answer.acc
    );
}
```

```shell
$ cargo run --quiet
Before executing 1 a second time, the accumulator was 5
```

ç°åœ¨è®©æˆ‘ä»¬ç”¨çœŸæ­£çš„è¾“å…¥æ¥è¯•è¯•:

```shell
$ cargo run --quiet
Before executing 296 a second time, the accumulator was 1594
```

## ç¬¬äºŒéƒ¨åˆ†

åœ¨ç¬¬ 2 éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬éœ€è¦ä¿®å¤ç¨‹åºï¼Œä½¿å…¶å¯ä»¥ç»ˆæ­¢ â€”â€” é€šè¿‡å°†ä¸€ä¸ª jmp è½¬æ¢ä¸º nopï¼Œæˆ–è€…å°†ä¸€ä¸ª nop è½¬æ¢ä¸º jmpã€‚

ç¬¬ 1 éƒ¨åˆ†å†…å®¹ä¸­ï¼Œå‘Šè¯‰æˆ‘ä»¬å“ªä¸ªæŒ‡ä»¤å°†è¦ç¬¬äºŒæ¬¡æ‰§è¡Œï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦å¼„æ¸…æ¥šæˆ‘ä»¬æ˜¯å¦‚ä½•åˆ°è¾¾é‚£é‡Œçš„ã€‚ä½†æ˜¯æ ¹æ®æˆ‘ä»¬ç›®å‰çš„è®¾ç½®ï¼Œæˆ‘ä»¬åªæœ‰ä¸‹ä¸€ä¸ªæŒ‡ä»¤ã€‚

ä¸ºäº†å¾—åˆ°ä¸Šä¸€æ¡å’Œä¸‹ä¸€æ¡æŒ‡ä»¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ itertools çš„ `tuple_windows` æ–¹æ³•:

```rust
use itertools::Itertools;

fn main() {
    let program = parse_program(include_str!("input.txt"));

    let iter = itertools::iterate(State::default(), |s| s.next(&program));
    let mut set: HashSet<usize> = Default::default();
    let answer = iter
        .tuple_windows()
        .find(|(_, next)| !set.insert(next.pc))
        .unwrap();

    println!(
        "Before {:?}, we were at state {:?} and executed {:?}",
        answer.1, answer.0, program[answer.0.pc]
    );
}
```

```shell
$ cargo run --quiet
Before State { pc: 296, acc: 1594 }, we were at state State { pc: 317, acc: 1594 } and executed Instruction { kind: Jmp, operand: -21 }
```

å› æ­¤ï¼Œå¦‚æœæˆ‘çš„è®¡ç®—æ˜¯æ­£ç¡®çš„... åœ¨ç¬¬ `318` è¡Œï¼ˆå› ä¸ºåœ¨å¤§å¤šæ•°æ–‡æœ¬ç¼–è¾‘å™¨ä¸­è¡Œæ˜¯ä»1å¼€å§‹çš„ï¼‰ï¼Œæˆ‘ä»¬åº”è¯¥æ‰¾åˆ°..

```text
jmp -21
```

ä½†è¿™çœŸçš„æ˜¯å¯¼è‡´æ— é™å¾ªç¯çš„åŸå› å—ï¼Ÿå¦‚æœæˆ‘ä»¬å°†å®ƒæ”¹ä¸º `nop -21`ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€åœ¨å…¶ä»–åœ°æ–¹å¾ªç¯:

```shell
$ cargo run --quiet
Before State { pc: 345, acc: 1546 }, we were at state State { pc: 322, acc: 1546 } and executed Instruction { kind: Jmp, operand: 23 }
```

æˆ‘ä»¬åªèƒ½ä¿®æ”¹ä¸€æ¡æŒ‡ä»¤ã€‚

æ‰€ä»¥ï¼Œå¯èƒ½æœ‰æ›´å¥½çš„æ–¹æ³•æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ä½†æ˜¯æˆ‘ç´¯äº†ï¼Œè¿™ä¸ªç¨‹åºåªæœ‰ 656 ä¸ªæŒ‡ä»¤..

```rust
fn main() {
    let program = parse_program(include_str!("input.txt"));

    let num_jmp_and_nop = program
        .iter()
        .filter(|i| matches!(i.kind, InstructionKind::Jmp | InstructionKind::Nop))
        .count();
    dbg!(num_jmp_and_nop);
}

```

```text
$ [src/main.rs:85] num_jmp_and_nop = 291
```

å…¶ä¸­ 291ä¸ª æ˜¯ jmp å’Œ nopã€‚æˆ‘æœ‰ä¸ªä¸»æ„ï¼Œæˆ‘ä»¬ç”¨æš´åŠ›ç ´è§£æ€ä¹ˆæ ·ï¼Ÿæˆ‘ä»¬ç”Ÿæˆ 291 ä¸ªä¸åŒç‰ˆæœ¬çš„ç¨‹åºï¼Œç„¶åå¹¶è¡Œåœ°æ¨¡æ‹Ÿå®ƒä»¬æ€ä¹ˆæ ·ï¼Ÿè°å…ˆå®Œæˆï¼Œè°å°±èµ¢å¾—å¥–å“ï¼

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæŒ‡ç¤ºå®Œæˆçš„æ–¹æ³•ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†æ›´æ”¹ `State::next` ä½¿å…¶è¿”å› `Option`:

```rust
impl State {
    fn next(self, program: &Program) -> Option<Self> {
        if !(0..program.len()).contains(&self.pc) {
            return None;
        }

        let ins = program[self.pc];
        Some(match ins.kind {
            InstructionKind::Nop => Self {
                pc: self.pc + 1,
                ..self
            },
            InstructionKind::Acc => Self {
                pc: self.pc + 1,
                acc: self.acc + ins.operand,
            },
            InstructionKind::Jmp => Self {
                pc: (self.pc as isize + ins.operand).try_into().unwrap(),
                ..self
            },
        })
    }
}
```

ç„¶åå¼€å§‹æ¯”èµ›:

```rust
fn main() {
    let program = parse_program(include_str!("input.txt"));
    find_variant(&program);
}

fn flip_kind(kind: &mut InstructionKind) {
    *kind = match *kind {
        InstructionKind::Jmp => InstructionKind::Nop,
        InstructionKind::Nop => InstructionKind::Jmp,
        x => x,
    };
}

fn find_variant(program: &Program) {
    let mut variants: Vec<_> = program
        .iter()
        .enumerate()
        .filter_map(|(index, ins)| match ins.kind {
            InstructionKind::Jmp | InstructionKind::Nop => Some(index),
            _ => None,
        })
        .map(|i| {
            let mut variant = program.clone();
            flip_kind(&mut variant[i].kind);
            (i, variant)
        })
        .map(|(index, variant)| {
            itertools::iterate(Some(State::default()), move |state| {
                state
                    .unwrap_or_else(|| panic!("variant {} terminated!", index))
                    .next(&variant)
            })
        })
        .collect();

    loop {
        for v in &mut variants {
            v.next();
        }
    }
}
```

```shell
$ cargo run --quiet
thread 'main' panicked at 'variant 364 terminated!', src/main.rs:99:40
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

æœ‰æ„æ€! ç°åœ¨æˆ‘ä»¬ç»ˆäºå¯ä»¥å›ç­”è¿™ä¸ªé—®é¢˜äº†: å½“ç¨‹åºç»ˆæ­¢æ—¶ï¼Œç´¯åŠ å™¨çš„å€¼æ˜¯å¤šå°‘ï¼Ÿ

```rust
use itertools::Itertools;

fn eval(program: &Program) -> Option<isize> {
    itertools::iterate(Some(State::default()), |state| {
        state.and_then(|state| state.next(program))
    })
    .while_some()
    .last()
    .map(|s| s.acc)
}

fn main() {
    let mut program = parse_program(include_str!("input.txt"));
    flip_kind(&mut program[364].kind);
    dbg!(eval(&program));
}
```

```shell
$ cargo run --quiet
[src/main.rs:79] eval(&program) = Some(
    758,
)
```

ğŸ‰ğŸ‰ğŸ‰!

ä¸‹æ¬¡è§ï¼Œä¿é‡ã€‚








