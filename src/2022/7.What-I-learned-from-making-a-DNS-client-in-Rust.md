>* What I learned from making a DNS client in Rust 译文（Rust 实现一个 DNS 客户端，我从中学到什么）
>* 原文链接：https://blog.adamchalmers.com/making-a-dns-client/
>* 原文作者：[Adam Chalmers](https://twitter.com/adam_chal)
>* 译文来自：https://github.com/suhanyujie/article-transfer-rs/
>* 译者：[suhanyujie](https://github.com/suhanyujie)
>* ps：水平有限，翻译不当之处，还请指正。
>* 标签：Rust, DNS, DNS client

Over the last few weeks I built [my own DNS client](https://github.com/adamchalmers/dingo). Mostly because I thought dig \(the standard DNS client\) was kinda clunky. Partly because I wanted to learn more about DNS. So here's how I built it, and how you can build your own too. It's a great weekend project, and I learned a lot from finishing it.
> 在过去的几周里，我构建了[我自己的 DNS 客户端](https://github.com/adamchalmers/dingo)。主要是因为我认为 dig（一个标准的 DNS 客户端）有点笨重。另一部分原因是我想了解更多关于 DNS 的知识。这就是我如何创建它，也是你如何创建 dns 客户端的过程。它是一个很棒的周末项目，我从完成它中学到了很多。

# Why?

[Julia Evans](https://jvns.ca/) gave me the idea of making a DNS client. She's one of my favourite tech bloggers. Her blog always teaches me something, and often inspires me to go learn something new. She's also really good at summing up complex topics into really [simple little cartoons](https://wizardzines.com), like this one:
> [Julia Evans](https://jvns.ca/) 给我提供了一些思路。她是我最喜欢的技术博客作者之一。她的博客总能给我一些启发，经常激励我去学习新的东西。她也很擅长把复杂的话题总结成[简单的小漫画](https://wizardzines.com)，比如这个:

[![Comic explaining DNS query structure, when serialized for transmission over wire](/making-a-dns-client/julia-evans-dns-packet.png)](https://wizardzines.com/comics/dns-packet/)

When I read that comic, I was shocked \-- the DNS query protocol is much simpler as I thought it would be. Also, I work at a company that is, uh, kind of a big player in the DNS world. I should probably understand it better.
> 但我看完这个漫画后，我震惊了 —— DNS 查询协议比我想象的要简单得多。并且，我所在的公司在 DNS 领域算是一个大玩家。我应该更了解这个。

# 计划

The other reason I wanted to make a DNS client is that I knew I could simplify every step using some great Rust crates. The plan:
> 我想构建 DNS 客户端的另一个原因是我可以使用一些优秀的 Rust crate 来快速实现（节省很多步骤）。

1.  **使用 [picoargs](https://crates.io/crates/pico-args) 解析 CLI 参数**

    It's not as powerful as [clap](https://crates.io/crates/clap), the standard Rust "enterprise-grade" CLI crate, and it requires some more boilerplate. But I don't really need advanced CLI features, and picoargs compiles _way_ faster.
    > 它没有 [clap](https://crates.io/crates/clap) 那么强大，clap 可以视为 Rust 的企业级 crate，它依赖了很多其他 crate。但我并不需要那么多高级特性，而且 picoargs 的编译速度会快很多。

2.  **使用 [bitvec](https://docs.rs/bitvec) 序列化 DNS 查询，它是一个强大且通用的读写“位”值的库。**

    I learned how to parse bitwise protocols with Nom when doing [Advent of Code](https://adventofcode.com/2021/day/16). I considered using [deku](https://crates.io/crates/deku) instead but decided against it[1](#nodeku).
    > 在做 [Advent of Code](https://adventofcode.com/2021/day/16) 时，我学会了使用 Nom 解析“位”协议，我也考虑过使用 [deku](https://crates.io/crates/deku)，但最后还是不使用它了。

3.  **使用 stdlib [UdpSocket](https://doc.rust-lang.org/stable/std/net/struct.UdpSocket.html) 类型与 DNS 解析器通信**

    I had no idea how this worked, but the Rust stdlib is really well-documented, so I was sure I could pick it up.
    > 我不知道怎么使用，但 Rust 有很详细的标准库文档，所以我有信心能够学会它。

4.  **使用 [Nom](https://docs.rs/nom) 解析响应的二进制数据**

    I learned how to parse bitwise protocols with Nom when doing [Advent of Code](https://adventofcode.com/2021/day/16). My [previous blog post](/nom-dns) has a detailed guide to parsing DNS headers, using bit-level Nom for the one-bit flags and four-bit numbers.
    > 在做 [Advent of Code](https://adventofcode.com/2021/day/16) 的时候，我学会如何使用 Nom 解析位协议。我之前的(博客)(/nom-dns) 中更加详细的描述了解析 DNS 头部指南，使用 Nom 解析位级别的 1 个标志位和 4 个数字位。

5.  **使用 `println!` 将响应发送给用户**

# How did I go\?

It took around 800 lines of code, and I had it almost finished in a weekend. There was just one part of the spec I hadn't implemented: message compression \(MC\). Unfortunately that took me another weekend to do \-- see below for more details.
> 它用了大概 800 行代码，一个周末就能完成。规范中只有一小部分还没实现：消息的压缩（MC）。不幸的是，我又要花一个周末去完成 —— 详见下方描述。

I named it Dingo because it sounded like `dig`, and it reminds me of Australia, my home. Anyway, it works\!
> 我把它命名为 Dingo，因为它听起来像 `dig`，它让我想起了澳大利亚，我的家。无论如何，它可以正常工作！

![Screenshot of a terminal running dingo, my DNS client, and resolving a name](/making-a-dns-client/dingo_screenshot.png)

You can install it or read the finished code [on GitHub](https://github.com/adamchalmers/dingo).
> 你可以安装它，也可以在 [github](https://github.com/adamchalmers/dingo) 查看源代码。

# 我学到了什么？

## Reading RFCs

I think a lot of programmers are intimidated by RFCs. At least, I'd like to think so, because I certainly am. Maybe all my peers are secretly RFC-loving little gremlins who get a heart-pounding high from reading plaintext ASCII diagrams... but they've never mentioned it.
> 我认为很多程序员会被 rfc 吓到。至少我有这种感觉，因为我也被吓到过。可能我的其他同行是喜欢 rfc 的怪物吧，他们在阅读存文本的 ASCII 时会感到兴奋不已。。。但他们从未提过。

[RFC 1035](https://datatracker.ietf.org/doc/html/rfc1035) defines the DNS message protocol, so I had to read it very closely. This was my first time actually reading an RFC top-to-bottom, and I was surprised by how legible it was. I kept referring back to it, and I pasted key definitions and quotes from the RFC into source code comments, to help understand how all the pieces fit together. Maybe RFC 1035 is unusually good and the rest _are_ actually all scary and incomprehensible. But I liked it.
> [RFC 1035](https://datatracker.ietf.org/doc/html/rfc1035) 定义了 DNS 消息协议，所以我必须非常仔细地阅读它。这是我第一次真正地从上到下阅读 RFC，文档详细的程度让我感到吃惊。我不断地参考它，并将 RFC 中的关键字和一些关键句子粘贴到源代码注释中，以帮助理解代码的实现原因。也有可能是 RFC 1035 是唯一容易理解的文档，其他都是难理解的。无论如何，我喜欢它。

\(it's especially interesting reading this as a historical document, a primary source \-- a lot has changed since the 1980s, and it's fascinating to learn what programmers back then were thinking, before the modern internet really existed\)
> （作为一个历史留下来的文档，自从 1980 年以来，它发生了很大的变化，了解过去的程序员是如何设计互联网是非常有趣的）

## Sockets

I've never been very comfortable with sockets. I tried reading [Beej's guide to socket programming](https://beej.us/guide/bgnet/) back in college, but I didn't really have the necessary OS, networking or C skills to make it through. I know about TCP and UDP, but I knew nothing about the lower-level abstractions that unify them.
> 一直以来，我对 socket 不是很喜欢。大学的时候，我试着阅读 [Beej 的 socket 编程指南](https://beej.us/guide/bgnet/)，但当时没有合适的操作系统、网络和 c 技能来完成学习。我了解 TCP 和 UDP，但对统一他们的底层抽象却一无所知。

This project was the first time I had to open a UDP socket \-- in my regular programming, I've just relied on some networking library to handle that low level detail. So, I read the [Rust docs for UDP sockets](https://doc.rust-lang.org/stable/std/net/struct.UdpSocket.html), which are remarkably clear. A lot of the methods on UdpSocket correspond directly to Linux syscalls. When I later went back and read [Beej's socket guide](https://beej.us/guide/bgnet/) properly, it was really easy. All these syscalls were familiar \-- they're just Rust stdlib networking methods\!
> 这个项目使我第一次不得不打开一个 UDP socket —— 在常规编程中，我都是依赖于一些网络库来处理底层细节。所以，我阅读了 [Rust 的 UDP socket 文档](https://doc.rust-lang.org/stable/std/net/struct.UdpSocket.html)，它写的很清楚。UdpSocket 上的很多方法直接对应于 Linux 系统调用。当我再回过头来重新阅读 [Beej 的 socket 编程指南](https://beej.us/guide/bgnet/)时，发现很容易懂了。所有的系统调用都比较熟悉 —— 它们只是 Rust 的 stdlib 中的网络方法！

In fact, if I use `dtruss` \(a MacOS tool for inspecting which syscalls your programs make[2](#syscall)\), I can see exactly what syscalls my program is using:
> 事实上，如果我使用 `dtruss`（一个MacOS工具，用于检查您的程序有哪些系统调用），我可以确切地看到程序在使用哪个系统调用。

```bash
$ sudo dtruss dingo -t A www.twitter.com
# Skipping lots of syscalls just for starting a process on MacOS...
getentropy(0x7FF7BE8734E0, 0x20, 0x0)  = 0 0 # Used by `rand` to generate a random DNS request ID
socket(0x2, 0x2, 0x0)  = 3 0 # Create the UDP socket, aka "file descriptor 3"
ioctl(0x3, 0x20006601, 0x0)  = 0 0 # Not sure, something about the UDP socket
setsockopt(0x3, 0xFFFF, 0x1022)  = 0 0 # Set the options on the UDP socket
bind(0x3, 0x7FF7BE87346C, 0x10)  = 0 0 # Bind the UDP socket to a local address
setsockopt(0x3, 0xFFFF, 0x1006)  = 0 0 # Set more options, dunno why it needs more...
connect(0x3, 0x7FF7BE873584, 0x10)  = 0 0 # Connect to the remote DNS resolver
sendto(0x3, 0x7FAE060041F0, 0x21)  = 33 0 # Send the request to the remote DNS resolver
recvfrom(0x3, 0x7FAE060043F0, 0x200)  = 79 0 # Get the response from the remote DNS resolver
close_nocancel(0x3)  = 0 0 # Close the UDP socket
# Skipping lots of syscalls just for ending a process on MacOS
```

The syscalls `connect`, `sendto` and `recvfrom` are all from calling Rust methods `UdpSocket::{connect, send_to, recv_from}` \-- they translate 1:1 into syscalls\! That's really cool.
> 系统调用 `connect`，`sendto` 和 `recvfrom` 都来自于 Rust 中的方法 `UdpSocket::{connect, send_to, recv_from}` —— 它们将会 1:1 转换成真正的系统调用！这很酷。

## Bitvec

I really love Bitvec. It combines the usability and readability of `Vec<bool>` with the speed of using bit-twiddling tricks. It's the perfect example of Rust's no-compromises "ergonomics AND speed AND correctness" ideals.
> 我真的很喜欢 Bitvec。它结合了 `Vec<bool>` 类型的可用性和可读性，并使用了“位”的微调技巧。而这正是 Rust 毫不妥协的“人体工程学、速度和正确性”的体现。

The library exposes types for BitArray, BitVec and BitSlice. They _mostly_ work the same, but I found two little [confusing issues](https://twitter.com/adam_chal/status/1487975794379005960) where they work differently. These were easily caught with unit tests, though, so I guess it's just a learning experience. The author hopes that after Rust ships more [const generics](https://blog.adamchalmers.com/grids-2/) features, they can release a Bitvec 2.0 where these types work the same.
> 标准库公开了 BitArray，BitVec 和 BitSlice 类型。它们的工作原来基本相同，但我发现了[两个小问题](https://twitter.com/adam_chal/status/1487975794379005960)，它们的工作方式不同。这些很容易通过单元测试发现，所以我想这是一个不错的学习方式。作者希望在 Rust 发布 [const generics](https://blog.adamchalmers.com/grids-2/)后，会发布 Bitvec 2.0，使这些类型都能以类似的方式使用。

## Dig's weird output

I mentioned earlier that I hate using `dig`. It's got so many confusing fields and weird extraneous information. I just want to see what some hostname resolves to, and `dig` forces me to read all this extra info I don't care about.
> 我之前提到过，我讨厌使用 `dig`。它有那么多令人困惑的无关信息。我只是想看看一些主机名的解析是什么，而 `dig` 使我看了很多我并不关心的额外信息。

```
$ dig adamchalmers.com

; <<>> DiG 9.10.6 <<>> adamchalmers.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 51459
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;adamchalmers.com.		IN	A

;; ANSWER SECTION:
adamchalmers.com.	300	IN	A	104.19.237.120
adamchalmers.com.	300	IN	A	104.19.238.120

;; Query time: 80 msec
;; SERVER: 2600:1700:280:1f40::1#53(2600:1700:280:1f40::1)
;; WHEN: Sun Apr 10 17:48:43 CDT 2022
;; MSG SIZE  rcvd: 77
```

But after implementing a DNS client, I actually know what all these mean\! Like, "IN" doesn't mean the English word "in", it's short for "internet", because DNS technically supports many possible namespaces \(it's just that we basically only ever use `dig` for internet DNS\).

It's kind of cool reading `dig` output now because it's a reminder of how much I've learned. Oh yeah, I also learned that it's easy to make `dig` give you just the information you want:

```
$ dig +short adamchalmers.com
104.19.238.120
104.19.237.120
```

...if I'd known that back in January, I might never have started this project :\)

## I still fucking love enums

Enums are such a great way to express domain logic. Functional programmers have been talking about union types for decades now, and I'm glad they're finally appearing in other languages. It's hard to model domain logic in Go after using enums in Rust/Swift/Haskell.

## Message compression \(MC\)

MC is a neat feature that DNS servers can use to reduce the size of their responses. Instead of repeating the same hostname multiple times in the response, MC replaces a hostname with a pointer back to a previously-cited hostname. The RFC actually [explains it really well](https://datatracker.ietf.org/doc/html/rfc1035#section-4.1.4). MC helps servers fit their DNS responses into a single UDP packet, which is important because UDP is unreliable and doesn't care about truncated packets. MC requires looking _back_ at the previously-parsed bytes, but Nom only lets you look _ahead_ at remaining, unparsed bytes. It took several attempts before I could support MC in a nice, idiomatic Nom way \(\[code\]\[msgcmprcode\]\), so that cost me another weekend of work.

# Conclusion

This is one of my favourite projects I've done. My career goal for this year is to learn a lot more about Linux and networking. Writing dingo taught me a lot about one of the fundamental building blocks of the internet and how real operating systems handle it. If you're trying to learn more about low-level programming, a DNS client is a perfect challenge. It's got bitwise arithmetic, parsing, UDP networking, IP addresses and DNS hostnames. You'll learn a lot. In fact, after I wrote dingo, my friend Jesse Li [wrote his own DNS client in Python](https://twitter.com/__jesse_li/status/1504509199253966850). Clearly writing a DNS client is the hot new trend that you've got to get on. You should comment below if you try it :\)

---

#### Footnotes

1

I tried [deku](https://crates.io/crates/deku), it's very nice\! I like how it generates both serialization and deserialization methods using annotations on your struct's fields, so they never conflict, and you don't have to learn two separate libraries \(bitvec _and_ nom\).

But I wanted practice explicitly using bitvec and getting comfortable with its API \-- after all, I was only doing this project to learn things.

Also, deku uses [serde](https://crates.io/crates/serde) and [syn](https://crates.io/crates/syn) to power its \(really helpful\) serialization annotations. These crates are really powerful and can really reduce the boilerplate in your codebases. But they do add a fair bit of overhead to your build times. This isn't a problem at work, where my Rust projects are pretty large and already include serde/syn in the tree. But dingo didn't use either of them, so adding Deku would increase build time from 5 seconds to 15 seconds. I hope to use Deku in the future, but it didn't really fit for this particular project.

2

Syscalls are like functions the operating system defines, so the operating system can manage risky operations like I/O. Dtruss is a MacOS version of `strace`, a Linux tool. I learned how to use `strace` from Julia Evans' [great strace comics](https://wizardzines.com/zines/strace/) which I _highly_ recommend, I learned so much from it. Now when I write a program, I can spy on exactly what the compiled code is _actually_ doing when it runs my functions.
