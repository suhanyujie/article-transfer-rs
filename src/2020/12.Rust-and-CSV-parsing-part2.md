>* Rust and CSV parsing 译文（用 Rust 实现 csv 解析-part2）
>* 原文链接：https://blog.burntsushi.net/csv/
>* 原文作者：[BurntSushi](https://github.com/BurntSushi)
>* 译文来自：https://github.com/suhanyujie/article-transfer-rs/
>* 译者：[suhanyujie](https://github.com/suhanyujie)
>* 译者博客：[suhanyujie](https://ishenghuo.cnblogs.com/)
>* ps：水平有限，翻译不当之处，还请指正。
>* 标签：Rust，csv

## Setup
In this section, we’ll get you setup with a simple program that reads CSV data and prints a “debug” version of each record. This assumes that you have the [Rust toolchain installed](https://www.rust-lang.org/install.html), which includes both Rust and Cargo.

We’ll start by creating a new Cargo project:

```
$ cargo new --bin csvtutor
$ cd csvtutor
```

Once inside `csvtutor`, open `Cargo.toml` in your favorite text editor and add `csv = "1"` to your [dependencies] section. At this point, your `Cargo.toml` should look something like this:

```toml
[package]
name = "csvtutor"
version = "0.1.0"
authors = ["Your Name"]

[dependencies]
csv = "1"
```

Next, let’s build your project. Since you added the csv crate as a dependency, Cargo will automatically download it and compile it for you. To build your project, use Cargo:

```
$ cargo build
```

This will produce a new binary, `csvtutor`, in your `target/debug` directory. It won’t do much at this point, but you can run it:

```
$ ./target/debug/csvtutor
Hello, world!
```

Let’s make our program do something useful. Our program will read CSV data on stdin and print debug output for each record on stdout. To write this program, open `src/main.rs` in your favorite text editor and replace its contents with this:

```rust
// This makes the csv crate accessible to your program.
extern crate csv;

// Import the standard library's I/O module so we can read from stdin.
use std::io;

// The `main` function is where your program starts executing.
fn main() {
    // Create a CSV parser that reads data from stdin.
    let mut rdr = csv::Reader::from_reader(io::stdin());
    // Loop over each record.
    for result in rdr.records() {
        // An error may occur, so abort the program in an unfriendly way.
        // We will make this more friendly later!
        let record = result.expect("a CSV record");
        // Print a debug version of the record.
        println!("{:?}", record);
    }
}
```

Don’t worry too much about what this code means; we’ll dissect it in the next section. For now, try rebuilding your project:

```
$ cargo build
```

Assuming that succeeds, let’s try running our program. But first, we will need some CSV data to play with! For that, we will use a random selection of 100 US cities, along with their population size and geographical coordinates. (We will use this same CSV data throughout the entire tutorial.) To get the data, download it from github:

```
$ curl -LO 'https://raw.githubusercontent.com/BurntSushi/rust-csv/master/examples/data/uspop.csv'
```

And now finally, run your program on uspop.csv:

```
$ ./target/debug/csvtutor < uspop.csv
StringRecord(["Davidsons Landing", "AK", "", "65.2419444", "-165.2716667"])
StringRecord(["Kenai", "AK", "7610", "60.5544444", "-151.2583333"])
StringRecord(["Oakman", "AL", "", "33.7133333", "-87.3886111"])
# ... and much more
```

## Basic error handling

Since reading CSV data can result in errors, error handling is pervasive throughout the examples in this tutorial. Therefore, we’re going to spend a little bit of time going over basic error handling, and in particular, fix our previous example to show errors in a more friendly way. **If you’re already comfortable with things like `Result` and `try!/?` in Rust, then you can safely skip this section**.

Note that The [Rust Programming Language Book](https://doc.rust-lang.org/book/second-edition/) contains an [introduction to general error handling](https://doc.rust-lang.org/book/second-edition/ch09-00-error-handling.html). For a deeper dive, see [my blog post on error handling in Rust](http://blog.burntsushi.net/rust-error-handling/). The blog post is especially important if you plan on building Rust libraries.

With that out of the way, error handling in Rust comes in two different forms: unrecoverable errors and recoverable errors.

Unrecoverable errors generally correspond to things like bugs in your program, which might occur when an invariant or contract is broken. At that point, the state of your program is unpredictable, and there’s typically little recourse other than panicking. In Rust, a panic is similar to simply aborting your program, but it will unwind the stack and clean up resources before your program exits.

On the other hand, recoverable errors generally correspond to predictable errors. A non-existent file or invalid CSV data are examples of recoverable errors. In Rust, recoverable errors are handled via `Result`. A `Result` represents the state of a computation that has either succeeded or failed. It is defined like so:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

That is, a `Result` either contains a value of type `T` when the computation succeeds, or it contains a value of type `E` when the computation fails.

The relationship between unrecoverable errors and recoverable errors is important. In particular, it is **strongly discouraged** to treat recoverable errors as if they were unrecoverable. For example, panicking when a file could not be found, or if some CSV data is invalid, is considered bad practice. Instead, predictable errors should be handled using Rust’s `Result` type.

With our new found knowledge, let’s re-examine our previous example and dissect its error handling.

```rust
extern crate csv;

use std::io;

fn main() {
    let mut rdr = csv::Reader::from_reader(io::stdin());
    for result in rdr.records() {
        let record = result.expect("a CSV record");
        println!("{:?}", record);
    }
}
```

There are two places where an error can occur in this program. The first is if there was a problem reading a record from stdin. The second is if there is a problem writing to stdout. In general, we will ignore the latter problem in this tutorial, although robust command line applications should probably try to handle it (e.g., when a broken pipe occurs). The former however is worth looking into in more detail. For example, if a user of this program provides invalid CSV data, then the program will panic:

```
$ cat invalid
header1,header2
foo,bar
quux,baz,foobar
$ ./target/debug/csvtutor < invalid
StringRecord { position: Some(Position { byte: 16, line: 2, record: 1 }), fields: ["foo", "bar"] }
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: UnequalLengths { pos: Some(Position { byte: 24, line: 3, record: 2 }), expected_len: 2, len: 3 }', /checkout/src/libcore/result.rs:859
note: Run with `RUST_BACKTRACE=1` for a backtrace.
```

What happened here? First and foremost, we should talk about why the CSV data is invalid. The CSV data consists of three records: a header and two data records. The header and first data record have two fields, but the second data record has three fields. By default, the csv crate will treat inconsistent record lengths as an error. (This behavior can be toggled using the [ReaderBuilder::flexible](https://docs.rs/csv/1.0.0/csv/struct.ReaderBuilder.html#method.flexible) config knob.) This explains why the first data record is printed in this example, since it has the same number of fields as the header record. That is, we don’t actually hit an error until we parse the second data record.

(Note that the CSV reader automatically interprets the first record as a header. This can be toggled with the [ReaderBuilder::has_headers](https://docs.rs/csv/1.0.0/csv/struct.ReaderBuilder.html#method.has_headers) config knob.)

So what actually causes the panic to happen in our program? That would be the first line in our loop:

```rust
for result in rdr.records() {
    let record = result.expect("a CSV record"); // this panics
    println!("{:?}", record);
}
```

The key thing to understand here is that `rdr.records()` returns an iterator that yields `Result` values. That is, instead of yielding records, it yields a `Result` that contains either a record or an error. The `expect` method, which is defined on `Result`, unwraps the success value inside the `Result`. Since the `Result` might contain an error instead, `expect` will panic when it does contain an error.

It might help to look at the implementation of `expect`:

```rust
use std::fmt;

// This says, "for all types T and E, where E can be turned into a human
// readable debug message, define the `expect` method."
impl<T, E: fmt::Debug> Result<T, E> {
    fn expect(self, msg: &str) -> T {
        match self {
            Ok(t) => t,
            Err(e) => panic!("{}: {:?}", msg, e),
        }
    }
}
```

Since this causes a panic if the CSV data is invalid, and invalid CSV data is a perfectly predictable error, we’ve turned what should be a recoverable error into an _unrecoverable_ error. We did this because it is expedient to use unrecoverable errors. Since this is bad practice, we will endeavor to avoid unrecoverable errors throughout the rest of the tutorial.

## Switch to recoverable errors

We’ll convert our unrecoverable error to a recoverable error in 3 steps. First, let’s get rid of the panic and print an error message manually:

```rust
extern crate csv;

use std::io;
use std::process;

fn main() {
    let mut rdr = csv::Reader::from_reader(io::stdin());
    for result in rdr.records() {
        // Examine our Result.
        // If there was no problem, print the record.
        // Otherwise, print the error message and quit the program.
        match result {
            Ok(record) => println!("{:?}", record),
            Err(err) => {
                println!("error reading CSV from <stdin>: {}", err);
                process::exit(1);
            }
        }
    }
}
```

If we run our program again, we’ll still see an error message, but it is no longer a panic message:

```
$ cat invalid
header1,header2
foo,bar
quux,baz,foobar
$ ./target/debug/csvtutor < invalid
StringRecord { position: Some(Position { byte: 16, line: 2, record: 1 }), fields: ["foo", "bar"] }
error reading CSV from <stdin>: CSV error: record 2 (line: 3, byte: 24): found record with 3 fields, but the previous record has 2 fields
```

The second step for moving to recoverable errors is to put our CSV record loop into a separate function. This function then has the option of returning an error, which our main function can then inspect and decide what to do with.

```rust
extern crate csv;

use std::error::Error;
use std::io;
use std::process;

fn main() {
    if let Err(err) = run() {
        println!("{}", err);
        process::exit(1);
    }
}

fn run() -> Result<(), Box<Error>> {
    let mut rdr = csv::Reader::from_reader(io::stdin());
    for result in rdr.records() {
        // Examine our Result.
        // If there was no problem, print the record.
        // Otherwise, convert our error to a Box<Error> and return it.
        match result {
            Err(err) => return Err(From::from(err)),
            Ok(record) => {
              println!("{:?}", record);
            }
        }
    }
    Ok(())
}
```

Our new function, run, has a return type of `Result<()`, `Box<Error>>`. In simple terms, this says that run either returns nothing when successful, or if an error occurred, it returns a `Box<Error>`, which stands for “any kind of error.” A `Box<Error>` is hard to inspect if we cared about the specific error that occurred. But for our purposes, all we need to do is gracefully print an error message and exit the program.

The third and final step is to replace our explicit match expression with a special Rust language feature: the question mark.

```rust
extern crate csv;

use std::error::Error;
use std::io;
use std::process;

fn main() {
    if let Err(err) = run() {
        println!("{}", err);
        process::exit(1);
    }
}

fn run() -> Result<(), Box<Error>> {
    let mut rdr = csv::Reader::from_reader(io::stdin());
    for result in rdr.records() {
        // This is effectively the same code as our `match` in the
        // previous example. In other words, `?` is syntactic sugar.
        let record = result?;
        println!("{:?}", record);
    }
    Ok(())
}
```

This last step shows how we can use the ? to automatically forward errors to our caller without having to do explicit case analysis with `match` ourselves. We will use the ? heavily throughout this tutorial, and it’s important to note that it can **only be used in functions that return** `Result`.

We’ll end this section with a word of caution: using `Box<Error>` as our error type is the minimally acceptable thing we can do here. Namely, while it allows our program to gracefully handle errors, it makes it hard for callers to inspect the specific error condition that occurred. However, since this is a tutorial on writing command line programs that do CSV parsing, we will consider ourselves satisfied. If you’d like to know more, or are interested in writing a library that handles CSV data, then you should check out my [blog post on error handling](http://blog.burntsushi.net/rust-error-handling/).

With all that said, if all you’re doing is writing a one-off program to do CSV transformations, then using methods like expect and panicking when an error occurs is a perfectly reasonable thing to do. Nevertheless, this tutorial will endeavor to show idiomatic code.

    -- to be continued