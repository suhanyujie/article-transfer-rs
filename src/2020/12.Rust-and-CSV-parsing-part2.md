>* Rust and CSV parsing 译文（用 Rust 实现 csv 解析-part2）
>* 原文链接：https://blog.burntsushi.net/csv/
>* 原文作者：[BurntSushi](https://github.com/BurntSushi)
>* 译文来自：https://github.com/suhanyujie/article-transfer-rs/
>* 译者：[suhanyujie](https://github.com/suhanyujie)
>* 译者博客：[suhanyujie](https://ishenghuo.cnblogs.com/)
>* ps：水平有限，翻译不当之处，还请指正。
>* 标签：Rust，csv

## Setup
In this section, we’ll get you setup with a simple program that reads CSV data and prints a “debug” version of each record. This assumes that you have the [Rust toolchain installed](https://www.rust-lang.org/install.html), which includes both Rust and Cargo.
>在这一节中，我们会编写一个简单的程序来读去 CSV 数据并以 debug 的方式打印每条记录。这是基于你已经安装了 [Rust 工具链](https://www.rust-lang.org/install.html)，工具链中包含了 Rust 编译器和 Cargo（包管理工具）。

我们以创建一个新的 Cargo 项目作为开始：

```
$ cargo new --bin csvtutor
$ cd csvtutor
```

Once inside `csvtutor`, open `Cargo.toml` in your favorite text editor and add `csv = "1"` to your [dependencies] section. At this point, your `Cargo.toml` should look something like this:
>进入 `csvtutor`，使用你最喜欢的文本编辑器打开 `Cargo.toml` 文件，向其中新增 `csv = "1"` 到你的依赖配置块中。此时，你的 `Cargo.toml` 文件内容应该如下方所示：

```toml
[package]
name = "csvtutor"
version = "0.1.0"
authors = ["Your Name"]

[dependencies]
csv = "1"
```

Next, let’s build your project. Since you added the csv crate as a dependency, Cargo will automatically download it and compile it for you. To build your project, use Cargo:
>接下来，我们构建项目。由于你新增了 csv crate 作为依赖，Cargo 会自动下载并编译它。构建项目使用 Cargo 命令：

```
$ cargo build
```

This will produce a new binary, `csvtutor`, in your `target/debug` directory. It won’t do much at this point, but you can run it:
>在你的 `target/debug` 目录下，会产生一个新的二进制文件，`csvtutor`。这一点上它不会做太多，但你可以执行这个二进制文件：

```
$ ./target/debug/csvtutor
Hello, world!
```

Let’s make our program do something useful. Our program will read CSV data on stdin and print debug output for each record on stdout. To write this program, open `src/main.rs` in your favorite text editor and replace its contents with this:
>我们可以让程序做一些有用的事情。程序可以从标准输入读取 csv 数据并在标准输出打印每一条记录。要完成这个程序，先用你喜欢的编辑器打开 `src/main.rs`，然后用下面的内容替换其中的内容：

```rust
// 这可以让你的程序能访问 csv crate
extern crate csv;

// 导入标准库中的 I/O 模块，这样我们可以从标准输入读取内容
use std::io;

// `main` 函数是程序开始执行的地方
fn main() {
    // 从标准输入读取数据并创建一个 CSV 解析器
    let mut rdr = csv::Reader::from_reader(io::stdin());
    // 遍历每一条记录
    for result in rdr.records() {
        // 一旦发生错误，程序将会以不太友好的方式终止
        // 我们后面会优化这里
        let record = result.expect("a CSV record");
        // 以 debug 的方式打印
        println!("{:?}", record);
    }
}
```

Don’t worry too much about what this code means; we’ll dissect it in the next section. For now, try rebuilding your project:
>别太担心读不懂代码的意思；我们会在下一节详细说明。现在，重新构建一下项目：

```
$ cargo build
```

Assuming that succeeds, let’s try running our program. But first, we will need some CSV data to play with! For that, we will use a random selection of 100 US cities, along with their population size and geographical coordinates. (We will use this same CSV data throughout the entire tutorial.) To get the data, download it from github:
>如果成功了，我们可以尝试运行一下它。但在此之前，我们需要一些示例 CSV 数据！为此，我们将选择随机的 100 个美国城市，以及它们的人口规模和地理坐标。（我们将在整个教程中使用一样的 CSV 数据）要获取数据，请从 GitHub 下载：

```
$ curl -LO 'https://raw.githubusercontent.com/BurntSushi/rust-csv/master/examples/data/uspop.csv'
```

And now finally, run your program on uspop.csv:
>现在，使用 uspop.csv 来运行你的程序：

```
$ ./target/debug/csvtutor < uspop.csv
StringRecord(["Davidsons Landing", "AK", "", "65.2419444", "-165.2716667"])
StringRecord(["Kenai", "AK", "7610", "60.5544444", "-151.2583333"])
StringRecord(["Oakman", "AL", "", "33.7133333", "-87.3886111"])
# ... and much more
```

## Basic error handling
>基础的异常处理

Since reading CSV data can result in errors, error handling is pervasive throughout the examples in this tutorial. Therefore, we’re going to spend a little bit of time going over basic error handling, and in particular, fix our previous example to show errors in a more friendly way. **If you’re already comfortable with things like `Result` and `try!/?` in Rust, then you can safely skip this section**.
>由于读取 CSV 数据可能会得到异常结果，因此本教程中的示例中是普遍存在的。因此，我们将花一点时间来学习基本的错误处理，特别是修复我们前面的一些示例，一遍更友好地显示错误。**如果你已经习惯在 Rust 中使用 `Result` 和 `try!/?`，那么你可以安全地跳过这个部分**

Note that The [Rust Programming Language Book](https://doc.rust-lang.org/book/second-edition/) contains an [introduction to general error handling](https://doc.rust-lang.org/book/second-edition/ch09-00-error-handling.html). For a deeper dive, see [my blog post on error handling in Rust](http://blog.burntsushi.net/rust-error-handling/). The blog post is especially important if you plan on building Rust libraries.
>请注意 [Rust 权威指南](https://doc.rust-lang.org/book/second-edition/)中包含了一些[通用的异常处理的介绍](https://doc.rust-lang.org/book/second-edition/ch09-00-error-handling.html)。如果要更深入的了解，可以看我的 [Rust 中的错误处理](http://blog.burntsushi.net/rust-error-handling/)。如果你打算构建 Rust 库，那么这篇文章尤其重要。

With that out of the way, error handling in Rust comes in two different forms: unrecoverable errors and recoverable errors.
>这样一来，Rust 中的错误处理就有两种不同的形式：不可恢复的错误和可恢复的错误。

Unrecoverable errors generally correspond to things like bugs in your program, which might occur when an invariant or contract is broken. At that point, the state of your program is unpredictable, and there’s typically little recourse other than panicking. In Rust, a panic is similar to simply aborting your program, but it will unwind the stack and clean up resources before your program exits.
>不可恢复的异常通常是程序中的异常，这些异常可能发生在规则被破坏的时候。此时，你的程序的状态是不可预测的，除了 panic 之外，通常也没有什么其他办法。在 Rust 中，panic 类似于简单地终止程序，但是它会在程序退出之前展开堆栈并清理资源。

On the other hand, recoverable errors generally correspond to predictable errors. A non-existent file or invalid CSV data are examples of recoverable errors. In Rust, recoverable errors are handled via `Result`. A `Result` represents the state of a computation that has either succeeded or failed. It is defined like so:
>另一方面，可恢复异常通常应用于可预测的错误。不存在的文件或者无效的 CSV 数据是可恢复错误的例子。在 Rust 中，可恢复异常是通过 `Result` 处理的。一个 `Result` 表示计算成功或者失败的状态。它的定义如下：

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

That is, a `Result` either contains a value of type `T` when the computation succeeds, or it contains a value of type `E` when the computation fails.

The relationship between unrecoverable errors and recoverable errors is important. In particular, it is **strongly discouraged** to treat recoverable errors as if they were unrecoverable. For example, panicking when a file could not be found, or if some CSV data is invalid, is considered bad practice. Instead, predictable errors should be handled using Rust’s `Result` type.

With our new found knowledge, let’s re-examine our previous example and dissect its error handling.

```rust
extern crate csv;

use std::io;

fn main() {
    let mut rdr = csv::Reader::from_reader(io::stdin());
    for result in rdr.records() {
        let record = result.expect("a CSV record");
        println!("{:?}", record);
    }
}
```

There are two places where an error can occur in this program. The first is if there was a problem reading a record from stdin. The second is if there is a problem writing to stdout. In general, we will ignore the latter problem in this tutorial, although robust command line applications should probably try to handle it (e.g., when a broken pipe occurs). The former however is worth looking into in more detail. For example, if a user of this program provides invalid CSV data, then the program will panic:

```
$ cat invalid
header1,header2
foo,bar
quux,baz,foobar
$ ./target/debug/csvtutor < invalid
StringRecord { position: Some(Position { byte: 16, line: 2, record: 1 }), fields: ["foo", "bar"] }
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: UnequalLengths { pos: Some(Position { byte: 24, line: 3, record: 2 }), expected_len: 2, len: 3 }', /checkout/src/libcore/result.rs:859
note: Run with `RUST_BACKTRACE=1` for a backtrace.
```

What happened here? First and foremost, we should talk about why the CSV data is invalid. The CSV data consists of three records: a header and two data records. The header and first data record have two fields, but the second data record has three fields. By default, the csv crate will treat inconsistent record lengths as an error. (This behavior can be toggled using the [ReaderBuilder::flexible](https://docs.rs/csv/1.0.0/csv/struct.ReaderBuilder.html#method.flexible) config knob.) This explains why the first data record is printed in this example, since it has the same number of fields as the header record. That is, we don’t actually hit an error until we parse the second data record.

(Note that the CSV reader automatically interprets the first record as a header. This can be toggled with the [ReaderBuilder::has_headers](https://docs.rs/csv/1.0.0/csv/struct.ReaderBuilder.html#method.has_headers) config knob.)

So what actually causes the panic to happen in our program? That would be the first line in our loop:

```rust
for result in rdr.records() {
    let record = result.expect("a CSV record"); // this panics
    println!("{:?}", record);
}
```

The key thing to understand here is that `rdr.records()` returns an iterator that yields `Result` values. That is, instead of yielding records, it yields a `Result` that contains either a record or an error. The `expect` method, which is defined on `Result`, unwraps the success value inside the `Result`. Since the `Result` might contain an error instead, `expect` will panic when it does contain an error.

It might help to look at the implementation of `expect`:

```rust
use std::fmt;

// This says, "for all types T and E, where E can be turned into a human
// readable debug message, define the `expect` method."
impl<T, E: fmt::Debug> Result<T, E> {
    fn expect(self, msg: &str) -> T {
        match self {
            Ok(t) => t,
            Err(e) => panic!("{}: {:?}", msg, e),
        }
    }
}
```

Since this causes a panic if the CSV data is invalid, and invalid CSV data is a perfectly predictable error, we’ve turned what should be a recoverable error into an _unrecoverable_ error. We did this because it is expedient to use unrecoverable errors. Since this is bad practice, we will endeavor to avoid unrecoverable errors throughout the rest of the tutorial.

## Switch to recoverable errors

We’ll convert our unrecoverable error to a recoverable error in 3 steps. First, let’s get rid of the panic and print an error message manually:

```rust
extern crate csv;

use std::io;
use std::process;

fn main() {
    let mut rdr = csv::Reader::from_reader(io::stdin());
    for result in rdr.records() {
        // Examine our Result.
        // If there was no problem, print the record.
        // Otherwise, print the error message and quit the program.
        match result {
            Ok(record) => println!("{:?}", record),
            Err(err) => {
                println!("error reading CSV from <stdin>: {}", err);
                process::exit(1);
            }
        }
    }
}
```

If we run our program again, we’ll still see an error message, but it is no longer a panic message:

```
$ cat invalid
header1,header2
foo,bar
quux,baz,foobar
$ ./target/debug/csvtutor < invalid
StringRecord { position: Some(Position { byte: 16, line: 2, record: 1 }), fields: ["foo", "bar"] }
error reading CSV from <stdin>: CSV error: record 2 (line: 3, byte: 24): found record with 3 fields, but the previous record has 2 fields
```

The second step for moving to recoverable errors is to put our CSV record loop into a separate function. This function then has the option of returning an error, which our main function can then inspect and decide what to do with.

```rust
extern crate csv;

use std::error::Error;
use std::io;
use std::process;

fn main() {
    if let Err(err) = run() {
        println!("{}", err);
        process::exit(1);
    }
}

fn run() -> Result<(), Box<Error>> {
    let mut rdr = csv::Reader::from_reader(io::stdin());
    for result in rdr.records() {
        // Examine our Result.
        // If there was no problem, print the record.
        // Otherwise, convert our error to a Box<Error> and return it.
        match result {
            Err(err) => return Err(From::from(err)),
            Ok(record) => {
              println!("{:?}", record);
            }
        }
    }
    Ok(())
}
```

Our new function, run, has a return type of `Result<()`, `Box<Error>>`. In simple terms, this says that run either returns nothing when successful, or if an error occurred, it returns a `Box<Error>`, which stands for “any kind of error.” A `Box<Error>` is hard to inspect if we cared about the specific error that occurred. But for our purposes, all we need to do is gracefully print an error message and exit the program.

The third and final step is to replace our explicit match expression with a special Rust language feature: the question mark.

```rust
extern crate csv;

use std::error::Error;
use std::io;
use std::process;

fn main() {
    if let Err(err) = run() {
        println!("{}", err);
        process::exit(1);
    }
}

fn run() -> Result<(), Box<Error>> {
    let mut rdr = csv::Reader::from_reader(io::stdin());
    for result in rdr.records() {
        // This is effectively the same code as our `match` in the
        // previous example. In other words, `?` is syntactic sugar.
        let record = result?;
        println!("{:?}", record);
    }
    Ok(())
}
```

This last step shows how we can use the ? to automatically forward errors to our caller without having to do explicit case analysis with `match` ourselves. We will use the ? heavily throughout this tutorial, and it’s important to note that it can **only be used in functions that return** `Result`.

We’ll end this section with a word of caution: using `Box<Error>` as our error type is the minimally acceptable thing we can do here. Namely, while it allows our program to gracefully handle errors, it makes it hard for callers to inspect the specific error condition that occurred. However, since this is a tutorial on writing command line programs that do CSV parsing, we will consider ourselves satisfied. If you’d like to know more, or are interested in writing a library that handles CSV data, then you should check out my [blog post on error handling](http://blog.burntsushi.net/rust-error-handling/).

With all that said, if all you’re doing is writing a one-off program to do CSV transformations, then using methods like expect and panicking when an error occurs is a perfectly reasonable thing to do. Nevertheless, this tutorial will endeavor to show idiomatic code.

    -- to be continued