>* Rust and CSV parsing 译文（用 Rust 实现 csv 解析-part3）
>* 原文链接：https://blog.burntsushi.net/csv/
>* 原文作者：[BurntSushi](https://github.com/BurntSushi)
>* 译文来自：https://github.com/suhanyujie/article-transfer-rs/
>* 译者：[suhanyujie](https://github.com/suhanyujie)
>* 译者博客：[suhanyujie](https://ishenghuo.cnblogs.com/)
>* ps：水平有限，翻译不当之处，还请指正。
>* 标签：Rust，csv

## 读取 CSV
Now that we’ve got you setup and covered basic error handling, it’s time to do what we came here to do: handle CSV data. We’ve already seen how to read CSV data from stdin, but this section will cover how to read CSV data from files and how to configure our CSV reader to data formatted with different delimiters and quoting strategies.
>现在我们设置并介绍了基本的错误处理，这下我们可以执行我们真正要做的事情：处理 CSV 数据。我们前面已经了解了如何从 stdin 中读取 CSV 数据，但本节将介绍如何从文件中读取 CSV 数据，以及如何将 CSV reader 配置为支持读取不同的分隔符或格式策略的数据。

First up, let’s adapt the example we’ve been working with to accept a file path argument instead of stdin.
>首先，我们修改前面那个示例，以使其接受文件路径参数而不是从 stdin 中读取。

```rust
extern crate csv;

use std::env;
use std::error::Error;
use std::ffi::OsString;
use std::fs::File;
use std::process;

fn run() -> Result<(), Box<Error>> {
    let file_path = get_first_arg()?;
    let file = File::open(file_path)?;
    let mut rdr = csv::Reader::from_reader(file);
    for result in rdr.records() {
        let record = result?;
        println!("{:?}", record);
    }
    Ok(())
}

/// 返回发送给此进程的第一个参数。如果没有，则返回一个错误。
fn get_first_arg() -> Result<OsString, Box<Error>> {
    match env::args_os().nth(1) {
        None => Err(From::from("expected 1 argument, but got none")),
        Some(file_path) => Ok(file_path),
    }
}

fn main() {
    if let Err(err) = run() {
        println!("{}", err);
        process::exit(1);
    }
}
```

If you replace the contents of your src/main.rs file with the above code, then you should be able to rebuild your project and try it out:
>如果用上面的代码你替换了 src/main.rs 文件的内容，你应该能够重新构建你的项目，尝试运行它：

```
$ cargo build
$ ./target/debug/csvtutor uspop.csv
StringRecord(["Davidsons Landing", "AK", "", "65.2419444", "-165.2716667"])
StringRecord(["Kenai", "AK", "7610", "60.5544444", "-151.2583333"])
StringRecord(["Oakman", "AL", "", "33.7133333", "-87.3886111"])
# ... and much more
```

This example contains two new pieces of code:
>示例代码包含两部分：

* Code for querying the positional arguments of your program. We put this code into its own function called get_first_arg. Our program expects a file path in the first position (which is indexed at 1; the argument at index 0 is the executable name), so if one doesn’t exist, then get_first_arg returns an error.
>查询程序当前所处的位置参数。我们将这段代码放入它自己的函数调用 get_first_arg 中。函数中，期望第一个参数是文件路径（索引为 1；索引 0 的参数是是可执行文件的名称），因此，如果不存在， get_first_arg 将返回一个错误。
* Code for opening a file. In run, we open a file using File::open. If there was a problem opening the file, we forward the error to the caller of run (which is main in this program). Note that we do not wrap the File in a buffer. The CSV reader does buffering internally, so there’s no need for the caller to do it.
>用于打开文件的代码。在运行时，我们使用 file:open 打开一个文件。如果在打开文件时出现问题，我们将错误转发给其调用者（在这个程序中就是 main）。注意，我们没有将文件内容包装在缓冲区中。CSV reader 在内部会有缓冲区，因此不需要调用者再声明一个缓冲区。

Now is a good time to introduce an alternate CSV reader constructor, which makes it slightly more convenient to open CSV data from a file. That is, instead of:
>现在是引入另一个 CSV reader 构造函数的好时机。它会使打开 CSV 文件更加便利。而不是使用下面这个：

```rust
let file_path = get_first_arg()?;
let file = File::open(file_path)?;
let mut rdr = csv::Reader::from_reader(file);
```

你可以使用：

```rust
let file_path = get_first_arg()?;
let mut rdr = csv::Reader::from_path(file_path)?;
```

`csv::Reader::from_path` will open the file for you and return an error if the file could not be opened.
>`csv::Reader::from_path` 会打开文件，并在异常时返回错误。

## 读取 headers

If you had a chance to look at the data inside uspop.csv, you would notice that there is a header record that looks like this:
>如果有机会可以看一下 uspop.csv 的内部数据，你会注意到，它的头部记录看起来像下面这样：

```
City,State,Population,Latitude,Longitude
```

Now, if you look back at the output of the commands you’ve run so far, you’ll notice that the header record is never printed. Why is that? By default, the CSV reader will interpret the first record in CSV data as a header, which is typically distinct from the actual data in the records that follow. Therefore, the header record is always skipped whenever you try to read or iterate over the records in CSV data.
>现在，如果你看看目前所有的示例程序的命令行输出，你会注意到，头部记录从未打印出来，这是为何呢？，默认情况下，CSV reader 将读取 CSV 数据中的第一条记录作为头部，第一行记录通常不作为实际数据。因此，每当你尝试读取或迭代 CSV 数据时，头记录会被跳过。

The CSV reader does not try to be smart about the header record and does not employ any heuristics for automatically detecting whether the first record is a header or not. Instead, if you don’t want to treat the first record as a header, you’ll need to tell the CSV reader that there are no headers.
>CSV reader 不会智能地处理头记录，也不会使用任何聪明的方法来自动检测第一个记录是否为头记录。相反，如果你不想将第一个记录作为头记录，那么你需要告诉 CSV reader，没有头记录。

To configure a CSV reader to do this, we’ll need to use a ReaderBuilder to build a CSV reader with our desired configuration. Here’s an example that does just that. (Note that we’ve moved back to reading from stdin, since it produces terser examples.)
>要配置 CSV reader 来实现这一点，我们需要使用一个 ReaderBuilder 来构建一个 CSV reader。这里有个示例。（注意，代码中回到了从 stdin 中读取数据，因为这样的示例更简洁。）

```rust
fn run() -> Result<(), Box<Error>> {
    let mut rdr = csv::ReaderBuilder::new()
        .has_headers(false)
        .from_reader(io::stdin());
    for result in rdr.records() {
        let record = result?;
        println!("{:?}", record);
    }
    Ok(())
}
```

If you compile and run this program with our uspop.csv data, then you’ll see that the header record is now printed:
>如果你用我们的 uspop.csv 作为输入构建程序，那么你会看到头记录将被打印出来：

```
$ cargo build
$ ./target/debug/csvtutor < uspop.csv
StringRecord(["City", "State", "Population", "Latitude", "Longitude"])
StringRecord(["Davidsons Landing", "AK", "", "65.2419444", "-165.2716667"])
StringRecord(["Kenai", "AK", "7610", "60.5544444", "-151.2583333"])
StringRecord(["Oakman", "AL", "", "33.7133333", "-87.3886111"])
```

If you ever need to access the header record directly, then you can use the Reader::headers method like so:
>如果你需要直接访问头记录，那么你可以使用 Reader::headers 方法，示例如下：

```rust
fn run() -> Result<(), Box<Error>> {
    let mut rdr = csv::Reader::from_reader(io::stdin());
    {
        // 由于生命周期的原因，我们将此调用嵌套在一个新的词法作用域中。
        let headers = rdr.headers()?;
        println!("{:?}", headers);
    }
    for result in rdr.records() {
        let record = result?;
        println!("{:?}", record);
    }
    // 我们可以任意的获取 header。没有必要建立新的作用域进行调用，因为我们再也不需要借用 reader 中的数据。
    let headers = rdr.headers()?;
    println!("{:?}", headers);
    Ok(())
}
```

One interesting thing to note in this example is that we put the call to rdr.headers() in its own scope. We do this because rdr.headers() returns a borrow of the reader’s internal header state. The nested scope in this code allows the borrow to end before we try to iterate over the records. If we didn’t nest the call to rdr.headers() in its own scope, then the code wouldn’t compile because we cannot borrow the reader’s headers at the same time that we try to borrow the reader to iterate over its records.
>在本例中要注意一件有趣的事是，我们对 rdr.headers() 的调用会放在一个独立的作用域中。之所以这样做，是因为 rdr.headers() 返回 reader 内部的 header 借用。此代码中的大括号嵌套的作用域可以让在我们遍历之前结束借用。如果我们没有将 rdr.headers() 的调用放在新的作用域中，那么代码将无法通过编译，因为我们不能在尝试借用 reader 来迭代它的记录的同时，又借用它的头部。

Another way of solving this problem is to clone the header record:
>解决这个问题的另一个方法是克隆 header：

```rust
let headers = rdr.headers()?.clone();
```

This converts it from a borrow of the CSV reader to a new owned value. This makes the code a bit easier to read, but at the cost of copying the header record into a new allocation.
>这将原本使用来自 CSV reader 的 header 借用转变为拥有一个新值的所有权。这使代码更易懂，但代价是需要新的内存分配存放头记录。

    -- 未完待续
    