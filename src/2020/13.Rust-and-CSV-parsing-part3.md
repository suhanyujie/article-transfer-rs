>* Rust and CSV parsing 译文（用 Rust 实现 csv 解析-part3）
>* 原文链接：https://blog.burntsushi.net/csv/
>* 原文作者：[BurntSushi](https://github.com/BurntSushi)
>* 译文来自：https://github.com/suhanyujie/article-transfer-rs/
>* 译者：[suhanyujie](https://github.com/suhanyujie)
>* 译者博客：[suhanyujie](https://ishenghuo.cnblogs.com/)
>* ps：水平有限，翻译不当之处，还请指正。
>* 标签：Rust，csv

## Reading CSV
Now that we’ve got you setup and covered basic error handling, it’s time to do what we came here to do: handle CSV data. We’ve already seen how to read CSV data from stdin, but this section will cover how to read CSV data from files and how to configure our CSV reader to data formatted with different delimiters and quoting strategies.

First up, let’s adapt the example we’ve been working with to accept a file path argument instead of stdin.

```rust
extern crate csv;

use std::env;
use std::error::Error;
use std::ffi::OsString;
use std::fs::File;
use std::process;

fn run() -> Result<(), Box<Error>> {
    let file_path = get_first_arg()?;
    let file = File::open(file_path)?;
    let mut rdr = csv::Reader::from_reader(file);
    for result in rdr.records() {
        let record = result?;
        println!("{:?}", record);
    }
    Ok(())
}

/// Returns the first positional argument sent to this process. If there are no
/// positional arguments, then this returns an error.
fn get_first_arg() -> Result<OsString, Box<Error>> {
    match env::args_os().nth(1) {
        None => Err(From::from("expected 1 argument, but got none")),
        Some(file_path) => Ok(file_path),
    }
}

fn main() {
    if let Err(err) = run() {
        println!("{}", err);
        process::exit(1);
    }
}
```

If you replace the contents of your src/main.rs file with the above code, then you should be able to rebuild your project and try it out:

```
$ cargo build
$ ./target/debug/csvtutor uspop.csv
StringRecord(["Davidsons Landing", "AK", "", "65.2419444", "-165.2716667"])
StringRecord(["Kenai", "AK", "7610", "60.5544444", "-151.2583333"])
StringRecord(["Oakman", "AL", "", "33.7133333", "-87.3886111"])
# ... and much more
```

This example contains two new pieces of code:

* Code for querying the positional arguments of your program. We put this code into its own function called get_first_arg. Our program expects a file path in the first position (which is indexed at 1; the argument at index 0 is the executable name), so if one doesn’t exist, then get_first_arg returns an error.
* Code for opening a file. In run, we open a file using File::open. If there was a problem opening the file, we forward the error to the caller of run (which is main in this program). Note that we do not wrap the File in a buffer. The CSV reader does buffering internally, so there’s no need for the caller to do it.

Now is a good time to introduce an alternate CSV reader constructor, which makes it slightly more convenient to open CSV data from a file. That is, instead of:

```rust
let file_path = get_first_arg()?;
let file = File::open(file_path)?;
let mut rdr = csv::Reader::from_reader(file);
```

you can use:

```rust
let file_path = get_first_arg()?;
let mut rdr = csv::Reader::from_path(file_path)?;
```

`csv::Reader::from_path` will open the file for you and return an error if the file could not be opened.

## Reading headers

If you had a chance to look at the data inside uspop.csv, you would notice that there is a header record that looks like this:

```
City,State,Population,Latitude,Longitude
```

Now, if you look back at the output of the commands you’ve run so far, you’ll notice that the header record is never printed. Why is that? By default, the CSV reader will interpret the first record in CSV data as a header, which is typically distinct from the actual data in the records that follow. Therefore, the header record is always skipped whenever you try to read or iterate over the records in CSV data.

The CSV reader does not try to be smart about the header record and does not employ any heuristics for automatically detecting whether the first record is a header or not. Instead, if you don’t want to treat the first record as a header, you’ll need to tell the CSV reader that there are no headers.

To configure a CSV reader to do this, we’ll need to use a ReaderBuilder to build a CSV reader with our desired configuration. Here’s an example that does just that. (Note that we’ve moved back to reading from stdin, since it produces terser examples.)

```rust
fn run() -> Result<(), Box<Error>> {
    let mut rdr = csv::ReaderBuilder::new()
        .has_headers(false)
        .from_reader(io::stdin());
    for result in rdr.records() {
        let record = result?;
        println!("{:?}", record);
    }
    Ok(())
}
```

If you compile and run this program with our uspop.csv data, then you’ll see that the header record is now printed:

```
$ cargo build
$ ./target/debug/csvtutor < uspop.csv
StringRecord(["City", "State", "Population", "Latitude", "Longitude"])
StringRecord(["Davidsons Landing", "AK", "", "65.2419444", "-165.2716667"])
StringRecord(["Kenai", "AK", "7610", "60.5544444", "-151.2583333"])
StringRecord(["Oakman", "AL", "", "33.7133333", "-87.3886111"])
```

If you ever need to access the header record directly, then you can use the Reader::headers method like so:

```rust
fn run() -> Result<(), Box<Error>> {
    let mut rdr = csv::Reader::from_reader(io::stdin());
    {
        // We nest this call in its own scope because of lifetimes.
        let headers = rdr.headers()?;
        println!("{:?}", headers);
    }
    for result in rdr.records() {
        let record = result?;
        println!("{:?}", record);
    }
    // We can ask for the headers at any time. There's no need to nest this
    // call in its own scope because we never try to borrow the reader again.
    let headers = rdr.headers()?;
    println!("{:?}", headers);
    Ok(())
}
```

One interesting thing to note in this example is that we put the call to rdr.headers() in its own scope. We do this because rdr.headers() returns a borrow of the reader’s internal header state. The nested scope in this code allows the borrow to end before we try to iterate over the records. If we didn’t nest the call to rdr.headers() in its own scope, then the code wouldn’t compile because we cannot borrow the reader’s headers at the same time that we try to borrow the reader to iterate over its records.

Another way of solving this problem is to clone the header record:

```rust
let headers = rdr.headers()?.clone();
```

This converts it from a borrow of the CSV reader to a new owned value. This makes the code a bit easier to read, but at the cost of copying the header record into a new allocation.

    -- to be continued
    