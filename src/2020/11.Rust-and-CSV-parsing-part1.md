>* Rust and CSV parsing 译文（用 Rust 实现 csv 解析）
>* 原文链接：https://blog.burntsushi.net/csv/
>* 原文作者：[BurntSushi](https://github.com/BurntSushi)
>* 译文来自：https://github.com/suhanyujie/article-transfer-rs/
>* 译者：[suhanyujie](https://github.com/suhanyujie)
>* 译者博客：[suhanyujie](https://ishenghuo.cnblogs.com/)
>* ps：水平有限，翻译不当之处，还请指正。
>* 标签：Rust，csv

With csv 1.0 just released, the time is ripe for a tutorial on how to read and write CSV data in Rust. This tutorial is targeted toward beginning Rust programmers, and is therefore full of examples and spends some time on basic concepts. Experienced Rust programmers may find parts of this useful, but would probably be happier with a quick skim.

For an introduction to Rust, please see the [official book](https://doc.rust-lang.org/book/second-edition/). If you haven’t written any Rust code yet but have written code in another language, then this tutorial might be accessible to you without needing to read the book first.

The CSV library is [available on Github](https://github.com/BurntSushi/rust-csv) and has [comprehensive API documentation](https://docs.rs/csv).

Finally, a version of this blog post is included as a [tutorial](https://docs.rs/csv/1.0.0/csv/tutorial/index.html) in the API documentation, and is more likely to be updated as time passes.

Target audience: Beginning Rust programmers.

## Table of contents

* csv 1.0 release
* Setup
* Basic error handling
    * Switch to recoverable errors
* Reading CSV
    * Reading headers
    * Delimiters, quotes and variable length records
    * Reading with Serde
    * Handling invalid data with Serde
* Writing CSV
    * Writing tab separated values
    * Writing with Serde
* Pipelining
    * Filter by search
    * Filter by population count
* Performance
    * Amortizing allocations
    * Serde and zero allocation
    * CSV parsing without the standard library
* Closing thoughts

## CSV 1.0 release
Before diving into the tutorial, I wanted to briefly recount the road to 1.0. The first commit to the rust-csv repository was on March 22, 2014, which is a little more than an entire year before the Rust 1.0 release. For those of you that have been involved with Rust since before 1.0, you will surely remember just how much the language changed. And of course, I changed as well, as I became more familiar with the language and its idioms. However, the CSV library API mostly remained unchanged since its original version. The API made it difficult to increase performance and fix several outstanding bugs, and worst of all, was using the old serialization infrastructure.

The CSV 1.0 release marks a library that is faster, has a better API and brings support for [Serde](https://serde.rs/), Rust’s serialization framework.

The new CSV library comes with a [`csv-core`](https://docs.rs/csv-core) crate, which can parse CSV data without Rust’s standard library and is predominantly responsible for the performance improvements. In particular, the old CSV library used a type of finite state machine that had a lot of overhead. The csv-core crate compiles its parser down to a table based DFA that occupies only a few hundred bytes on the stack. As a result, we get approximately a factor of 2 improvement across the board:

```
count_game_deserialize_owned_bytes  30,404,805 (85 MB/s)   23,878,089 (108 MB/s)    -6,526,716  -21.47%   x 1.27
count_game_deserialize_owned_str    30,431,169 (85 MB/s)   22,861,276 (113 MB/s)    -7,569,893  -24.88%   x 1.33
count_game_iter_bytes               21,751,711 (119 MB/s)  11,873,257 (218 MB/s)    -9,878,454  -45.41%   x 1.83
count_game_iter_str                 25,609,184 (101 MB/s)  13,769,390 (188 MB/s)   -11,839,794  -46.23%   x 1.86
count_game_read_bytes               12,110,082 (214 MB/s)  6,686,121 (388 MB/s)     -5,423,961  -44.79%   x 1.81
count_game_read_str                 15,497,249 (167 MB/s)  8,269,207 (314 MB/s)     -7,228,042  -46.64%   x 1.87
count_mbta_deserialize_owned_bytes  5,779,138 (125 MB/s)   3,775,874 (191 MB/s)     -2,003,264  -34.66%   x 1.53
count_mbta_deserialize_owned_str    5,777,055 (125 MB/s)   4,353,921 (166 MB/s)     -1,423,134  -24.63%   x 1.33
count_mbta_iter_bytes               3,991,047 (181 MB/s)   1,805,387 (400 MB/s)     -2,185,660  -54.76%   x 2.21
count_mbta_iter_str                 4,726,647 (153 MB/s)   2,354,842 (307 MB/s)     -2,371,805  -50.18%   x 2.01
count_mbta_read_bytes               2,690,641 (268 MB/s)   1,253,111 (577 MB/s)     -1,437,530  -53.43%   x 2.15
count_mbta_read_str                 3,399,631 (212 MB/s)   1,743,035 (415 MB/s)     -1,656,596  -48.73%   x 1.95
count_nfl_deserialize_owned_bytes   10,608,513 (128 MB/s)  5,828,747 (234 MB/s)     -4,779,766  -45.06%   x 1.82
count_nfl_deserialize_owned_str     10,612,366 (128 MB/s)  6,814,770 (200 MB/s)     -3,797,596  -35.78%   x 1.56
count_nfl_iter_bytes                6,798,767 (200 MB/s)   2,564,448 (532 MB/s)     -4,234,319  -62.28%   x 2.65
count_nfl_iter_str                  7,888,662 (172 MB/s)   3,579,865 (381 MB/s)     -4,308,797  -54.62%   x 2.20
count_nfl_read_bytes                4,588,369 (297 MB/s)   1,911,120 (714 MB/s)     -2,677,249  -58.35%   x 2.40
count_nfl_read_str                  5,755,926 (237 MB/s)   2,847,833 (479 MB/s)     -2,908,093  -50.52%   x 2.02
count_pop_deserialize_owned_bytes   11,052,436 (86 MB/s)   8,848,364 (108 MB/s)     -2,204,072  -19.94%   x 1.25
count_pop_deserialize_owned_str     11,054,638 (86 MB/s)   9,184,678 (104 MB/s)     -1,869,960  -16.92%   x 1.20
count_pop_iter_bytes                6,190,345 (154 MB/s)   3,110,704 (307 MB/s)     -3,079,641  -49.75%   x 1.99
count_pop_iter_str                  7,679,804 (124 MB/s)   4,274,842 (223 MB/s)     -3,404,962  -44.34%   x 1.80
count_pop_read_bytes                3,898,119 (245 MB/s)   2,218,535 (430 MB/s)     -1,679,584  -43.09%   x 1.76
count_pop_read_str                  5,195,237 (183 MB/s)   3,209,998 (297 MB/s)     -1,985,239  -38.21%   x 1.62
```

With all the goodies out of the way, let’s begin!
