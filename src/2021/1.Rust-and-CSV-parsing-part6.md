>* Rust and CSV parsing 译文（用 Rust 实现 csv 解析-part6）
>* 原文链接：https://blog.burntsushi.net/csv/
>* 原文作者：[BurntSushi](https://github.com/BurntSushi)
>* 译文来自：https://github.com/suhanyujie/article-transfer-rs/
>* 译者：[suhanyujie](https://github.com/suhanyujie)
>* 译者博客：[suhanyujie](https://ishenghuo.cnblogs.com/)
>* ps：水平有限，翻译不当之处，还请指正。
>* 标签：Rust，csv

## Writing tab separated values
In the previous section, we saw how to write some simple CSV data to `stdout` that looked like this:
>在前面的章节中，我们了解了如何将 CSV 数据输出到标准输出中，如下：

```
City,State,Population,Latitude,Longitude
Davidsons Landing,AK,,65.2419444,-165.2716667
Kenai,AK,7610,60.5544444,-151.2583333
Oakman,AL,,33.7133333,-87.3886111
```

You might wonder to yourself: what’s the point of using a CSV writer if the data is so simple? Well, the benefit of a CSV writer is that it can handle all types of data without sacrificing the integrity of your data. That is, it knows when to quote fields that contain special CSV characters (like commas or new lines) or escape literal quotes that appear in your data. The CSV writer can also be easily configured to use different delimiters or quoting strategies.
>

In this section, we’ll take a look at how to tweak some of the settings on a CSV writer. In particular, we’ll write TSV (“tab separated values”) instead of CSV, and we’ll ask the CSV writer to quote all non-numeric fields. Here’s an example:

```rust
fn run() -> Result<(), Box<Error>> {
    let mut wtr = csv::WriterBuilder::new()
        .delimiter(b'\t')
        .quote_style(csv::QuoteStyle::NonNumeric)
        .from_writer(io::stdout());

    wtr.write_record(&["City", "State", "Population", "Latitude", "Longitude"])?;
    wtr.write_record(&["Davidsons Landing", "AK", "", "65.2419444", "-165.2716667"])?;
    wtr.write_record(&["Kenai", "AK", "7610", "60.5544444", "-151.2583333"])?;
    wtr.write_record(&["Oakman", "AL", "", "33.7133333", "-87.3886111"])?;

    wtr.flush()?;
    Ok(())
}
```

Compiling and running this example gives:

```shell
$ cargo build
$ ./target/debug/csvtutor
"City"  "State" "Population"    "Latitude"      "Longitude"
"Davidsons Landing"     "AK"    ""      65.2419444      -165.2716667
"Kenai" "AK"    7610    60.5544444      -151.2583333
"Oakman"        "AL"    ""      33.7133333      -87.3886111
```

In this example, we used a new type [QuoteStyle](https://docs.rs/csv/1.0.0/csv/enum.QuoteStyle.html). The `QuoteStyle` type represents the different quoting strategies available to you. The default is to add quotes to fields only when necessary. This probably works for most use cases, but you can also ask for quotes to always be put around fields, to never be put around fields or to always be put around non-numeric fields.

## Writing with Serde

Just like the CSV reader supports automatic deserialization into Rust types with Serde, the CSV writer supports automatic serialization from Rust types into CSV records using Serde. In this section, we’ll learn how to use it.

As with reading, let’s start by seeing how we can serialize a Rust tuple.

```rust
fn run() -> Result<(), Box<Error>> {
    let mut wtr = csv::Writer::from_writer(io::stdout());

    // We still need to write headers manually.
    wtr.write_record(&["City", "State", "Population", "Latitude", "Longitude"])?;

    // But now we can write records by providing a normal Rust value.
    //
    // Note that the odd `None::<u64>` syntax is required because `None` on
    // its own doesn't have a concrete type, but Serde needs a concrete type
    // in order to serialize it. That is, `None` has type `Option<T>` but
    // `None::<u64>` has type `Option<u64>`.
    wtr.serialize(("Davidsons Landing", "AK", None::<u64>, 65.2419444, -165.2716667))?;
    wtr.serialize(("Kenai", "AK", Some(7610), 60.5544444, -151.2583333))?;
    wtr.serialize(("Oakman", "AL", None::<u64>, 33.7133333, -87.3886111))?;

    wtr.flush()?;
    Ok(())
}
```

Compiling and running this program gives the expected output:

```shell
$ cargo build
$ ./target/debug/csvtutor
City,State,Population,Latitude,Longitude
Davidsons Landing,AK,,65.2419444,-165.2716667
Kenai,AK,7610,60.5544444,-151.2583333
Oakman,AL,,33.7133333,-87.3886111
```

The key thing to note in the above example is the use of `serialize` instead of `write_record` to write our data. In particular, `write_record` is used when writing a simple record that contains string-like data only. On the other hand, `serialize` is used when your data consists of more complex values like numbers, floats or optional values. Of course, you could always convert the complex values to strings and then use `write_record`, but Serde can do it for you automatically.

As with reading, we can also serialize custom structs as CSV records. As a bonus, the fields in a struct will automatically be written as a header record!

To write custom structs as CSV records, we’ll need to make use of the `serde_derive` crate again. As in the [previous section on reading with Serde](https://blog.burntsushi.net/csv/#reading-with-serde), we’ll need to add a couple crates to our [dependencies] section in our Cargo.toml (if they aren’t already there):

```
serde = "1"
serde_derive = "1"
```

And we’ll also need to add a couple extra `extern crate` statements to our code, as shown in the example:

```rust
extern crate csv;
extern crate serde;
 #[macro_use]
extern crate serde_derive;

use std::error::Error;
use std::io;
use std::process;

// Note that structs can derive both Serialize and Deserialize!
 #[derive(Debug, Serialize)]
 #[serde(rename_all = "PascalCase")]
struct Record<'a> {
    city: &'a str,
    state: &'a str,
    population: Option<u64>,
    latitude: f64,
    longitude: f64,
}

fn run() -> Result<(), Box<Error>> {
    let mut wtr = csv::Writer::from_writer(io::stdout());

    wtr.serialize(Record {
        city: "Davidsons Landing",
        state: "AK",
        population: None,
        latitude: 65.2419444,
        longitude: -165.2716667,
    })?;
    wtr.serialize(Record {
        city: "Kenai",
        state: "AK",
        population: Some(7610),
        latitude: 60.5544444,
        longitude: -151.2583333,
    })?;
    wtr.serialize(Record {
        city: "Oakman",
        state: "AL",
        population: None,
        latitude: 33.7133333,
        longitude: -87.3886111,
    })?;

    wtr.flush()?;
    Ok(())
}

fn main() {
    if let Err(err) = run() {
        println!("{}", err);
        process::exit(1);
    }
}
```

Compiling and running this example has the same output as last time, even though we didn’t explicitly write a header record:

```shell
$ cargo build
$ ./target/debug/csvtutor
City,State,Population,Latitude,Longitude
Davidsons Landing,AK,,65.2419444,-165.2716667
Kenai,AK,7610,60.5544444,-151.2583333
Oakman,AL,,33.7133333,-87.3886111
```

In this case, the `serialize` method noticed that we were writing a struct with field names. When this happens, `serialize` will automatically write a header record (only if no other records have been written) that consists of the fields in the struct in the order in which they are defined. Note that this behavior can be disabled with the [`WriterBuilder::has_headers`](https://docs.rs/csv/1.0.0/csv/struct.WriterBuilder.html#method.has_headers) method.

It’s also worth pointing out the use of a lifetime parameter in our `Record` struct:

```rust
struct Record<'a> {
    city: &'a str,
    state: &'a str,
    population: Option<u64>,
    latitude: f64,
    longitude: f64,
}
```

The 'a lifetime parameter corresponds to the lifetime of the `city` and `state` string slices. This says that the `Record` struct contains _borrowed_ data. We could have written our struct without borrowing any data, and therefore, without any lifetime parameters:

```rust
struct Record {
    city: String,
    state: String,
    population: Option<u64>,
    latitude: f64,
    longitude: f64,
}
```

However, since we had to replace our borrowed `&str` types with owned `String` types, we’re now forced to allocate a new `String` value for both of `city` and `state` for every record that we write. There’s no intrinsic problem with doing that, but it might be a bit wasteful.

For more examples and more details on the rules for serialization, please see the [`Writer::serialize`](https://docs.rs/csv/1.0.0/csv/struct.Writer.html#method.serialize) method.

## Pipelining
>* to be continued...
